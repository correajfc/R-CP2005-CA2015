# Procesamiento y análisis de datos {#anayproc}

El procesamiento de los datos se realizó  principalmente en @R-base. Se usó [QGIS](http://www.qgis.org/es/site/) para conectarse a los servicios WFS del IDESC y previsualizar las capas de información geográfica recolectada y la realización de algunos de los mapas detallados.

El código que implementa  los análisis está dividido en archivos para facilitar su lectura, cada uno de los cuales se encargan de transformar los datos de las fuentes y construir estructuras de datos necesarias para realizar las regresiones, las gráficas y los análisis de tipo estadístico y geoestadístico. Cada script implementa una fase de la metodología y produce resultados intermedios que facilitan seguir y reproducir dichas transformaciones sobre los datos de un dominio del problema. El archivo de `funciones.R` agrupa funciones que encapsulan funcionalidades recurrentes dentro del desarrollo del análisis. El script de `geodata.R` opera sobre los fuentes de datos geográficas necesarias para consolidar los índices de acceso a espacios verdes (EV),  los indicadores y variables de la estructura de física de los sectores censales y unidades geográficas del análisis. El script `arboles,R` consolida la información de cada uno de los individuos del censo arbóreo agregandolos por sector censal. El scrript `censopoblacion.R` consolida los datos del Censo de Población 2005. Los scripts `consolidarDatos.R` y `analisis_exploratorio.R` consolidan una única estructura con todos los datos y produce una serie de gráficas y medidas de correlación, que son base para la identificación de supuestos y selección de las variables independientes para los análisis estadísticos y las regresiones espaciales. Finalmente los script de `analisis_estadistico.R` y `analisis_geoestadistico.R` implementan las regresiones lineales y las regresiones espaciales respectivamente, así como los test y tablas para la verificación de los supuesto matemáticos y la verificación de la calidad de los resultados.  Todos estos están reunidos en un script que carga las librerías necesarias y ejecuta secuencialmente cada de los scripts descritos.
```{r code-main, eval=FALSE, echo=TRUE, fig.cap="Script principal"}
# Scrip principal para la la ejecución de los .R

#librerias

library(rgdal)
library(rgeos)
library(raster)
library(sp)

library(tidyverse)
library(magrittr)
library(stringr)

library(viridis)
library(RColorBrewer)
library(gridExtra)

library(visdat)
library(GGally)
library(wesanderson)

library(ggrepel)


#  correr los script en el orden correcto para realizar todos los calculos 

source("funciones.R")
source("geodata.R")
source("arboles.R")
source("censopoblacion.R")
source("consolidarDatos.R")
source("analisis_exploratorio.R")
source("analisis_estadistico.R")
source("analisis_geoestadistico.R")


```




## Capas de información geográfica

Para usar la información geográfica de la cartografía censal y la información del IDESC es necesario establecer un sistema de coordenadas común, en unidades métricas, que facilite integrar la información y produzca resultados consistentes. El sistema de coordenadas proyectadas que vamos a usar es @noauthor_magna-sirgas-cali_nodate. Para cargar y manipular los datos espaciales hacemos uso de las librerías `rgdal` [@R-rgdal], `rgeos` [@R-rgeos] y `sp` [@R-sp]. 

El siguiente mapa muestra los sectores urbanos con sus respectivos códigos de identificación descritos en la documentación que acompaña la cartografía.


```{r mapa-su,fig.width=6, fig.asp=1.41, fig.cap="Sectores Urbanos del Censo del 2005. Los sectores seleccionados están parcial o totalmente contenidos en el perímetro urbano 2015"}

ggplot()+
  geom_polygon(data = su.f,aes(x=long,y=lat,group=group),
               fill="lightgrey",color="white")+
  coord_equal()+
   with(su.setu_ccdgo, annotate(geom="text", x = long, y=lat, label = ids_su, 
                                size = 1.8,
                                color="black"))+
  theme_void()

```

La capa de manzanas es necesaria para refinar las capas de espacio verde y poder calcular el área de calle , área privada y otras métricas sobre la estructura de cada sector sector censal y que servirán como criterios para la selección de sectores urbanos a incluir en los análisis de regresión.

```{r mapa-manzana, fig.width=6, fig.asp=0.8, fig.cap="Coropleta del tamaño de manzana.Se usaron 10 grupos con aprox. el mismo número de observaciones"}
#pintar usando colores por quantil
manzanas.su.f%>%
  ggplot(aes(x=long,y=lat,group=group))+
  geom_polygon(aes(fill=cut_number(area_manzana,n = 10)))+
  coord_equal()+
  theme_void()+
  viridis::scale_fill_viridis(discrete = TRUE, direction = -1)
```

Las capas de equipamiento de la EEC y espacio público se consolidan en una sola capa conservando la mayor cantidad de información sobre la clasificación de los tipos de espacios disponibles. El resultado puede ver verse de forma total (ver figuara \@ref(fig:mapa-ev)) o por tipo de espacio (figuras \@ref(fig:mapa-ev-facet) y \@ref(fig:mapa-ev-color)).

```{r mapa-ev, fig.width=6, fig.asp=0.8, fig.cap="Espacio verdes consolidados y sectores urbanos"}
# espacios publicos (verdes)
base_plot.manzanas2 +
  geom_path(data = su.f,aes(x=long,y=lat,group=group),
            color="lightskyblue",
            size=0.5)+
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group),
               fill="deeppink",
               alpha=0.7)+
                                
  theme_void()
```


```{r mapa-ev-color, fig.width=6, fig.asp=0.8, fig.cap="Espacio verde por categoría"}
base_plot.manzanas2 + 
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group,
               fill=tolower(categoria)),
               alpha=1)+
  
  theme_void()+
  scale_fill_manual(name = "Tipo EV",values = palKata[c(9,8,7,6,1,5,4,10,2,3)])
```


```{r mapa-ev-facet,  fig.asp=1.5, fig.cap="Small Multiple del espacio verde por categoría"}
# facets por tipo de espacio 
  ggplot()+
  geom_polygon(data = su.f,aes(x=long,y=lat,group=group),
            fill="grey80",
            color ="white",
            size=0.1
            )+
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group),
               fill="deeppink",
               alpha=1)+
    coord_equal()+
  theme_void()+
  facet_wrap(~categoria, ncol = 4)+
  theme(strip.text.x = element_text(size = 8))
```

### Índices de acceso a espacios verdes

Para mejorar la lectura de esta sección se incluyen a continuación las ecuaciones que definen los índices de acceso seleccionados y las variantes definidas en este trabajo.

#### Índices de acceso basados en área {-}
**índice contenedor** (area_ep)
\begin{equation}
A^{C}_i =\sum_j{s_j} \;  \; \forall  j \in I
(\#eq:cont)
\end{equation}
donde $s_j$ es el área de cada espacio verde $j$ que pertenece al conjunto $I$ de EV dentro del sector $i$.

**índice contenedor porcentual** (area_ep.porcentaje)
\begin{equation}
A^{C_p}_i =1/a_i\sum_j{s_j} \;  \; \forall  j \in I
(\#eq:n-cont)
\end{equation}
donde $a_i$ es el área del sector $i$.

**índice área disponible en radio** (ia.areas.1000)
\begin{equation}
A^{AR}_i= \sum_{\int R_b }{(s_j}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:area-radio)
\end{equation}
donde $R_b$ es el radio de búsqueda,  $s_j$ es el área de cada espacio verde $j$ que pertenece al conjunto $I_{R_b}$ de EVs en el radio de búsqueda.

**índice porcentual de área disponible en radio** (ia.areas.1000.porcentaje)
\begin{equation}
A^{AR_p}_i= 1/a_t \sum_{\int R_b }{(s_j}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:area-radio)
\end{equation}
donde $a_t$ es el área total de espacio verde en la ciudad.

#### Índices de acceso basados en distancia {-}

**costo de viaje** (ia.costoviaje)
\begin{equation}
A^{T}_i =\sum_j{d_{ij}} \; \; \forall  j \in I_t
(\#eq:costo)
\end{equation}
donde $d_{ij}$ es la distancia del centriode del sector $i$ al espacio $j$ e $I_t$ es el conjunto de todos los epacios verdes de la ciudad. 

**costo de viaje normalizado** (ia.costo.n)
\begin{equation}
\bar{A}^{T_n}_i =A^{T}_i/N 
(\#eq:n-costo)
\end{equation}
donde $N$ es el número total de espacio verdes en la ciudad.

**distancia mínima** (ia.mindist)
\begin{equation}
A^{M}_i=min\left | d_{ij} \right | \forall  j \in I_t
(\#eq:min-dist)
\end{equation}

#### Índices de acceso mixtos {-}

**razón área distancia** (ia.A.D)
\begin{equation}
A^{AD}_i= \sum_{\int R_b }{s_j/d_{ij}}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:area-dist)
\end{equation}
donde $R_b$ es el radio de búsqueda,  $s_j$ es el área de cada espacio verde $j$, $d_{ij}$ es la distancia del centriode del sector $i$ al espacio $j$  que pertenecen al conjunto $I_{R_b}$ de EVs en el radio de búsqueda. 

**razón área disponible distancia** (ia.areas.dist)
\begin{equation}
\bar{A}^{AD}_i= \frac{\sum_{\int R_b }{s_j}}{\sum_{\int R_b }{d_{ij}}}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:areas-dists)
\end{equation}


Con los datos consolidados se calculan las áreas de los espacios verdes al interior de cada sector censal, para calcular los índices de acceso tipo contenedor (ecuación \@ref(eq:cont)) interceptando los espacio verdes con los sectores urbanos (ecuación \@ref(eq:n-cont)). También se obtuvo una versión del índice contenedor como en porcentaje del área del SU. El cálculo de los índices de costo de viajes (ecuación \@ref(eq:costo)) y costo de viaje normalizado (ecuación \@ref(eq:n-costo)) se obtiene creado una matriz de distancia entre los centroides de los sectores censales y cada uno de los espacios verdes. De esta matriz de distancia también se obtiene el índice de distancia mínima (ecuación \@ref(eq:min-dist)). 

Los mapas de los índices de acceso basados en distancia se muestran en la figura \@ref(fig:mapas-ia-distancia)

```{r mapas-ia-distancia, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia en escala continua"}

pl_acceso_dist<-plots_map_su_df(metricas.acceso.df,metricas.acceso[c(1,2,7)])
grid.arrange(grobs =pl_acceso_dist, nrow =1)
```

```{r mapas-ia-distancia-deciles, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.acceso.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.acceso %in% metricas.acceso[c(1,2,7)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.acceso, nrow = 1)+
  tema_lgnd_abajo()
```


Además de los índices basados en distancia y el tipo contenedor se calcularon índices de acceso basados en el área de espacio verde en un radio de 1000 metros. Estos índices muestran un dimensión relacionada no con solo con el acceso sino con la cantidad de espacio disponible en el radio de busqueda definido desde el centroide del sector censal. Para hacernos una idea del radio de búsqueda seleccionado, el siguiente mapa muestra los radios búsqueda y los espacios verdes. 

```{r mapa-rango1km,  fig.asp=0.8, fig.cap="Espacio verdes y rango de 1 km desde centriodes de SU"}
ggplot()+
  geom_polygon(data = s_1000_df, 
               aes(x=long,y=lat,group=group),
               fill = "salmon",
               alpha = 0.2)+
  geom_path(data = su.f,aes(x=long,y=lat,group=group),
            color="grey40",
            size=0.4)+
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group),
               fill="royalblue",
               alpha=0.5)+
  coord_equal()+
  theme_void()
```



Los índices de acceso basados en área descritos en las ecuaciones \@ref(eq:cont),\@ref(eq:n-cont) y\@ref(eq:area-radio) se resumen en la siguiente gráfica.

```{r mapas-ia-area,   fig.asp=1, fig.cap="Small Multiple de los indices de acceso a EV basados en área usando escala continua"}
pl_acceso_dist<-plots_map_su_df(metricas.acceso.df,metricas.acceso[c(8,9,10,11)])
grid.arrange(grobs =pl_acceso_dist, ncol =2)

```

```{r mapas-ia-area-deciles, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.acceso.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.acceso %in% metricas.acceso[c(8,9,10,11)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.acceso, nrow = 1)+
  tema_lgnd_abajo()
```

En la búsqueda de índices de acceso más complejos que reflejen el acceso en distancia y la cantidad de área disponible desde cada sector urbano se construyeron índices similares a el índice de distancia de a pie (ecuación \@ref(eq:walkdist) que se basan en la razón entre el área a la que se accede y la distancia a la que se encuentra del centroide del sector. Dos nuevos índices se proponen en este trabajo: ia.areas.dist (ecuación \@ref(eq:areas-dists)) como la suma de las áreas en el rango de 1 km desde el centroide del SU dividido la suma de las distancia a esos EV; ia.A.D (ecuación \@ref(eq:area-dist)) , que es la suma de las razones entre el área del espacio verde $j$ dividido entre la distancia $d_{ij}$ desde el centroide del SU $i$ al EV $j$. La siguiente gráfica muestra las métricas propuestas.

```{r mapas-ia-area-dist, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en área y distancia usando escala continua"}
pl_acceso_mix<-plots_map_su_df(metricas.acceso.df,metricas.acceso[c(13:14)])
grid.arrange(grobs =pl_acceso_mix, ncol =2)

```

```{r mapas-ia-area-dist-deciles, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.acceso.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.acceso %in% metricas.acceso[c(13,14)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.acceso, nrow = 1)+
  tema_lgnd_abajo()
```

Además de los mapas es de interes observar la distribución en frecuencia de las métricas de acceso. La siguiente gráfica se observan los histogramas de las metricas calculadas.

```{r hist-acceso,  fig.asp=1.5, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
analisis.cali.df %>% select(one_of(metricas.acceso[c(1,2,7,8,9,10,11,13,14)])) %>%
  gather( key = metricas.acceso,
          value = valores,
          ia.costoviaje:ia.A.D) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="steelblue")+
  facet_wrap(~metricas.acceso, scales = "free", ncol = 2)
```


Finalmente se muestra el código en R que calcula los índices presentados, y el resumen de los índices calculados. 

```{r resumen-ia}
summary(analisis.cali.df[,metricas.acceso[c(1,2,7,8,9,10,11,13,14)]])
```

```{r code-indices-acceso, eval= FALSE, echo=TRUE}
# matriz distancia entre centriodes y espacios
m.dist.ctrdsu.ep<-gDistance(ep.cali,centroides.su, byid = T) 
#cuando el punto esta dentro del poligono el valor que rertorna es 0
# por ese motivo le pondremos 10 a valores = 0 o entre 0 y 10 para 
# evitar problemas al invertir la matriz y mejorar la conistencia del indices
# con valores inversos a la distancia
m.dist.ctrdsu.ep[m.dist.ctrdsu.ep < 10]<- 10
# matriz consicion de estar a 1000 del centriodo
is.1000.ep<-gWithinDistance(ep.cali,centroides.su,1001, byid = T)
# cantidad de espacio verdes en radio de 1000 m de los centriodes del sector urbano
num.ep.1000<-apply(is.1000.ep,1,function(x)  sum(x,na.rm =T))
#distancias de Espacio publicos a 1000 del centriode de SU
a<-m.dist.ctrdsu.ep*is.1000.ep

# distancia minima distinta de 0
ia.mindist<-apply(m.dist.ctrdsu.ep,1,function(x)  min(x[x!=0]))
index.min<-apply(m.dist.ctrdsu.ep,1,function(x)  which.min(x[x!=0]))
ia.area.mindist<-ep.cali$area_ep[index.min]/ia.mindist
# suma de las distancias a cada EP por centriode 
ia.costoviaje<-apply(m.dist.ctrdsu.ep,1,sum)
# suma de las distancias a cada EP ubicado a menos de 1000 m del centriode
ia.1000<-apply(a,1,function (x) sum(x))
ia.1000[ia.1000==0]<-NA
ia.1000.n<-ia.1000/num.ep.1000
# indice de la suma de las areas en el rango de un 1 km del sector censal
ia.areas.1000<-is.1000.ep %*% ep.cali$area_ep %>% as.vector()
# indice de area disponible en el radio de 1km como porcentaje del area total 
# disponible 

ia.areas.1000.porcentaje<-ia.areas.1000/sum(ep.cali$area_ep)

# matriz de distancias inversas de centriode su a espacios verdes  
m.dist.ctrdsu.1000.ep.inv<-1/a
b<-m.dist.ctrdsu.1000.ep.inv*is.finite(m.dist.ctrdsu.1000.ep.inv) # eliminar infinitos
# suma de inverso de las distancias a cada EP ubicado a menos de 1000 m del centriode
ia.1000.inv<-apply(b,1,function (x) sum(x,na.rm = T))
ia.1000.inv[ia.1000.inv==0]<-NA
#razon entre Area del EP y distancia al centriode
A.D<-t(t(b)*ep.cali$area_ep)

# sumatoria de la razon entre Area del EP y distancias de ese EP al centriode
ia.A.D<-apply(A.D,1,function (x) sum(x,na.rm = T))
class(ia.costoviaje)
summary(ia.costoviaje)
length(ia.costoviaje)
summary(ia.1000.inv)
length(ia.A.D)
summary(ia.A.D)

# consolidadcionde indices calculados
ia.ev<-data.frame(su$SETU_CCDGO,ia.costoviaje)
ia.ev$ia.costo.n<-ia.ev$ia.costoviaje/dim(m.dist.ctrdsu.ep)[2]
ia.ev<-bind_cols(ia.ev,data.frame(ia.1000,
                                  ia.1000.inv,
                                  ia.1000.n,
                                  ia.areas.1000,
                                  ia.areas.1000.porcentaje
                                  ))
ia.ev$ia.r300<-300*ia.1000.inv
ia.ev<-ia.ev%>%dplyr::rename(SETU_CCDGO=su.SETU_CCDGO)
ia.ev$ia.mindist<-ia.mindist
ia.ev$ia.area.mindist<-ia.area.mindist
ia.ev$ia.A.D<-ia.A.D
smry.area<-summary(ep.cali$area_ep)
ia.ev$ia.r300.Amedia<- 300/smry.area[4]*ia.ev$ia.A.D
ia.ev$ia.r300.Amediana<- 300/smry.area[3]*ia.ev$ia.A.D
ia.ev$ia.areas.dist<-ia.areas.1000/ia.1000


```



## Datos del censo arbóreo 2015 {#sec-ca2015}

El censo arbóreo del año 2015 consolidó un inventario de la vegetación de la ciudad compuesto por `r sum(altura_copa_por_cobertura$cantidad)` individuos. Entre las variables que categorizan los individuos censados están el tipo de emplazamiento, tipo de suelo que cubre la vegetación, la edad, la vitalidad, tipo de vegetación y sus caratetiristicas dasometricas p.ej la altura, el diamtro de la copa, altura y diametro del pecho, etc ..., entro otras relacionadas con el estado fitosanitario y daños físicos.

A continuación se presentan una serie de tablas que resumen las caraterísticas seleccionadas en la tabla \@ref(tab:vars-AU) para el análisis (por tipo de vegetación \@ref(tab:ca2015-vegetacion), por edad \@ref(tab:ca2015-edad) y por emplazamiento \@ref(tab:ca2015-emplazamiento)), antes de aplicar los criterios de seleccón de los individuos arbóres para este estudio.

```{r ca2015-vegetacion}
knitr::kable(altura_copa_por_vegetacion,col.names = c("Tipo de vegetación", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen CA2015 por tipo de vegetación")

```

```{r ca2015-edad}
knitr::kable(altura_copa_por_edad,col.names = c("Edad", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen CA2015 por edad")

```

```{r ca2015-emplazamiento}
knitr::kable(altura_copa_por_emplazamiento,col.names = c("Emplazamiento", "altura media","diámetro medio","cantidad"),digits = 2,caption = "Resúmen CA2015 por emplazamiento")

```

Existe una diferencia de 10 años entre censo de población de 2005 y el censo arbóreo de la ciudad de Cali. Aunque esto pueda parecer una situación que reduce la legitimidad de los resultados que se hayen en este estudio, autores como @boone2010landscape y @schwarz_trees_2015 reconocen que los paisajes que vemos hoy son legados de patrones de consumo pasados, y que en el caso de la vegetación urbana tratamos con organismos de larga vida que pueden tardar mucho tiempo en establecerse y crecer. En contraste, la estructura social de las ciudades puede cambiar más rápidamente. 

Como se menciona en la metodología, la apuesta para reducir la brecha es la exclusión de los árboles jóvenes del inventario, que posiblemente no estaban ahí en 2005. Aunque no conocemos las tasa anual de tala de árboles en la ciudad, y dado es posible que una parte importante de los árboles jóvenes haya reemplazado a los los que fueron talados, no parece realista mantener el inventario entero. 

Aunque en general toda la vegetación aporta beneficios ambientales a los habitantes, en este estudio descartamos la vegetación arbustiva y los árboles, palmas y bambú de menos de 1.9 m de altura para circunscribirnos a los individuos más desarrollados. 

Una vez aplicado este filtro contamos con `r nrow(AU_analsis)` individuos. Las tablas de resumen para la selección de indivuduos con base en estos criterios se muestran a contiunuación.



```{r ca2015sel-vegetacion}
res_vegetacion<-AU_analsis %>% 
  group_by(vegetacion) %>% 
  summarise(altura_media_vegetacion=mean(altura_arbol),
            diametro_medio_copa_vegetacion = mean(diametro_copa),cantidad=n()) 


knitr::kable(res_vegetacion,col.names = c("Tipo de vegetación", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen selección CA2015 por tipo de vegetación")

```

```{r ca2015sel-edad}


res_edad<-AU_analsis %>% 
  group_by(edad) %>% 
  summarise(altura_media_vegetacion=mean(altura_arbol),
            diametro_medio_copa_vegetacion = mean(diametro_copa),cantidad=n()) 

knitr::kable(res_edad,col.names = c("Edad", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen selección CA2015 por edad")

```

```{r ca2015sel-emplazamiento}
res_emplazamiento<-AU_analsis %>% 
  group_by(emplazamiento) %>% 
  summarise(altura_media_vegetacion=mean(altura_arbol),
            diametro_medio_copa_vegetacion = mean(diametro_copa),cantidad=n()) 

knitr::kable(res_emplazamiento,col.names = c("Emplazamiento", "altura media","diámetro medio","cantidad"),digits = 2,caption = "Resúmen selección CA2015 por emplazamiento")

```

Para indagar sobre la distribución de estos individuos y no quedarnos con los resúmenes estadísticos se muestran a continuación los datos desagregados gráficamente cada una de las variables categóricas y las características físicas del arbolado: altura, diámetro de la copa y su ubicación en la ciudad.

En primer lugar indagamos sobre las diferencias de diámetro y altura por tipo de vegetación. La figura \@ref(fig:au-veg) muestra claramente las diferencias físicas entre los árboles (desarrollan mayor tamaño y con mayor número de individuos), el bambú y las palmas (más altos que anchos y en menor número) de la ciudad. Los árboles catalogados como secos, hace 10 años estaban vivos y los mantenemos en la selección de individuos. 


```{r au-veg,  fig.asp=1, fig.cap="caraterísticas por tipo de vegetacion"}
#caraterísticas por tipo de vegetacion
AU_analsis %>% 
  ggplot()+
  geom_point(aes(y=altura_arbol,x=diametro_copa),alpha=0.1, color ="forestgreen" )+
  coord_equal()+
  theme_bw()+
  facet_wrap( ~ vegetacion, nrow = 2 )
```

Otra característica interesante para buscar condiciones que afectan el desarrollo del arbolado, representado por la altura y el diámetro son el tipo de lugares que conforman el espacio público donde se encuentran el mayor número de ellos. En la figura \@ref(fig:au-emplaz-veg) se observa la desagregación de los individuos por tipo de emplazamiento en gráficas individuales de altura y diámetro, y en color el tipo de vegetación. Es notorio en la figura que los parques urbanos  y escenarios deportivos son los equipamientos que mayor cantidad de individuos y más desarrollos alojan. Caso aparte son los andenes y separadores viales como se ve en la tabla \@ref(tab:ca2015sel-emplazamiento) y el gráfico alojan `r round((92198+28924)*100/nrow(AU_analsis),digits =2)`% de los individuos. Esto puede ser un hecho que incita a incluir elementos estructurales en los modelos que explican desde aspectos estructurales de los barrios la cobertura de copa. Por supuesto las rondas de ríos y canales dada su disponibilidad de agua condicionan el desarrollo de los individuos arbóreos y su cantidad. 

```{r au-emplaz-veg,  fig.asp=1.5, fig.cap="Caraterísticas por tipo de vegetación y emplazamiento"}
AU_analsis %>% 
  #filter(vegetacion %in% c("Arbol","Bambu","Palma")) %>%
  ggplot()+
  geom_point(aes(y=altura_arbol,x=diametro_copa,color=vegetacion),alpha=0.1)+
  scale_color_brewer(palette = "Dark2")+
  coord_equal()+
  facet_wrap(~emplazamiento , ncol = 4 ,labeller = label_wrap_gen())+
  guides(colour = guide_legend(override.aes = list(alpha=1)))+
  tema_lgnd_up()
```


Otra forma de ver los datos de resumen de las tabla \@ref(tab:ca2015sel-emplazamiento) y que completa la visión sobre la distribución de los datos en relación al desarrollo físico de los individuos arbóreos es la distribución de los diámetros (figura \@ref(fig:au-diametro-emp))y las alturas (figura \@ref(fig:au-altura-emp)) en relación con el emplazamiento. En ambas gráficas el punto rojo representa el valor promedio


```{r au-diametro-emp,  fig.asp=0.8, fig.cap="Variabilidad del diámetro de copa por emplazamiento"}
AU_analsis %>% 
ggplot( aes(x=emplazamiento,y=diametro_copa))+
  geom_jitter(position = position_jitter(0.3),alpha=0.1, color = "forestgreen")+ 
  stat_summary(fun.y = mean, geom = "point", shape = 18, size = 3, color = "tomato")+
  stat_summary(aes(label=round(..y..,digits = 2)),fun.y = mean, geom = "text", color = "tomato", hjust = -0.5, size =3)+
  coord_flip()+
  tema_lgnd_up()

```

```{r au-altura-emp,  fig.asp=0.8, fig.cap="Variabilidad de la altura de los arboles por emplazamiento"}
AU_analsis %>% 
  ggplot( aes(x=emplazamiento,y=altura_arbol))+
  geom_jitter(position = position_jitter(0.3),alpha=0.1, color = "forestgreen")+ 
  stat_summary(fun.y = mean, geom = "point", shape = 18, size = 3, color = "tomato")+
  stat_summary(aes(label=round(..y..,digits = 2)),fun.y = mean, geom = "text", color = "tomato", hjust = -0.5, size =3)+
  coord_flip()+
  tema_lgnd_up()

```

Finalmente en la figura \@ref(fig:au-geo-emp) graficamos los individuos en pequeños mapa por tipo de emplazamiento para observar su distribución geográfica. Es notorio que los árboles están distribuidos en toda la ciudad dada la disponibilidad de andenes aptos para alojarlos. Esto invita a explorar la relación que pueda existir entre el tamaño de los andenes de los barrios y el desarrollo físico de los individuos, ya que las vías con separadores viales y en consecuencia con más espacio para que árboles de mayor tamaño puedan desarrollarse es consistente con el valor medio de la altura y el diámetro sean mayores que el de los andenes. Sin embargo este hecho escapa del alcance de este trabajo y puede ser indagado por otras investigaciones. 

```{r au-geo-emp,  fig.asp=1.5, fig.cap="Small multiples de los individuos arbóreos por emplazamiento"}
# puntos por e,mplazamiento
base_plot.manzanas + geom_point(data = AU_analsis,
                                aes(x = Este, y = Norte),
                                size=0.01,
                                color="forestgreen",
                                alpha=0.1)+
  theme_void()+
  facet_wrap(~emplazamiento , ncol = 4 ,labeller = label_wrap_gen())

```

Antes de agregar (enmascarar) los datos usando los sectores censales es interesante inspeccionar el efecto que tiene usar unidade regulares o de tamaños no uniformes como los sectores urbanos en las coberturas de copa. Para ello podemos usar hexágonos de 250 metros de ancho que cubren completamente el territorio. La figura \@ref(fig:au-geo-hex) se evidencia que existen cinturones y lugares de alta concentración de individuos y en consecuencia de mayor cobertura de copa. 

```{r au-geo-hex,  fig.asp=0.8, fig.cap="Suma de cobertura por hexagonos"}
# suma de cobertura por hex
p.hex.copa  <-base_plot.manzanas+ stat_summary_hex(data = AU_analsis,
                                 aes(x = Este, y = Norte, z = area_copa),
                               binwidth = c(250, 250),
                               fun = sum 
                               )+
    geom_path(data = su.f,
                 aes(x = long, y = lat, group = group),
              color ="grey50",
              size=0.2)+
    coord_equal()+
    scale_fill_viridis(name="área \n copa",direction = 1)+
    theme_void()
 p.hex.copa   
```

En la figura \@ref(fig:au-su-acopa) usamos los SUs para agregar los valores de área de copa. Se observa como se reduce un poco la continuidad, y se intensifica el efecto de la agregación en algunos sectores y se atenúa en otros (las figuras \@ref(fig:comp-su-hex-copa) y \@ref(fig:comp-su-hex-numarb) muestran el efecto de la agregación en el área de copa y en el número de individuos, respectivamente ). 

```{r au-su-acopa,  fig.asp=0.8, fig.cap="Area de copa por sector censal"}
p.su.copa<-su.f %>% dplyr::select(-area_su)  %>%
  left_join(analisis.cali.df,by = c("id"="SETU_CCDGO")) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = area_copa))+
  coord_equal()+
  theme_void()+
  scale_fill_viridis(name = "área \n copa", direction = 1 )
p.su.copa

```


```{r comp-su-hex-copa, fig.cap="Agregación de area de copa por hexagonos y SU"}
grid.arrange(p.hex.copa,p.su.copa, ncol = 2)


```

```{r comp-su-hex-numarb, fig.cap="Agregación de número de árboles por hexagonos y SU"}
grid.arrange(p.hex.arboles,p.su.arboles, ncol = 2)
```

Esto sugiere que usar valores porcentuales para la cobertura en relación con el área de los SU o del área no-privada de cada sector puede ser una mejor medida para caracterizar el beneficio real en cada sector censal. En razón a esta consideración y las reflexiones sobre el tema en @schwarz_trees_2015, que sugiere que la distinción entre áreas privadas y públicas también puede hablar de las superficies plantables totales que están disponibles para aumentar la cobertura de copa, calculamos entonces el porcentaje de cobertura de copa respecto del área total sector urbano y respecto del área de espacio público (área del sector censal menos el área de las manzanas privadas)^[La capa de espacio público consolidada previamente nos permite identificar las manzanas de un SU que son espacio público, y por tanto podemos obtener el área que es vía pública, las manzanas que son privadas y las manzanas que son espacio público. Así el área pública es igual a la suma del área de calle más las manzanas de espacio público o al área de SU menos el área de manzanas privadas]. Las medidas porcentuales respecto del área total y pública permiten hacer una comparación más justa entre las diferentes unidades pues relativiza los niveles totales de área de copa. Un hecho que apoya el uso de medidas en relación al espacio público de un sector censal es que el CA2015 solo se realizó para la vegetación en lugares públicos, sobre la calle o vía pública. 

En consecuencia se calcularon las métricas de área de copa en relación al área del sector urbano (`cobertura_copa.su`) y al área pública del sector urbano (`cobertura_copa.ap`). En la figura \@ref(fig:metricas-cobertura-cont) se ven los mapas en escala continua y en la figura \@ref(fig:metricas-cobertura-deciles) se reproducen los mismos mapas usando una escala en deciles. Visualmente, cobertura de copa parece en espacio público parece aproximarse mejor a los patrones de distribución que se evidencia cuando usamos la división uniforme del terreno en hexágonos (figura \@ref(fig:au-geo-hex)), razón por la cual la preferiremos sobre `cobertura_copa.su` para los análsis.


```{r metricas-cobertura-cont,fig.asp=0.618, fig.cap="Métricas de cobertura de copa: área de copa, porcentaje de área de copa respecto del sector censal (cobertura_copa.su) y cobertura de copa respecto del área pública (cobertura_copa.ap)"}
pl_copa<-plots_map_su_df(analisis.cali.df,metricas.ca[c(1,5,6)])
grid.arrange(grobs =pl_copa, nrow = 1)
```


```{r metricas-cobertura-deciles, fig.cap="Métricas de cobertura de copa: área de copa, porcentaje de área de copa respecto del sector censal y cobertura de copa respecto del área pública"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.ca.ntl.long,by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.arboles %in% metricas.ca[c(1,5,6)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.arboles, nrow = 1)+
  tema_lgnd_abajo()
```

Finalmente se muestra los histogramas y el resúmen de las métricas de cobertura arbórea calculadas. 

```{r hist-metricas-copa, fig.cap="Histograma de las métricas de la cobertura de copa"}
#histogramas arboles -----

analisis.cali.df %>% select(one_of(metricas.ca[c(1,5,6)])) %>%
  gather( key = metricas.arboles,
          value = valores,
          area_copa:cobertura_copa.ap) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30,
                 color = "white", fill="forestgreen")+
  facet_wrap(~metricas.arboles, scales = "free", ncol = 1)
```

```{r resumen-cobcopa}
analisis.cali.df %>% select(one_of(metricas.ca[c(1,5,6)])) %>%
summary()
```




## Datos del censo de población

Los datos del censo fueron descargados del aplicativo con que cuenta el DANE para dar acceso al censo de población 2005 [@censo_sistema_dane]. Los datos agregados por sectores censales los inspeccionamos a través de los resúmenes estadistico, histogramas y mapas, de forma análoga a lo realizado hasta ahora con el resto de variables. 

### Característica de la población

La tabla \@ref(tab:vars-poblacion) resumen las variables consideradas inicialmente en este trabajo, sin embargo, algunas de ellas no contienen suficiente variabilidad o el número de individuos es muy bajo en comparación con el total de la población. En la tabla \@ref(tab:totales-poblacion) se observa el bajo número de personas que pertenecen al pueblo Rom (gitanos), Palenqueros de San Basilio (departamento de Bolívar) y de Raizales del Archipiélago de San Andrés, Providencia y Santa Catalina (SAI), por lo que son descartados del análisis. La población indígena es también baja, pero no tanto como para descartarla inmediatamente.

```{r totales-poblacion}
nombre_fila<-c("Población Total","Población afrodescendiente, negros o mulatos","Población indígena","Población Rom","Población Palenqueros","Población raizales de SAI")
tot_pob<-totales.cali[11:16] %>% as_vector(.,"numeric")
tabla.tmp<-data.frame(nombre_fila,unname(tot_pob))
knitr::kable(tabla.tmp, col.names = c("Tipo","Cantidad") ,caption = "Totales de población en la ciudad de Cali")

```

La figura \@ref(fig:mapas-poblacion-cont) muestra los datos de las variables de población en espacio geografico de la ciudad usando una escala continua y la figura \@ref(fig:mapas-poblacion-deciles) lo hace usando una escala discreta (deciles).

```{r mapas-poblacion-cont, fig.asp=1.5,fig.cap="Mapas de las variables de población seleccionadas (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.poblacion[c(2,3,4,6,7)])
grid.arrange(grobs =pl_poblacion, nrow =2)

```

```{r mapas-poblacion-deciles, fig.asp=1.2,fig.cap="Mapas de las variables de población seleccionadas (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.poblacion.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.poblacion %in% metricas.poblacion[c(2,3,4,6,7)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.poblacion, nrow = 2)+
  tema_lgnd_abajo()
```

Los histogramas de estas variables en la figura \@ref(fig:hist-poblacion) siguen la tendencia que se ha venido observando en los histogramas de cobertura arbórea y de variables de acceso a espacios verdes : las distribuciones no son *normales*, tienen una inclinación a la derecha.

```{r hist-poblacion, fig.asp=1,fig.cap="Histogramas de las variables de población "}
# histogramas datos poblacion  
analisis.cali.df %>% select(one_of(metricas.poblacion)) %>%
  gather( key = metricas.poblacion,
          value = valores,
          superior_postgrado:con_alguna_limitacion,indigena,negro_mulato_afrocolombiano) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="magenta")+
  facet_wrap(~metricas.poblacion, scales = "free", ncol = 2)
```

Además de las variables seleccionadas podemos calcular indicadores que se relacionan con el teóricamente como la densidad de población: dado que los árboles compiten por el espacio con los seres humanos es de esperarse que a mayor cantidad de personas haya menos lugar para los árboles. Podemos de nuevo calcular indicadores porcentualización de las condiciones de la población para facilitar la comparaciones y acentuar las diferencias entre los diferente sectores.

A continuación se muestran los mapas en escala continua (figura \@ref(fig:mapas-poblacion-mod-cont)), discreta (figura \@ref(fig:mapas-poblacion-mod-deciles)) e histogramas (figura \@ref(fig:hist-poblacion-mod)) de los indicadores porcentuales de las condiciones y la densidad de población.

```{r mapas-poblacion-mod-cont, fig.asp=1.5,fig.cap="Mapas de las variables de población seleccionadas como porcentajes (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.poblacion.mod[c(1,2,3,5,6)])
grid.arrange(grobs =pl_poblacion, nrow =2)

```

```{r mapas-poblacion-mod-deciles, fig.asp=1.2,fig.cap="Mapas de las variables de población seleccionadas como porcentajes (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.poblacion.mod.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.poblacion.mod %in% metricas.poblacion.mod[c(1,2,3,5,6)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.poblacion.mod, nrow = 2)+
  tema_lgnd_abajo()
```

```{r hist-poblacion-mod, fig.asp=1,fig.cap="Histogramas de las variables de población como porcentaje"}
# histogramas datos poblacion  
analisis.cali.df %>% select(one_of(metricas.poblacion.mod[c(1,2,3,5,6)])) %>%
  gather( key = metricas.poblacion,
          value = valores,
          densidad_poblacion:superior_postgrado.porcentaje) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="magenta")+
  facet_wrap(~metricas.poblacion, scales = "free", ncol = 2)
```

Podemos notar que la transformación realizada al expresar las variables como porcentaje reduce la inclinación hacia la derecha de los histogramas e inclusive la corrige para el caso de personas con alguna limitación. 

Para finalizar con la inspección de los datos sobre la población se proveen el resumen estadístico de las variables.

```{r resumen-poblacion}
analisis.cali.df %>% select(one_of(c(metricas.poblacion[c(2,3,4,6,7)],metricas.poblacion.mod[c(1,2,3,5,6)]))) %>%
summary()
```

### Características de las viviendas

Además de las rasgos étnicos, condiciones de estudio y limitaciones de la población el censo de 2005 tiene disponibles datos sobre el tipo de viviendas (casa, apartamento, tipo cuarto, casa indígena, otros), y el uso habitacional, comercial y la cantidad de unidades especiales de alojamiento L.E.A dado a los predios. La vocación comercial o residencial de un barrio puede ser un factor en el desarrollo del arbolado urbano, ya sea por las condiciones físicas como por la intervención de sus habitantes. Estas variables pueden también expresarse como porcentaje de la cantidad de predios de vivienda en el caso de los tipos o como porcentaje de la cantidad de predios en el caso del uso como unidad de vivienda, económica o L.E.A.

A continuación presentamos el resumen, los mapas por sector urbano (figuras \@ref(fig:mapas-usopredios-cont) y \@ref(fig:mapas-usopredios-deciles))y los histogramas (figura \@ref(fig:hist-usopredios))de las variables sobre el uso de los predios.

```{r mapas-usopredios-cont, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo de uso de los predios como porcentaje de la cantidad de predios (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.predios[c(13:15)])
grid.arrange(grobs =pl_poblacion, nrow =1)

```

```{r mapas-usopredios-deciles, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo de uso de los predios como porcentaje de la cantidad de predios (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.predios.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.predios %in% metricas.predios[13:15]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.predios, nrow = 1)+
  tema_lgnd_abajo()
```

```{r hist-usopredios, fig.asp=0.7,fig.cap="Histogramas de las variables de uso de predios como porcentaje"}
#histogramas predios ----

analisis.cali.df %>% select(one_of(metricas.predios[13:15])) %>%
  gather( key = metricas.predios,
          value = valores,
          viviendas.porcentaje:LEA.porcentaje) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="steelblue")+
  facet_wrap(~metricas.predios, scales = "free", ncol = 1)
```

El uso de L.E.A tiene una distribución concentrada en uno pocos SU, por lo que podemos descartarla para los análisis de regresión. Existe también cierta complementariedad entre el uso de vivienda y los usos económicos de los predios, porque seguramente, si existe una correlación entre estas variables y la cobertura de copa o el acceso a espacios verdes una de las dos puede bastar para incluir esta dimensión en los modelos de regresion.

A continuación presentamos el resumen, los mapas por sector urbano (figuras \@ref(fig:mapas-viviendas-cont) y \@ref(fig:mapas-viviendas-deciles))y los histogramas (figura \@ref(fig:hist-viviendas))de las variables sobre los tipos de vivienda.

```{r mapas-viviendas-cont, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo viviendas como porcentaje (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.predios[c(9:11)])
grid.arrange(grobs =pl_poblacion, nrow =1)

```

```{r mapas-viviendas-deciles, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo viviendas como porcentaje (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.predios.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.predios %in% metricas.predios[9:11]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.predios, nrow = 1)+
  tema_lgnd_abajo()
```

```{r hist-viviendas, fig.asp=0.7,fig.cap="Histogramas de los tipo de vivienda como porcentaje"}
#histogramas predios ----

analisis.cali.df %>% select(one_of(metricas.predios[9:11])) %>%
  gather( key = metricas.predios,
          value = valores,
          casa.porcentaje:cuarto.porcentaje) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="steelblue")+
  facet_wrap(~metricas.predios, scales = "free", ncol = 1)
```

Esta primera inspección a los datos permitió descartar algunas variables a usar en los modelos de regresión sobre las coberturas y los espacios verdes, conocer la distribución espacial de los datos y perfilar las posibles variables a incluir. Sin embargo, la percepción suele ser engañosa, vemos patrones en todas partes, así que es necesario acompañar estas intuiciones con métricas estadísticas y gráficas sobre las relaciones entre las variables dependientes e independientes para ser más asertivos en las decisiones del proceso de modelado. 

## Análisis estadísticos

### Criterios y selección de sectores censales

Antes de iniciar un analaisis de regresion es importante establecer ciertos criterios pra inclusion o no de ciertos datos dentro del conjunto de varores para la regresion y calculo de la correlacion. Estos criterios estan ligados 
 creterios de excepcion de sectores urbanos a ser incluidos en el analsis de regresion:
 
- sectores sin personas
- sectores sin viviendas
- sectores area de espacio publico mayor que el 60 % del area del sector
- sectores area de calle mayor que el 80 % del area del sector
- sectores area privada mayor que el 90 % del area del sector

```{r code-excluidos, eval=FALSE, echo=TRUE}
 analisis.cali.df %>% 
   filter(is.na(personas_edad)) %>%
   select(SETU_CCDGO) -> sin_personas
 
 analisis.cali.df %>% 
   filter(uso_vivienda == 0) %>%
   select(SETU_CCDGO) -> sin_viviendas

 analisis.cali.df %>% 
   filter(area_ep.porcentaje > 0.6 ) %>%
   select(SETU_CCDGO)  -> ep_60
 
 analisis.cali.df %>% 
   filter(area_privada.porcentaje > 0.85 ) %>%
   select(SETU_CCDGO) -> privada_85
 
 analisis.cali.df %>% 
   filter(area_calle.porcentaje > 0.8 ) %>%
   select(SETU_CCDGO) -> calle_80
 
 analisis.cali.df %>% 
   filter(is.na(area_copa)) %>%
   select(SETU_CCDGO) -> sin_arboles_censado
 
 
 su.exc.apriori<-c("0204","1736",# sector con alto porcentaje no urbanizado
                   "1709",# maroria del area por fuera del perimetro urbano
                   "1317")# laguna del pandaje
```

Además de estos criterios se excluyeron los sectores donde está la Laguna el Pondaje, que cubre una porción muy importante del sector que no se ve reflejado en las otras métricas, los sectores con una porción mayor al 60% por fuera del perímetro urbano o sin urbanización visible en las imagenes satelitales. Así los sectores excluidos del análisis se muestran en los mapas \@ref(fig:mapa-excluidos) y \@ref(fig:mapa-excluidos-tipo) por criterio usado. 

```{r mapa-excluidos, fig.cap="Mapa de los sectores excluidos"}
ggplot()+
   geom_polygon(data = su.f,
                aes(x = long ,y = lat, group = group),
                fill = "grey70")+
   geom_polygon(data = subset(su.f, id %in% su.exc$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "descartados"),
                alpha = 0.5)+
   coord_equal()+
   scale_fill_manual(name ="SU",values = "blue")+
   theme_void()
```

```{r mapa-excluidos-tipo, fig.cap="Mapa de los sectores excluidos por criterio usado"}
 ggplot()+
   geom_polygon(data = su.f,
                aes(x = long ,y = lat, group = group),
                fill = "grey70")+
   geom_polygon(data = subset(su.f, id %in% sin_arboles_censado$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin arboles censados"))+
   geom_polygon(data = subset(su.f, id %in% sin_personas$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin personas"))+
   geom_polygon(data = subset(su.f, id %in% sin_viviendas$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin viviendas"))+
   geom_polygon(data = subset(su.f, id %in% ep_60$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Ep > 60%"))+
   geom_polygon(data = subset(su.f, id %in% privada_85$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Privado > 85%"))+
   geom_polygon(data = subset(su.f, id %in% calle_80$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Calle > 80%"))+
   geom_polygon(data = subset(su.f, id %in% su.exc.apriori),
                aes(x = long ,y = lat, group = group,fill = "a priori"))+
   geom_text_repel( data = data.frame(centroides.su) %>% 
                filter( setu_ccgdo %in% su.exc.criterios$SETU_CCDGO),
              aes(x = x, y =y, label =setu_ccgdo))+
   
   coord_equal()+
  scale_fill_manual(name="Criterios",values = brewer.pal(7,"Set1"))+
   theme_void()
```


### Modelando la cobertura de copa

Las variables a incluir en los modelos lineales deben cumplir una serie de condiciones para ser elegidas como candidatas:

- *Mostrar una correlación fuerte* (típicamente mayor a 0.6 se considera una asociación fuerte).
- *Las variables independientes o predictoras no deben estar fuertemente correlacionadas entre ellas*.
- *Las observaciones deben ser independientes*. En nuestro caso significa que no debe existir relación espacial o temporal entre los diferentes sectores. Justamente esto se pondrá a prueba con los test estadísticos y los graficos de diagnostico sobre la distribución de los residuos de la regresión: se espera que dicha dependencia esté motivada por la vecindad de los sectores.
- *Las variables dependientes e independientes deben tener una distribución normal*. Esta condición no suele ser estricta, inclusive algunos textos como @ , afirman que lo importante es que calcular los coeficientes de la regresión obtengamos una distribución normal de los residuos (sin ningún patrón, ruido). De no ser así, es posible que las variables no sean independiente y que exista información significativa en los residuos, por ejemplo, porque existe autocorrelación espacial en la variable dependiente y entonces la regresión lineal no obtiene resultados confiables para los coeficientes.


Para hacer más tratable y gradual el proceso de complejizar el modelo iniciaremos el análisis con las variables sobre la población, que son las de mayor interés en un estudio dado su enfoque en la  justicia ambiental, para luego incorporar las variables de los dominios relacionados con el uso de los predios, los tipos de viviendas y la existencia de espacios verdes como parques, bulevares, escenarios deportivos o plazas, que como se vio en la sección \@ref(sec-ca2015) (revisar figura \@ref(fig:au-emplaz-veg))  alojan una cantidad considerable de los individuos arbóreos de la ciudad.

Las variables a modelar son la área de copa en metros^2^ (`area_copa`) y la cobertura de copa como porcentaje del área pública total (`cobertura_copa.ap`), conformda por la vías y calles más el área de espacio públicos) (ver figura \@ref(fig:mapa-copa-dep)).

```{r mapa-copa-dep, fig.cap="Sectores urbanos de las variables dependientes sobre cobertura de copa"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(dep.arboles.ntl.long,by = c("id"="SETU_CCDGO")) %>%
  filter(dep.arboles %in% dependientes.arboles) %>%
  ggplot()+
  geom_polygon(data = su.f, aes(x= long, y = lat, group = group), fill = "grey60")+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~dep.arboles, nrow = 1)+
  tema_lgnd_abajo()

```



#### Correlaciones y gráficos de dispersión entre pares

Para asegurarnos de que las variables no están correlacionadas entre si, usaremos los coeficientes de correlación de Pearson, usado para detectar relaciones lineales, usualmente en variables con distribución normal, y el coeficiente de Spearman para detectar relaciones en variables con otras distribuciones o que exhiben relaciones no lineales. Para tener una idea más amplia sobre esa relación que expresan los coeficiente de correlación se incluyen gráficas de dispersión entre las variables independientes, y con las dependientes.


En la figura \@ref(fig:bivar-poblacion-abs) se explora las relaciones entre las variables de población en las unidades originales de los datos (número de personas); la matriz triangular superior muestra los coeficientes de correlación de Pearson, la diagonal contiene el histogram de frecuencias de la variable y la matriz triangular inferior muestra un gráfico de dispersión y la línea de tendencia usando un modelo lineal entre cada par de variables. Es notoria la alta correlación entre tener ningún estudio y tener alguna limitación física (0.88);  pertenecer a una comunidad afrodescendiente y carecer de estudios (0.92) o ser afrodescendiente y tener alguna limitación (0.88). Esto representa una suma de condiciones desfavorables relacionadas entre sí, que desde el punta del vista del modelo sólo podrán ser representadas por una de las variables, la que mejor se relacione con la cobertura de copa y evitar así colinealidad entre los predictores.



```{r bivar-poblacion-abs, fig.asp=1, fig.cap="Comparación por pares entre predictores de población"}
ggpairs(
  regresion.arboles[,indep.poblacion.abs], lower = list(continuous = wrap_fn_with_params(lowerFn, method = "lm")),
  diag = list(continuous = GGally:: wrap_fn_with_params("barDiag", colour = "white",fill ="steelblue")),
  upper = list(continuous = wrap_fn_with_params("cor", size = 4)),
  title = "Comparación por pares entre predictores de población"
)+ theme_grey(base_size = 8)

```

Cuando realizamos la misma comparación entre las variables porcentuales (más la densidad poblacional) se observan patrones similares(ver figura \@ref(fig:bivar-poblacion-mod)): existe una alta correlación negativa entre el porcentaje de población afro de un sector y la tenencia de estudios superiores (-0.71), una fuerte asociación positiva entre el porcentaje de personas afro de un sector y el porcentaje de personas que carecen de estudios (0.68). También hay una fuerte relación inversa entre el porcentaje de personas de un sector sin estudios y el porcentaje de ellos que tiene estudios superiores (-0.8). Estas variables evitaremos usarlas como predictores en una misma formulación para no sesgar la estimación con problemas de colinealidad. Existe también una asociación, no tan fuerte pero importante, entre la densidad de población y sectores con mayor porcentaje de personas afro (0.47) y una asociación negativa entre la densidad de población y el porcentaje de personas con estudios superiores (-0.51). Estos resultados hablan de una concentración de condiciones desfavorables para la población, posiblemente acompañado de una segregación racial alta.

```{r bivar-poblacion-mod, fig.asp=1, fig.cap="Comparación por pares entre predictores de población porcentuales"}
ggpairs(
  regresion.arboles[,indep.poblacion.percent], lower = list(continuous = wrap_fn_with_params(lowerFn, method = "lm")),
  diag = list(continuous = wrap_fn_with_params("barDiag", colour = "white",fill ="steelblue")),
  upper = list(continuous = wrap_fn_with_params("cor", size = 4)),
  title = "Comparación por pares entre predictores de población porcentuales y la densidad de población"
)+ theme_grey(base_size = 8)

```

Para completar la inspección de las relaciones entre predictores la figura \@ref(fig:bivar-poblacion-mod-abs) muestra la relación entre las variables provistas en por el censo de población en unidades de personas y las versiones porcentuales que calculamos. El número en el recuadro de cada subgráfica es el coeficiente de correlación de Pearson. Aunque procuraremos incluir cada una de las condiciones evitando redundar al incluir la misma variable en sus dos versiones en un mismo modelo, es interesante que la división entre el número de personas totales del sector atenúa la correlación entre la variable observada y su contraparte porcentual.

```{r bivar-poblacion-mod-abs, fig.asp=1, fig.cap="Comparación por pares entre predictores de población porcentuales y predictores en unidades de personas"}
# entre predictoras y version porcentual
ggduo(regresion.arboles,
      columnsX =indep.poblacion.abs, 
      columnsY =indep.poblacion.percent,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
  title = "Comparación por pares entre predictores en unidades de personas y porcentuales"
)+ theme_grey(base_size = 8)

```


Ya que hemos explorado visualmente la dispersión entre los datos crudos, podemos usar forma resumida, usando gráficos de azulejos o de matriz para consultar la intensidad de estas relaciones, no solo las lineales que revela el coeficiente de Pearson, sino usando el coeficiente de Spearman. La figura \@ref() sintetiza las relaciones lineales entre las variables dependientes, mientras que la figura \@ref() lo hace para las no lineales. 

```{r tile-poblacion-pearson, fig.asp=1,fig.cap="Coeficiente Pearson entre varibles de población"} 
pintar_corrmatrix(regresion.arboles,indep.poblacion)+
  labs(title="Coeficiente Pearson entre varibles de población")


```

```{r tile-poblacion-spearman, fig.asp=1,fig.cap="Coeficiente Spearman entre varibles de población"}
pintar_corrmatrix(regresion.arboles,indep.poblacion, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre varibles de población")

```

Para seleccionar las variables que mejor predicen la cobertura de copa aplicamos un procedimiento análogo al realizado con las variables dependientes entre sí. Con base en los coeficientes de correlación de Pearson (figura \@ref(fig:tile-copa-poblacion-pearson)) y Spearman (figura \@ref(fig:tile-copa-poblacion-spearman)) entre las variables dependientes e independientes, y teniendo en cuenta las restricciones de colinealidad entre las variables dependientes, seleccionamos las variables a usar en el modelo lineal. 

Así pues, para el área de copa (`area_copa`) los predictores seleccionados son`` `r str_c(indep.poblacion.copa.sel, collapse = ", ") ` `` y para la cobertura de copa en área pública (`cobertura_copa.ap`) los predictores seleccionados son`` `r str_c(indep.poblacion.copa.ap.sel, collapse = ", ") ` `` 

```{r tile-copa-poblacion-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre coberturas de copa y variables de población"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.poblacion, y=dependientes.arboles)+
  labs(title="Pearson entre cobertura de copa y variables de población")

```


```{r tile-copa-poblacion-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre coberturas de copa y variables de población"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.poblacion, y=dependientes.arboles, method_cor = "spearman")+
  labs(title="Spearman entre cobertura de copa y variables de población")
```


Se recomienda especificar correctamente los modelos lineales cuando existen relaciones con correlaciones negativas, pues es posible que sea mejor usar el inverso de la variable. Para probar si al hacerlo dichas variables tienen incrementos en los coeficientes de correlación respecto de las variables dependientes. Como se observa en las figuras \@ref(fig:duolin-poblacion-copa) y \@ref(fig:duonolin-poblacioninv-copa) las mejoras son solo en la varible de `afro.porcentaje.inv` en el segundo dígito decimal. Como son tan pequeñas las diferencias opto por no usar las variables transformdas por la funcion inversa pues esto reduce el intervalo en que varian, reduciendo asi su poder explicativo. 




```{r duolin-poblacion-copa,cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población y variables dependientes de la cobertura de copa (regresión lineal + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =c("superior_postgrado",indep.poblacion.copa.ap.sel),
      columnsY =dependientes.arboles,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      # types = list(continuous = wrap_fn_with_params(lm_with_cor,
      #                                method_cor = "spearman",
      #                                method_smooth= "loess")),
      title = "Predictores de población vs. cobertura de copa (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)


```

```{r duonolin-poblacioninv-copa, cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población (usando el inverso de la variable con correlaciones negativas: $f(x)=\\frac{1}{x+1}$) y las variables dependientes de la cobertura de copa ( regresión lineal  + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =c("superior_postgrado",indep.poblacion.cobertura.ap), 
      columnsY =dependientes.arboles,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      # types = list(continuous = wrap_fn_with_params(lm_with_cor,
      #                                method_cor = "spearman",
      #                                method_smooth= "loess")),
title = "Predictores de población (invertido) vs. cobertura de copa (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)
```


#### Modelos de regresión lineal 

Antes ajustar los modelos suele ser común en los modelos de regresión ajustar la distribución de las variables dependientes (y a veces las independientes) por motivos teóricos usando transformaciones logarítmicas o de raíz cuadra para eliminar no linealidades entre las variables dependientes y las independientes, y reducir posibles fenómenos de heterocedasticidad debido a estas no-linealidades. Siguiendo el ejemplo, ajustaremos 5 modelos: uno por cada variable dependiente en sus tres versiones, sin transforma, con una tranformacion logaritmica (exepto para la cobertura_copa.ap pues por tener valores ya entre [0,1] produce valores negativos) y otra de la raiz cuadra. 

Los histogramas de las variables dependientes tranformadas se muestran en la figura \@ref(fig:hist-copa-trnsf). 
```{r hist-copa-trnsf, fig.asp=1.5,fig.cap="Histogramas de las variables de cobertura de copa transformadas"}
# histogramas 

regresion.arboles %>% select(one_of(c(dependientes.copa.trnsf,dependientes.copa.ap.trnsf))) %>%
  gather( key = indep.poblacion,
          value = valores,
          1:5) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="forestgreen")+
  facet_wrap(~indep.poblacion, scales = "free", ncol = 1)

```

Las mejoras sobre el modelo de regresión que puedan hacer estas transformaciones pueden apreciarse en los gráficos de dispersión de las variables independientes transformadas vs. las dependientes o/y en los coeficientes de correlación de Pearson. Como se observa en las figuras \@ref(fig:duolin-poblacion-copa-trnsf) y \@ref(fig:duolin-poblacion-cob-trnsf) hay leves mejoras al aplicar las transformaciones.    

```{r duolin-poblacion-copa-trnsf,cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población y variables dependientes de la área de copa transformdas (regresión lineal + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =indep.poblacion.copa.sel, 
      columnsY =dependientes.copa.trnsf,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      title = "Predictores de población vs. área de copa transformda (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)


```


```{r duolin-poblacion-cob-trnsf,cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población y variables dependientes de la cobertura de copa transformdas (regresión lineal + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =indep.poblacion.copa.ap.sel, 
      columnsY =dependientes.copa.ap.trnsf,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      title = "Predictores de población vs. cobertura de copa transformda (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)


```

También es sabido que dividir o multiplicar por alguna constante no tiene ningún efecto en la calidad de la estimación , pero sí sobre los coeficientes de la regresión. Esto suele ser sensible a la hora de interpretar los cambios marginales de cada una de las variables independientes y su efecto sobre la variable dependiente. Sin embargo, lo que interesa para este estudio no es la interpretación de esos cambio sino la importancia relativa de cada variable y comparar los cambios de los coeficientes de regresión para el ajuste de cada modelo y/o las mejoras que pueda operar un modelos autorregresivo en caso de encontrase autocorrelación en los residuos de la regresión lineal. Por esta razón, normalizar los valores puede ser una ventaja pues mantiene los coeficiente mejor acotados. La normalización se aplica posterior a las transformaciones propuestas y se realiza dividiendo por el máximo valor de los datos de cada variable para mantener valores en el intervalo [0,1], dado que los valores son todos iguales o mayores que 0.


El siguiente código en **R** crea las 5 regresiones lineales propuestas y se resumen en la la tablas \@ref(tab:comp-lmcopa) y \@ref(tab:comp-lmcopaap)

```{r code-lm-area_copa, echo=TRUE,eval=TRUE}

dependiente <- "area_copa"
independientes  <- indep.poblacion.copa.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mn.area_copa.sel<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mn.area_copa.sel)
sm

```


```{r code-lm-log.area_copa,echo=TRUE,eval=TRUE}


dependiente <- "log.area_copa"
independientes  <- indep.poblacion.copa.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.log.area_copa.sel<-crear_lm_from_df(regresion.arboles.mn)
modelo<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mxn.log.area_copa.sel)
sm

```



```{r code-lm-sqrt.area_copa,echo=TRUE,eval=TRUE}

dependiente <- "sqrt.area_copa"
independientes  <- indep.poblacion.copa.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.sqrt.area_copa.sel<-crear_lm_from_df(regresion.arboles.mn)
summary(lm.mxn.sqrt.area_copa.sel)

```

Table: (\#tab:comp-lmcopa)Modelos área copa preliminares

|  | modelos|
|:----------|------------:|

`r sjt.lm(lm.mn.area_copa.sel, lm.mxn.log.area_copa.sel,lm.mxn.sqrt.area_copa.sel,       depvar.labels = c("Area Copa (AC)", "Log(AC)","Sqrt(AC))"),separate.ci.col = FALSE, p.numeric = FALSE, show.fstat =TRUE,show.aic = TRUE, no.output=TRUE)$knitr`


```{r tabla-mse-lmcopa}
modelos<-c("Area Copa (AC)", "Log(AC)","Sqrt(AC))")
sm1<-summary(lm.mn.area_copa.sel)
sm2<-summary(lm.mxn.log.area_copa.sel)
sm3<-summary(lm.mxn.sqrt.area_copa.sel)
mse<-c(mean(sm1$residuals^2),mean(sm2$residuals^2),mean(sm3$residuals^2))
tablamse<-data.frame(modelos,mse)
knitr::kable(tablamse,
             col.names =c("Modelo","MSE"),
             caption = "Comparación MSE para modelos de área de copa")
```



```{r code-lm-cobertura_copa.ap,echo=TRUE}


dependiente <- "cobertura_copa.ap"
independientes  <- indep.poblacion.copa.ap.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.cobertura_copa.ap<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mxn.cobertura_copa.ap)
sm
#MSE
mean(sm$residuals^2)

```


```{r code-lm-sqrt.cobertura_copa.ap,echo=TRUE}


dependiente <- "sqrt.cobertura_copa.ap"
independientes  <- indep.poblacion.copa.ap.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.sqrt.cobertura_copa.ap<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mxn.sqrt.cobertura_copa.ap)
sm
#MSE
mean(sm$residuals^2)

```


Table: (\#tab:comp-lmcopaap)Modelos cobertura de copa preliminares

|  | modelos|
|:----------|------------:|

`r sjt.lm(lm.mxn.cobertura_copa.ap, lm.mxn.sqrt.cobertura_copa.ap,depvar.labels = c("Cobertura Copa % (CC)","Sqrt(CC))"), separate.ci.col = FALSE, p.numeric = FALSE, show.fstat =TRUE,show.aic = TRUE, no.output=TRUE)$knitr`

```{r tabla-mse-lmcopaap}
modelos<-c("Cobertura Copa % (CC)","Sqrt(CC))")
sm1<-summary(lm.mxn.cobertura_copa.ap)
sm2<-summary(lm.mxn.sqrt.cobertura_copa.ap)
mse<-c(mean(sm1$residuals^2),mean(sm2$residuals^2))
tablamse<-data.frame(modelos,mse)
knitr::kable(tablamse,
             col.names =c("Modelo","MSE"),
             caption = "Comparación MSE para modelos de porcentaje de cobertura de copa")
```

De los 3 formulaciones de usadas para modelar el área de copa la que mejor ajuste obtuvo fue el que transforma la variable dependiente usando la raíz cuadrada (`sqrt.area_copa`). Este modelo explica el 60% de la variabilidad en los datos (Adjusted R-squared:  0.604) y considera las variables `superior_postgrado` y `densidad_poblacion` como muy significativas, con ambos coeficientes obteniendo valores consistentes con el signo de las correlaciones calculadas previamente en análisis bivariado de la figura \@ref(fig:duolin-poblacion-copa-trnsf).

Para el porcentaje de cobertura copa en el área pública, el mejor ajuste se obtuvo con la variable transformada por la función raíz cuadrada (`sqrt.cobertura_copa.ap`). Este modelo considera que las variables `superior_postgrado.porcentaje` y `densidad_poblacion` como muy significativas, y explica  casi el 50% de la variabilidad (Adjusted R-squared:  0.4858). Sin embargo el coeficiente de la densidad de población obtiene un valor positivo, contrario al signo de la correlación obtenida en el análisis bivariado de la figura \@ref(fig:duolin-poblacion-cob-trnsf).

Reduzcamos ambos modelos eliminando las variables no significativas y aplicando test para verificar que las condiciones de un buen ajuste (no hay sesgos en el estimador o una mala especificación del modelo) de un modelo lineal se cumplen:

- La media de los residuos es 0 o muy cercana.
- La distribución de los residuos es normal.
- Los residuos muestran homocedasticidad (la varianza es constante)

Para verificar la normalidad de los residuos usaremos el test de Shapiro–Wilk [@shapiro1965analysis] y para la verificar si existe homocedasticidad el test de Breusch–Pagan [@breusch1979simple]. Además se acompaña de gráficas de diagnóstico de los resultados de cada modelo.

Para el mejor modelos del área de copa el siguiente codigo realiza el trabajo generar las gráficas diagnósticas y los tests de normalidad y homocedasticidad.

```{r code-best-lm-areacopa, eval=TRUE, echo=TRUE,results='hide' }
dependiente <- "sqrt.area_copa"
independientes  <- c("superior_postgrado","densidad_poblacion")
# max normalizado 
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.best.area_copa<-lm(sqrt.area_copa.mxn~superior_postgrado.mxn+densidad_poblacion.mxn,data = regresion.arboles.mn)
sm<-summary(lm.best.area_copa)
sm
#MSE
mean(sm$residuals^2)
#test de ajuste
mean(lm.best.area_copa$residuals) # media de los residuos cercana a 0 (si)
# Homocedasticidad de los residuos o varianza igual
lmtest::bptest(lm.best.area_copa) # la varianza de los residuos no es constante 
# Normalidad de los residuos
shapiro.test(lm.best.area_copa$residuals) # los residuos no exhiben una distribucion normal

```

Table: (\#tab:lmcopa-best)Resumen de OLS -`r format(as.formula(lm.best.area_copa)) %>% str_c(collapse = "\n")`

|  | modelo|
|:----------|:------------:|

`r sjt.lm(lm.best.area_copa,depvar.labels = c("Sqrt(AC)"), separate.ci.col = FALSE, p.numeric = FALSE, show.fstat =TRUE,show.aic = TRUE, show.se=TRUE,no.output=TRUE)$knitr`

```{r diagn-best-lm-areacopa, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal del área de copa"}
graf<-autoplot(lm.best.area_copa)
title1=grid::textGrob(format(as.formula(lm.best.area_copa)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
# +
#   theme(title = element_text(size = 0.5))

```

Los resultados de los tests (tablas \@ref(tab:fitlm-copa) y \@ref(tab:testlm-copa)) rechazan que los residuos sean normales y que la varianza sea constante, por lo cual, es posibles que los estimadores sean ineficientes y que existan efecto no considerados en el modelo. Las gráficas diagnosticas (figura \@ref(fig:diagn-best-lm-areacopa)) muestran que existe heterocedasticidad en los residuos, pues se observa como la linea de tendencia se aleja de la horizontal y la dispesion de los residuos aumenta con el valor ajustado. Para probar si es posible tener un modelo mejor especificado se introduce en la sección \@ref(geostat) análisis geoestadisticos basados en la autocorrelación espacial. 

Table: (\#tab:fitlm-copa)**MSE y Media(residuos)** - `r format(as.formula(lm.best.area_copa)) %>% str_c(collapse = "\n")`

| Modelo          | MSE| Media(residuos)|
|:----------|:------------:|:------------:|
| `lm.best.area_copa`  | `r mean(summary(lm.best.area_copa)$residuals^2)` | `r mean(lm.best.area_copa$residuals)` | 


```{r testlm-copa, warning=FALSE}
# Homocedasticidad de los residuos o varianza igual
bpt<-lmtest::bptest(lm.best.area_copa) # la varianza de los residuos no es constante 
# Normalidad de los residuos
swt<-shapiro.test(lm.best.area_copa$residuals) # los residuos no exhiben una distribucion normal
bpt.df<-tidy(bpt)
swt.df<-tidy(swt)
tabla.tmp<-bind_rows(swt.df,bpt.df)
kable(tabla.tmp, caption = paste0("**Test de normalidad y homocedasticidad** - ", format(as.formula(lm.best.area_copa)) %>% str_c(collapse = "\n")))
```



El mismo procedimiento lo aplicamos para el mejor modelo de cobertura de copa. El siguiente código construye el modelo y realiza los test descritos anteriormente.  


```{r code-best-lm-copaap, eval=TRUE, echo=TRUE, results='hide' }
dependiente <- "sqrt.cobertura_copa.ap"
independientes  <- c("superior_postgrado.porcentaje","densidad_poblacion")
# max normalizado 
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.best.cobertura.ap<-lm(sqrt.cobertura_copa.ap.mxn~superior_postgrado.porcentaje.mxn+densidad_poblacion.mxn,data = regresion.arboles.mn)
sm<-summary(lm.best.cobertura.ap)
sm
#test de ajuste
mean(lm.best.cobertura.ap$residuals) # media de los residuos cercana a 0 (si)
# Homocedasticidad de los residuos o varianza igual
lmtest::bptest(lm.best.cobertura.ap) # la varianza de los residuos no es constante 
# Normalidad de los residuos
shapiro.test(lm.best.cobertura.ap$residuals) # los residuos no exhiben una distribucion normal

```

Table: (\#tab:lmcopaap-best)Resumen de OLS -`r format(as.formula(lm.best.cobertura.ap)) %>% str_c(collapse = "")`

|  | modelo|
|:----------|:------------:|

`r sjt.lm(lm.best.cobertura.ap,depvar.labels = c("Sqrt(AC)"), separate.ci.col = FALSE, p.numeric = FALSE, show.fstat =TRUE,show.aic = TRUE, show.se=TRUE,no.output=TRUE)$knitr`


```{r diagn-best-lm-copaap, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal del porcentaje de cobertura de copa"}

graf<-autoplot(lm.best.cobertura.ap, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.best.cobertura.ap)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
```

Table: (\#tab:fitlm-copa)**MSE y Media(residuos)** - `r format(as.formula(lm.best.cobertura.ap)) %>% str_c(collapse = "")`

| Modelo          | MSE| Media(residuos)|
|:----------|:------------:|:------------:|
| `lm.best.cobertura.ap`  | `r mean(summary(lm.best.cobertura.ap)$residuals^2)` | `r mean(lm.best.cobertura.ap$residuals)` | 


```{r testlm-copaap, warning=FALSE}
# Homocedasticidad de los residuos o varianza igual
bpt<-lmtest::bptest(lm.best.cobertura.ap) # la varianza de los residuos no es constante 
# Normalidad de los residuos
swt<-shapiro.test(lm.best.cobertura.ap$residuals) # los residuos no exhiben una distribucion normal
bpt.df<-tidy(bpt)
swt.df<-tidy(swt)
tabla.tmp<-bind_rows(swt.df,bpt.df)
kable(tabla.tmp, caption = paste0("**Test de normalidad y homocedasticidad** - ", format(as.formula(lm.best.cobertura.ap)) %>% str_c(collapse = "")))
```

Al igual que para el área de copa los resultados de los tests rechazan que los residuos sean normales y que la varianza sea constante (tabla \@ref(tab:testlm-copaap)), sin embargo, no es tan notorio el aumento de la varianza con el aumento de los valores ajustados; la curva de tendencia de los residuos vs. los valores ajustados sugiere una no linealidad no absorbida por el modelo (figura \@ref(fig:diagn-best-lm-copaap)). Igualmente veremos si la introducción de elementos de la teoría geoestadística permite mejorar la especificación del modelo.

Los resultados de la regresión de los modelos con varibles de población se resumen en la tabla \@ref(tab:comp-lmcopaap) y al igual que los test de normalidad \@ref(tab:testsw-poblacion), homocedasticidad \@ref(tab:testbp-poblacion) y métricas sobre los residuos \@ref(tab:mse-lm-best-poblacion). 

Table: (\#tab:comp-lmcopaap)OLS con variables de población para el área (AC) y el porcentaje decobertura de copa (CC%)

|  | modelos|
|:----------|:------------:|

`r sjt.lm(lm.best.area_copa, lm.best.cobertura.ap,depvar.labels = c("Sqrt(AC)", "Sqrt(CC%))"), separate.ci.col = FALSE, p.numeric = FALSE, show.fstat =TRUE,show.aic = TRUE, show.se=TRUE, no.output=TRUE)$knitr`


```{r mse-lm-best-poblacion}
modelos<-c("Sqrt(AC)", "Sqrt(CC%))")
sm1<-summary(lm.best.area_copa)
sm2<-summary(lm.best.cobertura.ap)
mse<-c(mean(sm1$residuals^2),mean(sm2$residuals^2))
media<-c(mean(lm.best.area_copa$residuals),mean(lm.best.cobertura.ap$residuals))
tablamse<-data.frame(modelos,mse,media)
knitr::kable(tablamse,
             col.names =c("Modelo","MSE","Media(residuos)"),
             caption = "Comparación MSE para los modelos seleccionados de cobertura y área de copa")
```

```{r testsw-poblacion, warning=FALSE}
modelos<-c("Sqrt(AC)", "Sqrt(CC%))")
# Normalidad de los residuos
swt1<-shapiro.test(lm.best.area_copa$residuals)
swt2<-shapiro.test(lm.best.cobertura.ap$residuals)

swt.df<-bind_rows(tidy(swt1),tidy(swt2))
tabla.tmp<-bind_cols(modelo=modelos,swt.df)  

kable(tabla.tmp, caption = "**Test de normalidad**")

```
```{r testbp-poblacion, warning=FALSE}
modelos<-c("Sqrt(AC)", "Sqrt(CC%))")
# Homocedasticidad de los residuos o varianza igual
bpt1<-lmtest::bptest(lm.best.area_copa) 
bpt2<-lmtest::bptest(lm.best.cobertura.ap)


bpt.df<-bind_rows(tidy(bpt1),tidy(bpt2))
tabla.tmp<-bind_cols(modelo=modelos,bpt.df)  

kable(tabla.tmp, caption = "**Test de homocedasticidad**")
```




#### Introducción de dimensiones no poblacionales al modelo lineal

Para la inclusión de otras variables agregadas por sector urbano aplicamos el procedimiento realizado para la selección de las variables de población usando como criterio la inclusión de variables con coeficientes de correlación que muestren una asociación fuerte con las variables de cobertura de copa. Las figuras \@ref(fig:tile-prediosev-pearson) y \@ref(fig:tile-prediosev-spearman) se ven los coeficientes de Pearson y Spearman, respectivamente, entre las variables sobre el uso los predios, tipo de viviendas y área (y porcentaje) de espacios verdes en cada sector urbano. Como se observa, existe una fuerte (perfecta) asociación negativa entre el porcentaje de casas y apartamentos, lo que obliga a solo escoger una de las dos en caso de haber una fuerte relación entre alguna de ellas con las variables de cobertura de copa. También hay una fuerte asociación positiva entre el área de espacios verdes y el porcentaje de área de espacio verdes en un sector urbano. Como mencionamos antes solo incluiremos una de las dos en caso de que ambas resulten fuertemente asociadas con las variables dependientes.  

```{r tile-prediosev-pearson, fig.asp=1,fig.cap="Coeficiente Pearson entre variables de uso de los predios y espacios verdes en los sectores urbanos"}
pintar_corrmatrix(regresion.arboles,indep.predios)+
  labs(title="Pearson entre características de predios y EV")
```

```{r tile-prediosev-spearman, fig.asp=1,fig.cap="Coeficiente Pearson entre variables de uso de los predios y espacios verdes en los sectores urbanos"}
pintar_corrmatrix(regresion.arboles,indep.predios, method_cor = "spearman")+
  labs(title="Spearman entre entre características de predios y EV")
```

Las figuras \@ref(fig:tile-copa-prediosev-pearson) y \@ref(fig:tile-copa-prediosev-spearman) muestran la correlación entre las potenciales nuevas variables a incluir en el modelo y las variables dependientes de cobertura y área de copa. Para el área de copa se seleccionan el área de espacios verdes (`area_ep`) y el porcentaje de viviendas tipo cuarto (`cuarto.porcentaje`). Para el modelo de porcentaje de cobertura de se seleccionan `apartamento.porcentaje`, `cuarto.porcentaje` y `area_ep.porcentaje`.

```{r tile-copa-prediosev-pearson, fig.asp=0.65, fig.cap= "Coeficiente Pearson entre coberturas de copa y variables de predios y EV"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.predios, y=dependientes.arboles)+
  labs(title="Coeficiente Pearson entre cobertura de copa y uso de los predios")
```


```{r tile-copa-prediosev-spearman, fig.asp=0.65,fig.cap="Coeficiente Pearson entre coberturas de copa y variables de predios y EV"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.predios, y=dependientes.arboles, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre  cobertura de copa y uso de los predios")
```

La nueva formulación del modelo de área de copa obtiene los siguientes resultados:

```{r code-mode-best-lm-areacopa, eval=TRUE, echo=TRUE,results='hide' }

# introducimos las varibles nuevas
dependiente <- "sqrt.area_copa"
independientes  <- c("superior_postgrado","densidad_poblacion",indep.predios.copa.sel)
# max normalizado 
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mod.area_copa<-lm(sqrt.area_copa.mxn~superior_postgrado.mxn+
                        densidad_poblacion.mxn+
                        cuarto.porcentaje.mxn+
                        area_ep.mxn,
                      data = regresion.arboles.mn)
sm<-summary(lm.mod.area_copa)
sm
#MSE
mean(sm$residuals^2)

#test de ajuste
mean(lm.mod.area_copa$residuals) # media de los residuos cercana a 0 (si)
# Homocedasticidad de los residuos o varianza igual
lmtest::bptest(lm.mod.area_copa) # la varianza de los residuos no es constante 
# test normalidad de los residuos
shapiro.test(lm.mod.area_copa$residuals) # los residuos no exhiben una distribucion normal

#Comparacion AIC
AIC(lm.mod.area_copa)
AIC(lm.best.area_copa)

```


Table: (\#tab:comp-lmcopa-pob-mod)Comparación OLS para el área (AC) población y otras dimensiones

|  | modelos|
|:----------|:------------:|

`r sjt.lm(lm.best.area_copa, lm.mod.area_copa,depvar.labels = c("Sqrt(AC)~pob", "Sqrt(AC)~pob+otras"), separate.ci.col = FALSE, p.numeric = FALSE, show.fstat =TRUE,show.aic = TRUE, show.se=TRUE, no.output=TRUE)$knitr`

Las variables introducidas tienen todas p-value significativos, y a pesar de la inclusión de más términos al modelo existe una mejora en el Criterio de Información de Akaike (baja de `r AIC(lm.best.area_copa)` a `r AIC(lm.mod.area_copa)`). Los resultados de los test evidencian que aunque hay mejoras en Adjusted R-squared ( de 0.6032 a 0.678) y en MSE (de 0.0121 a 0.0098) sigue existiendo no normalidad en los residuos y heterocedasticidad, como se observa también en las gráficas diagnosticas de la regresión \@ref(fig:diagn-mod-best-lm-copa).

```{r mse-lm-mod-poblacion}
modelos<-c("Sqrt(AC)~pob", "Sqrt(AC)~pob+otras")
sm1<-summary(lm.best.area_copa)
sm2<-summary(lm.mod.area_copa)
mse<-c(mean(sm1$residuals^2),mean(sm2$residuals^2))
media<-c(mean(lm.best.area_copa$residuals),mean(lm.mod.area_copa$residuals))
tablamse<-data.frame(modelos,mse,media)
knitr::kable(tablamse,
             col.names =c("Modelo","MSE","Media(residuos)"),
             caption = "MSE y Media(residuos) para los modelos de área de copa más otras dimensiones no poblacionales")
```

```{r testsw-poblacion-mod, warning=FALSE}
modelos<-c("Sqrt(AC)~pob", "Sqrt(AC)~pob+otras")
# Normalidad de los residuos
swt1<-shapiro.test(lm.best.area_copa$residuals)
swt2<-shapiro.test(lm.mod.area_copa$residuals)

swt.df<-bind_rows(tidy(swt1),tidy(swt2))
tabla.tmp<-bind_cols(modelo=modelos,swt.df)  

kable(tabla.tmp, caption = "**Test de normalidad**")

```
```{r testbp-poblacion-mod, warning=FALSE}
modelos<-c("Sqrt(AC)~pob", "Sqrt(AC)~pob+otras")
# Homocedasticidad de los residuos o varianza igual
bpt1<-lmtest::bptest(lm.best.area_copa) 
bpt2<-lmtest::bptest(lm.mod.area_copa)


bpt.df<-bind_rows(tidy(bpt1),tidy(bpt2))
tabla.tmp<-bind_cols(modelo=modelos,bpt.df)  

kable(tabla.tmp, caption = "**Test de homocedasticidad**")
```


```{r diagn-mod-best-lm-copa, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de área de copa con los nuevos términos"}

graf<-autoplot(lm.mod.area_copa, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.mod.area_copa)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)

```


Para el caso del porcentaje de cobertura de copa los resultados obtenidos con la introduccion de las nuevas varibles son los siguientes:

```{r code-mode-best-lm-copaap, eval=TRUE, echo=TRUE,results="hide"}
# coberbtura AP
dependiente <- "sqrt.cobertura_copa.ap"
independientes  <- c("superior_postgrado.porcentaje","densidad_poblacion",indep.predios.copa.ap.sel)
# max normalizado 
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mod.cobertura.ap<-lm(sqrt.cobertura_copa.ap.mxn~superior_postgrado.porcentaje.mxn+
                          densidad_poblacion.mxn+
                          apartamento.porcentaje.mxn+
                          cuarto.porcentaje.mxn+
                          area_ep.porcentaje.mxn,
                        data = regresion.arboles.mn)
sm<-summary(lm.mod.cobertura.ap)
sm
#MSE
mean(sm$residuals^2)
#test de ajuste
mean(lm.mod.cobertura.ap$residuals) # media de los residuos cercana a 0 (si)
# Homocedasticidad de los residuos o varianza igual
lmtest::bptest(lm.mod.cobertura.ap) # la varianza de los residuos no es constante 
# test normalidad de los residuos
shapiro.test(lm.mod.cobertura.ap$residuals) # los residuos no exhiben una distribucion normal
#Comparacion AIC
AIC(lm.mod.cobertura.ap)
AIC(lm.best.cobertura.ap)

```

Table: (\#tab:comp-lmcopaap-pob-mod)Comparación OLS para el porcenataje de cobertura de copa (CC%) con variables de población y otras dimensiones

|  | modelos|
|:----------|:------------:|

`r sjt.lm(lm.best.cobertura.ap, lm.mod.cobertura.ap,depvar.labels = c("Sqrt(CC%)~pob", "Sqrt(CC%)~pob+otras"), separate.ci.col = FALSE, p.numeric = FALSE, show.fstat =TRUE,show.aic = TRUE, show.se=TRUE, no.output=TRUE)$knitr`

Las variables introducidas tienen todas p-value no significativos. La inclusión de más términos al modelo empeoran el Criterio de Información de Akaike (sube de `r AIC(lm.best.cobertura.ap)` a `r AIC(lm.mod.cobertura.ap)`). Los resultados de los test no dan evidencian de mejoras en Adjusted R-squared ( de 0.4883 a 0.489 ) y en MSE (de 0.01279 a 0.01266). Sigue existiendo no normalidad en los residuos y heterocedasticidad, como se observa en las gráficas diagnosticas de la regresión \@ref(fig:diagn-mod-best-lm-copaap).

```{r mse-lm-copaap-mod-pob}
modelos<-c("Sqrt(CC%)~pob", "Sqrt(CC%)~pob+otras")
sm1<-summary(lm.best.cobertura.ap)
sm2<-summary(lm.mod.cobertura.ap)
mse<-c(mean(sm1$residuals^2),mean(sm2$residuals^2))
media<-c(mean(lm.best.cobertura.ap$residuals),mean(lm.mod.cobertura.ap$residuals))
tablamse<-data.frame(modelos,mse,media)
knitr::kable(tablamse,
             col.names =c("Modelo","MSE","Media(residuos)"),
             caption = "MSE y Media(residuos) para los modelos de cobertura de copa más otras dimensiones no poblacionales")
```

```{r testsw-copaap-pob-mod, warning=FALSE}
modelos<-c("Sqrt(CC%)~pob", "Sqrt(CC%)~pob+otras")
# Normalidad de los residuos
swt1<-shapiro.test(lm.best.cobertura.ap$residuals)
swt2<-shapiro.test(lm.mod.cobertura.ap$residuals)

swt.df<-bind_rows(tidy(swt1),tidy(swt2))
tabla.tmp<-bind_cols(modelo=modelos,swt.df)  

kable(tabla.tmp, caption = "**Test de normalidad**")

```
```{r testbp-copaap-pob-mod, warning=FALSE}
modelos<-c("Sqrt(CC%)~pob", "Sqrt(CC%)~pob+otras")
# Homocedasticidad de los residuos o varianza igual
bpt1<-lmtest::bptest(lm.best.cobertura.ap) 
bpt2<-lmtest::bptest(lm.mod.cobertura.ap)


bpt.df<-bind_rows(tidy(bpt1),tidy(bpt2))
tabla.tmp<-bind_cols(modelo=modelos,bpt.df)  

kable(tabla.tmp, caption = "**Test de homocedasticidad**")
```

```{r diagn-mod-best-lm-copaap, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de porcentaje de cobertura de copa con los nuevos términos"}

graf<-autoplot(lm.mod.cobertura.ap, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.mod.cobertura.ap)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
```

Como incluimos muchas variables nuevas veamos cuales son los modelos que presentan mejoras usando diferentes combinaciones de las variables seleccionadas con base en el Criterio de Información de Akaike, el MSE y el  Adjusted R-squared. Para ello usamos la función `ols_best_subset` de la librería `olsrr` que escoge los mejores 5 modelos con base en estos criterios.

```{r code-sel-best-lm-copaap, eval=TRUE, echo=TRUE,results="hide"}
best_models.copa.ap<-ols_best_subset(lm(sqrt.cobertura_copa.ap.mxn~
                                  superior_postgrado.porcentaje.mxn+
                                  densidad_poblacion.mxn+
                                  area_ep.porcentaje.mxn+
                                  cuarto.porcentaje.mxn+
                                  apartamento.porcentaje.mxn,
                                data = lm.mod.cobertura.ap$model))
best_models.copa.ap
#plot(best_models)
```
```{r perm-copaap-pred}
tabla.tmp<-data.frame(id_model=best_models.copa.ap$mindex,
                      Predictores=best_models.copa.ap$predictors)
kable(tabla.tmp, caption = "5 mejores permutaciones de variables")
```

```{r perm-copaap-fit}
tabla.tmp<-data.frame(id_model=best_models.copa.ap$mindex,
                       AdjR_Sq=best_models.copa.ap$adjr,
                       AIC= best_models.copa.ap$aic,
                      MSEP=best_models.copa.ap$msep)
kable(tabla.tmp, caption = "Comparación Medidas de Ajuste ")
```


Los resultados de este análsis comparativo dan como mejor modelo al conformado por `` `r best_models.copa.ap$predictors[3] %>%str_split(" ") %>% unlist() %>% str_c(collapse =", ") ` `` (modelo 3). La gráfica \@ref(fig:comp-model-copaap) resume las métricas de ajuste de los 5 mejores modelos. A pesar de las mejoras en el ajuste el coeficiente de la variable `cuarto.porcentaje` tiene un valor *p* que no es significativo, siguen existiendo no normalidad y heterocedasticidad, por lo que no podemos confiar en la eficiencia de los coeficientes de la regresión. Optamos entonces por mantener el modelo de varibles poblacionales para la el porcentaje de cobertura de copa que contiene solo variables de población.  

```{r comp-model-copaap, fig.cap="Comparación entre modelos con las combinaciones de predictores con base en AIC, MSEP y Adjusted R-squared "}
plot(best_models,main ="Comparacion de los 5 mejores modelos para la cobertura de copa")
```

Finalmente presento los mapas de las variables dependientes de los 2 modelos seleccionados, comparandolas con el modelo ajustado y los residuos de ajuste, con el finde observar donde se localizan los errores en la predicción. La figura \@ref(fig:mapas-lm-copa) corresponde al ajuste del área de copa y la figura \@ref(fig:mapas-lm-copaap) al porcentaje de la cobertura de copa.

```{r mapas-lm-copa, fig.asp= 0.7,fig.cap="Variable dependiente, valor ajsutado por el modelo y residuos del OLS para `sqrt.area_copa` normalizada"}
pintar_mapa_su_lm2(regresion.arboles,lm.mod.area_copa,nrow =1)
```

```{r mapas-lm-copaap, fig.asp= 0.7,fig.cap="Variable dependiente, valor ajsutado por el modelo y residuos del OLS para `sqrt.cobertura_copa.ap` normalizada"}
pintar_mapa_su_lm2(regresion.arboles,lm.best.cobertura.ap,nrow =1)
```

### Acceso a espacios verdes


#### Correlaciones y distribuciones bivaridas

#### Modelos de regresion lineal 


## Análisis geoestadísticos {#geostat}

Para los analsis geoestadisticos introducimos los modelos autoregresivos para obtener mejoras en la estimación de los coeficientes y en el ajuste de los modelo si existe algun tipo de autocorrelacion espacial en los residuos. Exite una variedad de estos modelos que capturan diferentes tipos de efectos: modelo autoregresivo SAR que capturan efectos de la variable dependiente, ecuación \@ref(eq:sar) , sobre las varibles las independientes ( spatial lag o retardo espacial en $X$ SLX, ecuación \@ref(eq:slx), en el error (modelo espacial del errore SEM,ecuación \@ref(eq:sem) o usando una combinacion del modelo de error y autoregresivo (modelo espacial de Durbin SD,ecuación \@ref(eq:sd). Todas estas aproximaciones introducen una matriz de $W_{n\times n}$, donde $n$ es el número de sitios, que captura la influencia de las variables en relación con su proximidad. Esta matriz $W$ es una estructura que restringe la influecia a priori en el modelo. Para observar el efecto que tiene esta matriz sobre los resultados del modelo usaremos 2 matrices distintas, y veremos su impacto en la estimación.

Para los análisis espaciales usaremos la libreria `spdep` [@R-spdep]

### Matrices de vecindad

La matriz $W$ representa la topología de vecindad entre los sectores censales. Existen la literatura diferentes tipos de vecindad: rook, bishop y queen son las más referenciadas. Esta vecindad está representada en la matriz con 1 cuando existe vecindad y 0 cuando no. Otra forma de cuantificar la interacción de esa vecindad es usando una matriz de inversos de la distancia entre los centroides de los sectores censales, con el fin de atenuar la interacción entre sectores muy alejados y tener una variable continua que representa esa influencia. En la figura \@ref(fig:w-su-todos) se muestra la matriz $W$ defina para vecinos que comparten un lado del polígono (vecindad rook) para todos los sectores de la ciudad de Cali.

```{r w-su-todos, fig.cap="Grafo de vecidad entre todos los SU de la ciudad de Cali"}
nb.su<-poly2nb(su, row.names = su$SETU_CCDGO)
par(mai=c(0,0,0,0))
plot(su, border="grey80")
plot(nb.su, coordinates(su), col='grey50', pch=19, cex=0.1,add=TRUE)
```

Sin embargo, la regresiones se realizaron sobre un subconjunto de los datos, y por tanto la estructura de esta matriz debe tener esto en cuenta, o mejor, no tener en cuenta la influencia de estos sectores excluidos. Así la matriz de vecindad para los SU usados para la estimación de los coeficientes de las regresiones lineales se ve en la figura \@ref(fig:w-su-reg).

```{r w-su-reg, fig.cap="Grafo de vecidad entre los SU seleccionados para el análisis"}

par(mai=c(0,0,0,0))
plot(su, border="grey80")
plot(W_cont, coordinates(su.arboles), col='orchid1',pch=19, cex=0.1, add=TRUE)
```

Las matrices de vecindad construidas para el análisis espacial son la queen $W_q$, que considera vecino a todos los sectores que comparten un lado o una esquina con un sector censal; y una matriz de distancia inversas entre los centroides de los SU, restringiendo la vecindad a aquellos centroides que están a menos de 1 km ($W_d$). Los grafos que representan las 2 matrices $W$ se muestran en la figura \@ref(fig:ws-su-reg). 

```{r ws-su-reg, fig.asp=1.5 ,out.width='48%' ,fig.cap="Matrices de vecindad del análisis espacial",fig.align="center",fig.show="hold"}
plot(W_queen,coords=coordinates(su.arboles),pch=19, cex=0.1, col="gray", main="Queen")
title(main = "Queen")
plot(W_dist1000.inv,coords=coordinates(su.arboles),pch=19, cex=0.1, col="gray", main="Distancia inversa a 1km")
title(main = "Distancia inversa a 1km")

```

La matriz $W_d$ impone un estructura de interacciones que puede relacionar sectores en una zona que no necesariamente comparten ningún lado o esquina pero que están cercanos, mientras que $W_d$ se restringe a condiciones de vecindad sólo entre sectores contiguos. En esa medida puede existir juego para dar interpretación teórica al fenómeno de derrame o influencia que ejercen sobre el ajuste de los modelos. Un ejemplo puede ser que la dependencia espacial de las cobertura de árboles que expresa $W_d$ es una característica en una zona no limitada por las divisiones del territorio con base en los desarrollos urbanísticos (barrios) sino que se ajustan más a fenómenos de dispersión continuos con base en el alcance escogido. Así, la $W_q$ puede interpretarse como una forma de dar relevancia a la continuidad entre barrios y su importancia como unidad de desarrollo urbano en las variaciones de la variable a predecir. 

### Modelado espacial de la cobertura de copa

#### Autocorrelación espacial

Para indagar sobre la información o patrones espaciales de los residuos de los modelos de regresión usaramos el índice de Moran I. El índice de Moran I es el coeficiente de correlación para la relación entre una variable y sus valores circundantes. Si encontramos una correlación espacial significativa en los residuos, esto sugiere que agregando esa estructura en el modelo podremos obtener una estimación más eficientes de los coeficientes, y en consecuencia un mejor entendimiento de la relación entre esas variables. Hay que recordar que en este ejercicio no estamos queriendo entender una población por una muestra, estamos calculando estos coeficientes sobre el total de la población, y por tanto los coeficientes pueden interpretarse como la fuerza de esa relación. La confianza en esa estimación depende de que los residuos obtenidos sean tenga un valor medio de 0, y que no puedan distinguirse del ruido. La ecuación \@ref(eq:moranI) define matemáticamente el índice:


\begin{equation}
 I=\frac {N}{\sum _{i}\sum _{j}w_{ij}} \frac {\sum _{i}\sum _{j}w_{ij}(X_{i}-{\bar {X}})(X_{j}-{\bar {X}})}{\sum _{i}(X_{i}- \bar{X})^{2}}
(\#eq:moranI)
\end{equation}

donde $N$ es el número de unidades espaciales indexados por $i$ y  $j$; $X$ es la variable de interés; $\bar {X}$ es la media de $X$; y $w_{ij}$ es un elemento de una matriz de pesos espaciales $W$. Un valor de 0 de Moran’I indica un patrón espacial aleatorio. Si existe autocorrelación los valores son positivos y el máximo es 1. Si los valores son negativos decimos que existe dispersión, siendo -1 el mínimo valor posible representando la dispersión perfecta.

El gráfico de Moran es una forma de observar el valor de la pendiente (el índice de autocorrelación) graficando los valores retardados (spatial lag: es como dijimos previamente el valor medio de los valores vecinos) de la variable en cuestión en el eje $y$ y la variable en el $x$. El valor **$p$** del test estadístico nos dice qué tan seguros estamos que esa pendiente no es plana, por lo que se espera que sean menores que el valor límite de significancia $\alpha = 0.05$  

> El hecho de que de la Morán I es una suma de productos cruzados individuales es explotado por los "indicadores locales de asociación espacial" (LISA) para evaluar la agrupación de las unidades individuales mediante el cálculo de la I de Moran local para cada unidad espacial y la evaluación de la significación estadística para cada I. [@wikilisa]

Examinemos primero la autocorrelación de las varibles dependientes. Los mapas que acompaña el resultado númerico y el grafico de Moran son el valor z-normalizado del LISA, el valor $p$ y la el mapa de clusters. En este ultimo mapa las regiones resaltadas en rojo tienen valores altos de la variable y tienen vecinos con valores altos también (high-high). El área azul es low-low en el mismo esquema propuesto por los cuadrantes en el gráfico de Moran, mientras que las regiones azul pálido son low-high y las áreas rosadas son high-low. Las regiones fuertemente coloreadas son aquellas que contribuyen significativamente a un resultado positivo de autocorrelación espacial global, mientras que los colores más claros contribuyen significativamente a un resultado de autocorrelación negativo.

```{r code-moran-copa-w, echo=TRUE}
moran.test(lm.mod.area_copa$model$sqrt.area_copa.mxn, listw=W_queen)
moran.test(lm.mod.area_copa$model$sqrt.area_copa.mxn, listw=W_dist1000.inv, zero.policy = TRUE)

```

```{r moranplot-copa-w, fig.cap="Gráfico de Moran para los residuos del modelo lineal para del área de cobertura de copa usando $W_{q}$",fig.show="hold",out.width='49%'}

moran.plot(lm.mod.area_copa$model$sqrt.area_copa.mxn, 
             listw=W_queen, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="sqrt.area_copa", 
             ylab="sqrt.area_copa (Spatial Lag)", main="Gráfico de Moran Wq") 
moran.plot(lm.mod.area_copa$model$sqrt.area_copa.mxn, 
             listw=W_dist1000.inv, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="sqrt.area_copa", 
             ylab="sqrt.area_copa (Spatial Lag)", main="Gráfico de Moran Wd") 

```



La matrix $W_q$ capatura mucho mejor de forma global la autocorrelacieon del area de copa. Los mapas LISA muestran los focos de esta autocorrelación usando la matriz para $W_q$ (figura \@ref(fig:mapas-lisa-copa-wq)) y para $W_d$ (figura \@ref(fig:mapas-lisa-copa-wd)) . 

```{r mapas-lisa-copa-wq,fig.asp=0.618}

pintar_mapa_su_LISA_var(regresion.arboles,"sqrt.area_copa",W_queen, wname = "W_q",nrow =1)

```

```{r mapas-lisa-copa-wd,fig.asp=0.618}

pintar_mapa_su_LISA_var(regresion.arboles,"sqrt.area_copa",W_dist1000.inv, wname = "W_d", nrow =1)

```

Para la variable dependiente porcentaje de cobertura de copa los resulados de la autocorrelacieon son lo siguientes.



El siguiente código calcula los índices de autocorrelación de los residuos para ambas matrices $W$ del mejor modelo lineal de área de copa (`` `r str_c("sqrt.copa_area.mxn",str_c(names(lm.mod.area_copa$model)[-1],collapse =" + "), sep= " ~ ") ` ``) y construye el gráfico de Moran \@ref(fig:moranplot-rescopa-wq) para $W_q$ y \@ref(fig:moranplot-rescopa-wd) para $W_d$. 

```{r code-moran-rescopa-wq, echo=TRUE}
moran.test(lm.mod.area_copa$residuals, listw=W_queen)
```

```{r moranplot-rescopa-wq, fig.cap="Gráfico de Moran para los residuos del modelo lineal para del área de cobertura de copa usando $W_{q}$"}

moran.plot(lm.mod.area_copa$residuals, 
             listw=W_queen, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran") 

```


```{r code-moran-rescopa-wd, echo=TRUE}
moran.test(lm.mod.area_copa$residuals, listw=W_dist1000.inv, zero.policy = TRUE)
```

```{r moranplot-rescopa-wd, fig.cap="Gráfico de Moran para los residuos del modelo lineal para del área de cobertura de copa usando $W_d$"}

moran.plot(lm.mod.area_copa$residuals, 
             listw=W_dist1000.inv, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran ") 

```

Para ambos caso el valor de Moran es mayor que 0 y significativo, aunque no es muy alto, si existe una tendencia en los datos y ambas matrices capturan el efecto. El mismo análisis se aplica para el modelos de porcentaje de cobertura de copa (`` `r str_c("sqrt.cobertura_copa.ap.mxn",str_c(names(lm.best.cobertura.ap$model)[-1],collapse =" + "), sep= " ~ ") ` ``). 


```{r code-moran-copaap-wq, echo=TRUE}
moran.test(lm.best.cobertura.ap$residuals, listw=W_queen)
```

```{r moranplot-copaap-wq, fig.cap="Gráfico de Moran para los residuos del modelo lineal para el porcentaje de área de cobertura de copa usando $W_{q}$"}

moran.plot(lm.best.cobertura.ap$residuals, 
             listw=W_queen, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran") 

```


```{r code-moran-copaap-wd, echo=TRUE}
moran.test(lm.best.cobertura.ap$residuals, listw=W_dist1000.inv, zero.policy = TRUE)
```

```{r moranplot-copaap-wd, fig.cap="Gráfico de Moran para los residuos del modelo lineal para el porcentaje de área de cobertura de copa usando $W_d$"}

moran.plot(lm.best.cobertura.ap$residuals, 
             listw=W_dist1000.inv, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran ") 

```

Esta vez la autocorrelación de los residuos es más fuerte e igualmente significativa. Podemos proceder a realizar un ajuste en ambos modelos introduciendo algún tipo de estructura espacial.

#### Ajuste de modelos espaciales

Mejorar la especificación de los modelos lineales incluyendo términos de retardo espacial en la variable dependiente (SAR \@ref(eq:sar)) se hace para obtener una adecuada estimación de los coeficientes de las otras covariables en el modelo. Si optamos por un modelo de error espacial  (SE \@ref(eq:sem)) implica que no es necesario plantear efectos distintivos de la variable dependiente rezagada, y que es posible que ese efecto sea por otras variables no tenidas en cuenta: el agrupamiento espacial observado en la variable dependiente se explica simplemente por el patrón geográfico de variables independientes medidas y no medidas. El modelo SAR, en cambio, incorpora la influencia de variables independientes no medidas, pero también estipula un efecto adicional de valores de atributos vecinos, es decir, la variable dependiente rezagada. 
Si incluimos el retardo sólo de las variables independientes (SLX \@ref(eq:slx)) esperamos que los cambios en las dimensiones expresadas con las predictores produce un efecto de derrame o influencia en los sectores vecinos. 

¿Qué significa decir que la cantidad de cobertura de copa está relacionada con la de los sectores vecinos?¿Son los procesos de reproducción del arbolado urbano un fenómeno independiente de las intervenciones de sus habitantes y de los urbanizadores?¿Los habitantes que ven árboles en las cuadras o barrios aledaños deciden sembrar árboles en su vecindario?¿Existen similitudes en las condiciones estructurales de los barrios en ciertas zonas de la ciudad que prefieren las personas con mejores condiciones sociales( tener estudios superiores p.e)?¿Qué tipo de pérdidas en la cobertura de copa están motivadas por la densificación de un sector? ¿Cómo afectan los cambios en los tipos de oferta habitacional en un sector la cobertura de copa de los sectores vecinos? (las viviendas tipo cuarto suelen ofrecerse en pensiones y ser más económicas que las casas o apartamentos).

La pregunta a hacerse es cómo saber cuál de los diferentes modelos espaciales es el que mejor representa el fenómeno que estamos modelando y si los datos respaldan nuestras convicciones teóricas. Si el modelo de retraso espacial que especifique es realmente el correcto, entonces ninguna dependencia espacial debe permanecer en los residuos, y podremos elaborar sobre el tipo de procesos que pueden verse representados.


Una alternativa metodológica es probar los 3 tipos de modelos con ambas matrices $W_d$ y $W_q$  y comparar sus resultados.



```{r code-laglm-copa-wq, echo=TRUE}
sar.mod.sqrt.area_copa.wq<-lagsarlm(formula = as.formula(lm.mod.area_copa),
         data = lm.mod.area_copa$model,
         listw = W_queen, zero.policy = T,tol.solve=1.0e-30)
summary(sar.mod.sqrt.area_copa.wq,Nagelkerke=T)
```


```{r code-laglm-copa-wd, echo=TRUE}
sar.mod.sqrt.area_copa.wd<-lagsarlm(formula = as.formula(lm.mod.area_copa),
                                       data = lm.mod.area_copa$model,
                                       listw = W_dist1000.inv, zero.policy = T,tol.solve=1.0e-30)
summary(sar.mod.sqrt.area_copa.wd,Nagelkerke=T)
```



### Modelado espacial de espacios verdes

#### Autocorrelación espacial

#### Ajuste de modelos espaciales