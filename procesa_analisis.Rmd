# Procesamiento y análisis de datos {#anayproc}

El procesamiento de los datos se realizó  principalmente en @R-base. Se usó [QGIS](http://www.qgis.org/es/site/) para conectarse a los servicios WFS del IDESC y previsualizar las capas de información geográfica recolectada y la realización de algunos de los mapas detallados.

El código que implementa  los análisis está dividido en archivos para facilitar su lectura, cada uno de los cuales se encargan de transformar los datos de las fuentes y construir estructuras de datos necesarias para realizar las regresiones, las gráficas y los análisis de tipo estadístico y geoestadístico. Cada script implementa una fase de la metodología y produce resultados intermedios que facilitan seguir y reproducir dichas transformaciones sobre los datos de un dominio del problema. El archivo de `funciones.R` agrupa funciones que encapsulan funcionalidades recurrentes dentro del desarrollo del análisis. El script de `geodata.R` opera sobre los fuentes de datos geográficas necesarias para consolidar los índices de acceso a espacios verdes (EV),  los indicadores y variables de la estructura de física de los sectores censales y unidades geográficas del análisis. El script `arboles,R` consolida la información de cada uno de los individuos del censo arbóreo agregandolos por sector censal. El scrript `censopoblacion.R` consolida los datos del Censo de Población 2005. Los scripts `consolidarDatos.R` y `analisis_exploratorio.R` consolidan una única estructura con todos los datos y produce una serie de gráficas y medidas de correlación, que son base para la identificación de supuestos y selección de las variables independientes para los análisis estadísticos y las regresiones espaciales. Finalmente los script de `analisis_estadistico.R` y `analisis_geoestadistico.R` implementan las regresiones lineales y las regresiones espaciales respectivamente, así como los test y tablas para la verificación de los supuesto matemáticos y la verificación de la calidad de los resultados.  Todos estos están reunidos en un script que carga las librerías necesarias y ejecuta secuencialmente cada de los scripts descritos.
```{r code-main, eval=FALSE, echo=TRUE, fig.cap="Script principal"}
# Scrip principal para la la ejecución de los .R

#librerias

library(rgdal)
library(rgeos)
library(raster)
library(sp)

library(tidyverse)
library(magrittr)
library(stringr)

library(viridis)
library(RColorBrewer)
library(gridExtra)

library(visdat)
library(GGally)
library(wesanderson)

library(ggrepel)


#  correr los script en el orden correcto para realizar todos los calculos 

source("funciones.R")
source("geodata.R")
source("arboles.R")
source("censopoblacion.R")
source("consolidarDatos.R")
source("analisis_exploratorio.R")
source("analisis_estadistico.R")
source("analisis_geoestadistico.R")


```




## Capas de información geográfica

Para usar la información geográfica de la cartografía censal y la información del IDESC es necesario establecer un sistema de coordenadas común, en unidades métricas, que facilite integrar la información y produzca resultados consistentes. El sistema de coordenadas proyectadas que vamos a usar es @noauthor_magna-sirgas-cali_nodate. Para cargar y manipular los datos espaciales hacemos uso de las librerías `rgdal` [@R-rgdal], `rgeos` [@R-rgeos] y `sp` [@R-sp]. 

El siguiente mapa muestra los sectores urbanos con sus respectivos códigos de identificación descritos en la documentación que acompaña la cartografía.


```{r mapa-su,fig.width=6, fig.asp=1.41, fig.cap="Sectores Urbanos del Censo del 2005. Los sectores seleccionados están parcial o totalmente contenidos en el perímetro urbano 2015"}

ggplot()+
  geom_polygon(data = su.f,aes(x=long,y=lat,group=group),
               fill="lightgrey",color="white")+
  coord_equal()+
   with(su.setu_ccdgo, annotate(geom="text", x = long, y=lat, label = ids_su, 
                                size = 1.8,
                                color="black"))+
  theme_void()

```

La capa de manzanas es necesaria para refinar las capas de espacio verde y poder calcular el área de calle , área privada y otras métricas sobre la estructura de cada sector sector censal y que servirán como criterios para la selección de sectores urbanos a incluir en los análisis de regresión.

```{r mapa-manzana, fig.width=6, fig.asp=0.8, fig.cap="Coropleta del tamaño de manzana.Se usaron 10 grupos con aprox. el mismo número de observaciones", cache=TRUE}
#pintar usando colores por quantil
manzanas.su.f%>%
  ggplot(aes(x=long,y=lat,group=group))+
  geom_polygon(aes(fill=cut_number(area_manzana,n = 10)))+
  coord_equal()+
  theme_void()+
  viridis::scale_fill_viridis(discrete = TRUE, direction = -1)
```

Las capas de equipamiento de la EEC y espacio público se consolidan en una sola capa conservando la mayor cantidad de información sobre la clasificación de los tipos de espacios disponibles. El resultado puede ver verse de forma total (ver figuara \@ref(fig:mapa-ev)) o por tipo de espacio (figuras \@ref(fig:mapa-ev-facet) y \@ref(fig:mapa-ev-color)).

```{r mapa-ev, fig.width=6, fig.asp=0.8, fig.cap="Espacio verdes consolidados y sectores urbanos",cache=TRUE}
# espacios publicos (verdes)
base_plot.manzanas2 +
  geom_path(data = su.f,aes(x=long,y=lat,group=group),
            color="lightskyblue",
            size=0.5)+
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group),
               fill="deeppink",
               alpha=0.7)+
                                
  theme_void()
```


```{r mapa-ev-color, fig.width=6, fig.asp=0.8, fig.cap="Espacio verde por categoría",cache=TRUE}
base_plot.manzanas2 + 
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group,
               fill=tolower(categoria)),
               alpha=1)+
  
  theme_void()+
  scale_fill_manual(name = "Tipo EV",values = palKata[c(9,8,7,6,1,5,4,10,2,3)])
```


```{r mapa-ev-facet,  fig.asp=1.5, fig.cap="Small Multiple del espacio verde por categoría",cache=TRUE}
# facets por tipo de espacio 
  ggplot()+
  geom_polygon(data = su.f,aes(x=long,y=lat,group=group),
            fill="grey80",
            color ="white",
            size=0.1
            )+
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group),
               fill="deeppink",
               alpha=1)+
    coord_equal()+
  theme_void()+
  facet_wrap(~categoria, ncol = 4)+
  theme(strip.text.x = element_text(size = 8))
```

### Índices de acceso a espacios verdes

Para mejorar la lectura de esta sección se incluyen a continuación las ecuaciones que definen los índices de acceso seleccionados y las variantes definidas en este trabajo.

#### Índices de acceso basados en área {-}
**índice contenedor** (area_ep)
\begin{equation}
A^{C}_i =\sum_j{s_j} \;  \; \forall  j \in I
(\#eq:cont)
\end{equation}
donde $s_j$ es el área de cada espacio verde $j$ que pertenece al conjunto $I$ de EV dentro del sector $i$.

**índice contenedor porcentual** (area_ep.porcentaje)
\begin{equation}
A^{C_p}_i =1/a_i\sum_j{s_j} \;  \; \forall  j \in I
(\#eq:n-cont)
\end{equation}
donde $a_i$ es el área del sector $i$.

**índice área disponible en radio** (ia.areas.1000)
\begin{equation}
A^{AR}_i= \sum_{\int R_b }{(s_j}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:area-radio)
\end{equation}
donde $R_b$ es el radio de búsqueda,  $s_j$ es el área de cada espacio verde $j$ que pertenece al conjunto $I_{R_b}$ de EVs en el radio de búsqueda.

**índice porcentual de área disponible en radio** (ia.areas.1000.porcentaje)
\begin{equation}
A^{AR_p}_i= 1/a_t \sum_{\int R_b }{(s_j}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:area-radio2)
\end{equation}
donde $a_t$ es el área total de espacio verde en la ciudad.

#### Índices de acceso basados en distancia {-}

**costo de viaje** (ia.costoviaje)
\begin{equation}
A^{T}_i =\sum_j{d_{ij}} \; \; \forall  j \in I_t
(\#eq:costo)
\end{equation}
donde $d_{ij}$ es la distancia del centriode del sector $i$ al espacio $j$ e $I_t$ es el conjunto de todos los epacios verdes de la ciudad. 

**costo de viaje normalizado** (ia.costo.n)
\begin{equation}
\bar{A}^{T_n}_i =A^{T}_i/N 
(\#eq:n-costo)
\end{equation}
donde $N$ es el número total de espacio verdes en la ciudad.

**distancia mínima** (ia.mindist)
\begin{equation}
A^{M}_i=min\left | d_{ij} \right | \forall  j \in I_t
(\#eq:min-dist)
\end{equation}

#### Índices de acceso mixtos {-}

**razón área distancia** (ia.A.D)
\begin{equation}
A^{AD}_i= \sum_{\int R_b }{s_j/d_{ij}}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:area-dist)
\end{equation}
donde $R_b$ es el radio de búsqueda,  $s_j$ es el área de cada espacio verde $j$, $d_{ij}$ es la distancia del centriode del sector $i$ al espacio $j$  que pertenecen al conjunto $I_{R_b}$ de EVs en el radio de búsqueda. 

**razón área disponible distancia** (ia.areas.dist)
\begin{equation}
\bar{A}^{AD}_i= \frac{\sum_{\int R_b }{s_j}}{\sum_{\int R_b }{d_{ij}}}  \;  \; \forall  j \in I_{R_b} \; 
(\#eq:areas-dists)
\end{equation}


Con los datos consolidados se calculan las áreas de los espacios verdes al interior de cada sector censal, para calcular los índices de acceso tipo contenedor (ecuación \@ref(eq:cont)) interceptando los espacio verdes con los sectores urbanos (ecuación \@ref(eq:n-cont)). También se obtuvo una versión del índice contenedor como en porcentaje del área del SU. El cálculo de los índices de costo de viajes (ecuación \@ref(eq:costo)) y costo de viaje normalizado (ecuación \@ref(eq:n-costo)) se obtiene creado una matriz de distancia entre los centroides de los sectores censales y cada uno de los espacios verdes. De esta matriz de distancia también se obtiene el índice de distancia mínima (ecuación \@ref(eq:min-dist)). 

Los mapas de los índices de acceso basados en distancia se muestran en la figura \@ref(fig:mapas-ia-distancia)

```{r mapas-ia-distancia, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia en escala continua"}

pl_acceso_dist<-plots_map_su_df(metricas.acceso.df,metricas.acceso[c(1,2,7)])
grid.arrange(grobs =pl_acceso_dist, nrow =1)
```

```{r mapas-ia-distancia-deciles, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.acceso.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.acceso %in% metricas.acceso[c(1,2,7)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.acceso, nrow = 1)+
  tema_lgnd_abajo()
```


Además de los índices basados en distancia y el tipo contenedor se calcularon índices de acceso basados en el área de espacio verde en un radio de 1000 metros. Estos índices muestran un dimensión relacionada no con solo con el acceso sino con la cantidad de espacio disponible en el radio de busqueda definido desde el centroide del sector censal. Para hacernos una idea del radio de búsqueda seleccionado, el siguiente mapa muestra los radios búsqueda y los espacios verdes. 

```{r mapa-rango1km,  fig.asp=0.8, fig.cap="Espacio verdes y rango de 1 km desde centriodes de SU"}
ggplot()+
  geom_polygon(data = s_1000_df, 
               aes(x=long,y=lat,group=group),
               fill = "salmon",
               alpha = 0.2)+
  geom_path(data = su.f,aes(x=long,y=lat,group=group),
            color="grey40",
            size=0.4)+
  geom_polygon(data = ep.cali.f ,
               aes(x=long,y=lat,group=group),
               fill="royalblue",
               alpha=0.5)+
  coord_equal()+
  theme_void()
```



Los índices de acceso basados en área descritos en las ecuaciones \@ref(eq:cont),\@ref(eq:n-cont) y\@ref(eq:area-radio) se resumen en la siguiente gráfica.

```{r mapas-ia-area,   fig.asp=1, fig.cap="Small Multiple de los indices de acceso a EV basados en área usando escala continua"}
pl_acceso_dist<-plots_map_su_df(metricas.acceso.df,metricas.acceso[c(8,9,10,11)])
grid.arrange(grobs =pl_acceso_dist, ncol =2)

```

```{r mapas-ia-area-deciles, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.acceso.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.acceso %in% metricas.acceso[c(8,9,10,11)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.acceso, nrow = 1)+
  tema_lgnd_abajo()
```

En la búsqueda de índices de acceso más complejos que reflejen el acceso en distancia y la cantidad de área disponible desde cada sector urbano se construyeron índices similares a el índice de distancia de a pie (ecuación \@ref(eq:walkdist) que se basan en la razón entre el área a la que se accede y la distancia a la que se encuentra del centroide del sector. Dos nuevos índices se proponen en este trabajo: ia.areas.dist (ecuación \@ref(eq:areas-dists)) como la suma de las áreas en el rango de 1 km desde el centroide del SU dividido la suma de las distancia a esos EV; ia.A.D (ecuación \@ref(eq:area-dist)) , que es la suma de las razones entre el área del espacio verde $j$ dividido entre la distancia $d_{ij}$ desde el centroide del SU $i$ al EV $j$. La siguiente gráfica muestra las métricas propuestas.

```{r mapas-ia-area-dist, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en área y distancia usando escala continua"}
pl_acceso_mix<-plots_map_su_df(metricas.acceso.df,metricas.acceso[c(13:14)])
grid.arrange(grobs =pl_acceso_mix, ncol =2)

```

```{r mapas-ia-area-dist-deciles, fig.asp=0.8, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.acceso.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.acceso %in% metricas.acceso[c(13,14)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.acceso, nrow = 1)+
  tema_lgnd_abajo()
```

Además de los mapas es de interes observar la distribución en frecuencia de las métricas de acceso. La siguiente gráfica se observan los histogramas de las metricas calculadas.

```{r hist-acceso,  fig.asp=1.5, fig.cap="Small Multiple de los indices de acceso a EV basados en distancia usando deciles"}
analisis.cali.df %>% select(one_of(metricas.acceso[c(1,2,7,8,9,10,11,13,14)])) %>%
  gather( key = metricas.acceso,
          value = valores,
          ia.costoviaje:ia.A.D) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="steelblue")+
  facet_wrap(~metricas.acceso, scales = "free", ncol = 2)
```


Finalmente se muestra el código en R que calcula los índices presentados, y el resumen de los índices calculados. 

```{r resumen-ia}
summary(analisis.cali.df[,metricas.acceso[c(1,2,7,8,9,10,11,13,14)]])
```

```{r code-indices-acceso, eval= FALSE, echo=TRUE}
# matriz distancia entre centriodes y espacios
m.dist.ctrdsu.ep<-gDistance(ep.cali,centroides.su, byid = T) 
#cuando el punto esta dentro del poligono el valor que rertorna es 0
# por ese motivo le pondremos 10 a valores = 0 o entre 0 y 10 para 
# evitar problemas al invertir la matriz y mejorar la conistencia del indices
# con valores inversos a la distancia
m.dist.ctrdsu.ep[m.dist.ctrdsu.ep < 10]<- 10
# matriz consicion de estar a 1000 del centriodo
is.1000.ep<-gWithinDistance(ep.cali,centroides.su,1001, byid = T)
# cantidad de espacio verdes en radio de 1000 m de los centriodes del sector urbano
num.ep.1000<-apply(is.1000.ep,1,function(x)  sum(x,na.rm =T))
#distancias de Espacio publicos a 1000 del centriode de SU
a<-m.dist.ctrdsu.ep*is.1000.ep

# distancia minima distinta de 0
ia.mindist<-apply(m.dist.ctrdsu.ep,1,function(x)  min(x[x!=0]))
index.min<-apply(m.dist.ctrdsu.ep,1,function(x)  which.min(x[x!=0]))
ia.area.mindist<-ep.cali$area_ep[index.min]/ia.mindist
# suma de las distancias a cada EP por centriode 
ia.costoviaje<-apply(m.dist.ctrdsu.ep,1,sum)
# suma de las distancias a cada EP ubicado a menos de 1000 m del centriode
ia.1000<-apply(a,1,function (x) sum(x))
ia.1000[ia.1000==0]<-NA
ia.1000.n<-ia.1000/num.ep.1000
# indice de la suma de las areas en el rango de un 1 km del sector censal
ia.areas.1000<-is.1000.ep %*% ep.cali$area_ep %>% as.vector()
# indice de area disponible en el radio de 1km como porcentaje del area total 
# disponible 

ia.areas.1000.porcentaje<-ia.areas.1000/sum(ep.cali$area_ep)

# matriz de distancias inversas de centriode su a espacios verdes  
m.dist.ctrdsu.1000.ep.inv<-1/a
b<-m.dist.ctrdsu.1000.ep.inv*is.finite(m.dist.ctrdsu.1000.ep.inv) # eliminar infinitos
# suma de inverso de las distancias a cada EP ubicado a menos de 1000 m del centriode
ia.1000.inv<-apply(b,1,function (x) sum(x,na.rm = T))
ia.1000.inv[ia.1000.inv==0]<-NA
#razon entre Area del EP y distancia al centriode
A.D<-t(t(b)*ep.cali$area_ep)

# sumatoria de la razon entre Area del EP y distancias de ese EP al centriode
ia.A.D<-apply(A.D,1,function (x) sum(x,na.rm = T))
class(ia.costoviaje)
summary(ia.costoviaje)
length(ia.costoviaje)
summary(ia.1000.inv)
length(ia.A.D)
summary(ia.A.D)

# consolidadcionde indices calculados
ia.ev<-data.frame(su$SETU_CCDGO,ia.costoviaje)
ia.ev$ia.costo.n<-ia.ev$ia.costoviaje/dim(m.dist.ctrdsu.ep)[2]
ia.ev<-bind_cols(ia.ev,data.frame(ia.1000,
                                  ia.1000.inv,
                                  ia.1000.n,
                                  ia.areas.1000,
                                  ia.areas.1000.porcentaje
                                  ))
ia.ev$ia.r300<-300*ia.1000.inv
ia.ev<-ia.ev%>%dplyr::rename(SETU_CCDGO=su.SETU_CCDGO)
ia.ev$ia.mindist<-ia.mindist
ia.ev$ia.area.mindist<-ia.area.mindist
ia.ev$ia.A.D<-ia.A.D
smry.area<-summary(ep.cali$area_ep)
ia.ev$ia.r300.Amedia<- 300/smry.area[4]*ia.ev$ia.A.D
ia.ev$ia.r300.Amediana<- 300/smry.area[3]*ia.ev$ia.A.D
ia.ev$ia.areas.dist<-ia.areas.1000/ia.1000


```



## Datos del censo arbóreo 2015 {#sec-ca2015}

El censo arbóreo del año 2015 consolidó un inventario de la vegetación de la ciudad compuesto por `r sum(altura_copa_por_cobertura$cantidad)` individuos. Entre las variables que categorizan los individuos censados están el tipo de emplazamiento, tipo de suelo que cubre la vegetación, la edad, la vitalidad, tipo de vegetación y sus caratetiristicas dasometricas p.ej la altura, el diamtro de la copa, altura y diametro del pecho, etc ..., entro otras relacionadas con el estado fitosanitario y daños físicos.

A continuación se presentan una serie de tablas que resumen las caraterísticas seleccionadas en la tabla \@ref(tab:vars-AU) para el análisis (por tipo de vegetación \@ref(tab:ca2015-vegetacion), por edad \@ref(tab:ca2015-edad) y por emplazamiento \@ref(tab:ca2015-emplazamiento)), antes de aplicar los criterios de seleccón de los individuos arbóres para este estudio.

```{r ca2015-vegetacion}
knitr::kable(altura_copa_por_vegetacion,col.names = c("Tipo de vegetación", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen CA2015 por tipo de vegetación")

```

```{r ca2015-edad}
knitr::kable(altura_copa_por_edad,col.names = c("Edad", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen CA2015 por edad")

```

```{r ca2015-emplazamiento}
knitr::kable(altura_copa_por_emplazamiento,col.names = c("Emplazamiento", "altura media","diámetro medio","cantidad"),digits = 2,caption = "Resúmen CA2015 por emplazamiento")

```

Existe una diferencia de 10 años entre censo de población de 2005 y el censo arbóreo de la ciudad de Cali. Aunque esto pueda parecer una situación que reduce la legitimidad de los resultados que se hayen en este estudio, autores como @boone2010landscape y @schwarz_trees_2015 reconocen que los paisajes que vemos hoy son legados de patrones de consumo pasados, y que en el caso de la vegetación urbana tratamos con organismos de larga vida que pueden tardar mucho tiempo en establecerse y crecer. En contraste, la estructura social de las ciudades puede cambiar más rápidamente. 

Como se menciona en la metodología, la apuesta para reducir la brecha es la exclusión de los árboles jóvenes del inventario, que posiblemente no estaban ahí en 2005. Aunque no conocemos las tasa anual de tala de árboles en la ciudad, y dado es posible que una parte importante de los árboles jóvenes haya reemplazado a los los que fueron talados, no parece realista mantener el inventario entero. 

Aunque en general toda la vegetación aporta beneficios ambientales a los habitantes, en este estudio descartamos la vegetación arbustiva y los árboles, palmas y bambú de menos de 1.9 m de altura para circunscribirnos a los individuos más desarrollados. 

Una vez aplicado este filtro contamos con `r nrow(AU_analsis)` individuos. Las tablas de resumen para la selección de indivuduos con base en estos criterios se muestran a contiunuación.



```{r ca2015sel-vegetacion}
res_vegetacion<-AU_analsis %>% 
  group_by(vegetacion) %>% 
  summarise(altura_media_vegetacion=mean(altura_arbol),
            diametro_medio_copa_vegetacion = mean(diametro_copa),cantidad=n()) 


knitr::kable(res_vegetacion,col.names = c("Tipo de vegetación", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen selección CA2015 por tipo de vegetación")

```

```{r ca2015sel-edad}


res_edad<-AU_analsis %>% 
  group_by(edad) %>% 
  summarise(altura_media_vegetacion=mean(altura_arbol),
            diametro_medio_copa_vegetacion = mean(diametro_copa),cantidad=n()) 

knitr::kable(res_edad,col.names = c("Edad", "altura media","diámetro medio","cantidad"),digits = 2, caption = "Resúmen selección CA2015 por edad")

```

```{r ca2015sel-emplazamiento}
res_emplazamiento<-AU_analsis %>% 
  group_by(emplazamiento) %>% 
  summarise(altura_media_vegetacion=mean(altura_arbol),
            diametro_medio_copa_vegetacion = mean(diametro_copa),cantidad=n()) 

knitr::kable(res_emplazamiento,col.names = c("Emplazamiento", "altura media","diámetro medio","cantidad"),digits = 2,caption = "Resúmen selección CA2015 por emplazamiento")

```

Para indagar sobre la distribución de estos individuos y no quedarnos con los resúmenes estadísticos se muestran a continuación los datos desagregados gráficamente cada una de las variables categóricas y las características físicas del arbolado: altura, diámetro de la copa y su ubicación en la ciudad.

En primer lugar indagamos sobre las diferencias de diámetro y altura por tipo de vegetación. La figura \@ref(fig:au-veg) muestra claramente las diferencias físicas entre los árboles (desarrollan mayor tamaño y con mayor número de individuos), el bambú y las palmas (más altos que anchos y en menor número) de la ciudad. Los árboles catalogados como secos, hace 10 años estaban vivos y los mantenemos en la selección de individuos. 


```{r au-veg,  fig.asp=1, fig.cap="caraterísticas por tipo de vegetacion",cache=TRUE}
#caraterísticas por tipo de vegetacion
AU_analsis %>% 
  ggplot()+
  geom_point(aes(y=altura_arbol,x=diametro_copa),alpha=0.1, color ="forestgreen" )+
  coord_equal()+
  theme_bw()+
  facet_wrap( ~ vegetacion, nrow = 2 )
```

Otra característica interesante para buscar condiciones que afectan el desarrollo del arbolado, representado por la altura y el diámetro son el tipo de lugares que conforman el espacio público donde se encuentran el mayor número de ellos. En la figura \@ref(fig:au-emplaz-veg) se observa la desagregación de los individuos por tipo de emplazamiento en gráficas individuales de altura y diámetro, y en color el tipo de vegetación. Es notorio en la figura que los parques urbanos  y escenarios deportivos son los equipamientos que mayor cantidad de individuos y más desarrollos alojan. Caso aparte son los andenes y separadores viales como se ve en la tabla \@ref(tab:ca2015sel-emplazamiento) y el gráfico alojan `r round((92198+28924)*100/nrow(AU_analsis),digits =2)`% de los individuos. Esto puede ser un hecho que incita a incluir elementos estructurales en los modelos que explican desde aspectos estructurales de los barrios la cobertura de copa. Por supuesto las rondas de ríos y canales dada su disponibilidad de agua condicionan el desarrollo de los individuos arbóreos y su cantidad. 

```{r au-emplaz-veg,  fig.asp=1.5, fig.cap="Caraterísticas por tipo de vegetación y emplazamiento",cache=TRUE}
AU_analsis %>% 
  #filter(vegetacion %in% c("Arbol","Bambu","Palma")) %>%
  ggplot()+
  geom_point(aes(y=altura_arbol,x=diametro_copa,color=vegetacion),alpha=0.1)+
  scale_color_brewer(palette = "Dark2")+
  coord_equal()+
  facet_wrap(~emplazamiento , ncol = 4 ,labeller = label_wrap_gen())+
  guides(colour = guide_legend(override.aes = list(alpha=1)))+
  tema_lgnd_up()
```


Otra forma de ver los datos de resumen de las tabla \@ref(tab:ca2015sel-emplazamiento) y que completa la visión sobre la distribución de los datos en relación al desarrollo físico de los individuos arbóreos es la distribución de los diámetros (figura \@ref(fig:au-diametro-emp))y las alturas (figura \@ref(fig:au-altura-emp)) en relación con el emplazamiento. En ambas gráficas el punto rojo representa el valor promedio


```{r au-diametro-emp,  fig.asp=0.8, fig.cap="Variabilidad del diámetro de copa por emplazamiento",cache=TRUE}
AU_analsis %>% 
ggplot( aes(x=emplazamiento,y=diametro_copa))+
  geom_jitter(position = position_jitter(0.3),alpha=0.1, color = "forestgreen")+ 
  stat_summary(fun.y = mean, geom = "point", shape = 18, size = 3, color = "tomato")+
  stat_summary(aes(label=round(..y..,digits = 2)),fun.y = mean, geom = "text", color = "tomato", hjust = -0.5, size =3)+
  coord_flip()+
  tema_lgnd_up()

```

```{r au-altura-emp,  fig.asp=0.8, fig.cap="Variabilidad de la altura de los arboles por emplazamiento",cache=TRUE}
AU_analsis %>% 
  ggplot( aes(x=emplazamiento,y=altura_arbol))+
  geom_jitter(position = position_jitter(0.3),alpha=0.1, color = "forestgreen")+ 
  stat_summary(fun.y = mean, geom = "point", shape = 18, size = 3, color = "tomato")+
  stat_summary(aes(label=round(..y..,digits = 2)),fun.y = mean, geom = "text", color = "tomato", hjust = -0.5, size =3)+
  coord_flip()+
  tema_lgnd_up()

```

Finalmente en la figura \@ref(fig:au-geo-emp) graficamos los individuos en pequeños mapa por tipo de emplazamiento para observar su distribución geográfica. Es notorio que los árboles están distribuidos en toda la ciudad dada la disponibilidad de andenes aptos para alojarlos. Esto invita a explorar la relación que pueda existir entre el tamaño de los andenes de los barrios y el desarrollo físico de los individuos, ya que las vías con separadores viales y en consecuencia con más espacio para que árboles de mayor tamaño puedan desarrollarse es consistente con el valor medio de la altura y el diámetro sean mayores que el de los andenes. Sin embargo este hecho escapa del alcance de este trabajo y puede ser indagado por otras investigaciones. 

```{r au-geo-emp,  fig.asp=1.5, fig.cap="Small multiples de los individuos arbóreos por emplazamiento",cache=TRUE}
# puntos por e,mplazamiento
base_plot.manzanas + geom_point(data = AU_analsis,
                                aes(x = Este, y = Norte),
                                size=0.01,
                                color="forestgreen",
                                alpha=0.1)+
  theme_void()+
  facet_wrap(~emplazamiento , ncol = 4 ,labeller = label_wrap_gen())

```

Antes de agregar (enmascarar) los datos usando los sectores censales es interesante inspeccionar el efecto que tiene usar unidade regulares o de tamaños no uniformes como los sectores urbanos en las coberturas de copa. Para ello podemos usar hexágonos de 250 metros de ancho que cubren completamente el territorio. La figura \@ref(fig:au-geo-hex) se evidencia que existen cinturones y lugares de alta concentración de individuos y en consecuencia de mayor cobertura de copa. 

```{r au-geo-hex,  fig.asp=0.8, fig.cap="Suma de cobertura por hexagonos",cache=TRUE}
# suma de cobertura por hex
p.hex.copa  <-base_plot.manzanas+ stat_summary_hex(data = AU_analsis,
                                 aes(x = Este, y = Norte, z = area_copa),
                               binwidth = c(250, 250),
                               fun = sum 
                               )+
    geom_path(data = su.f,
                 aes(x = long, y = lat, group = group),
              color ="grey50",
              size=0.2)+
    coord_equal()+
    scale_fill_viridis(name="área \n copa",direction = 1)+
    theme_void()
 p.hex.copa   
```

En la figura \@ref(fig:au-su-acopa) usamos los SUs para agregar los valores de área de copa. Se observa como se reduce un poco la continuidad, y se intensifica el efecto de la agregación en algunos sectores y se atenúa en otros (las figuras \@ref(fig:comp-su-hex-copa) y \@ref(fig:comp-su-hex-numarb) muestran el efecto de la agregación en el área de copa y en el número de individuos, respectivamente ). 

```{r au-su-acopa,  fig.asp=0.8, fig.cap="Area de copa por sector censal"}
p.su.copa<-su.f %>% dplyr::select(-area_su)  %>%
  left_join(analisis.cali.df,by = c("id"="SETU_CCDGO")) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = area_copa))+
  coord_equal()+
  theme_void()+
  scale_fill_viridis(name = "área \n copa", direction = 1 )
p.su.copa

```


```{r comp-su-hex-copa, fig.cap="Agregación de area de copa por hexagonos y SU"}

grid.arrange(p.hex.copa,p.su.copa, ncol = 2)


```

```{r comp-su-hex-numarb, fig.cap="Agregación de número de árboles por hexagonos y SU"}
p.su.arboles<-su.f %>% dplyr::select(-area_su)  %>%
  left_join(analisis.cali.df,by = c("id"="SETU_CCDGO")) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = num_arboles))+
  coord_equal()+
  theme_void()+
  scale_fill_viridis(name = "num \narboles ", direction = 1 )

p.hex.arboles<- base_plot.manzanas+ geom_hex(data = AU_analsis,
                                       aes(x = Este, y = Norte),
                                       binwidth = c(250, 250)
  )+
    geom_path(data = su.f,
              aes(x = long, y = lat, group = group),
              color ="grey50",
              size=0.2)+
    coord_equal()+
    scale_fill_viridis(name="num \narboles",direction = 1)+
    theme_void()

grid.arrange(p.hex.arboles,p.su.arboles, ncol = 2)

```

Esto sugiere que usar valores porcentuales para la cobertura en relación con el área de los SU o del área no-privada de cada sector puede ser una mejor medida para caracterizar el beneficio real en cada sector censal. En razón a esta consideración y las reflexiones sobre el tema en @schwarz_trees_2015, que sugiere que la distinción entre áreas privadas y públicas puede ayudar a determinar las superficies plantables totales que están disponibles para aumentar la cobertura de copa. Calculamos entonces el porcentaje de cobertura de copa respecto del área total sector urbano y respecto del área de espacio público (área del sector censal menos el área de las manzanas privadas)^[La capa de espacio público consolidada previamente nos permite identificar las manzanas de un SU que son espacio público, y por tanto podemos obtener el área que es vía pública, las manzanas que son privadas y las manzanas que son espacio público. Así el área pública es igual a la suma del área de calle más las manzanas de espacio público o al área de SU menos el área de manzanas privadas]. Las medidas porcentuales respecto del área total y pública permiten hacer una comparación más justa entre las diferentes unidades pues relativiza los niveles totales de área de copa. Un hecho que apoya el uso de medidas en relación al espacio público de un sector censal es que el CA2015 solo se realizó para la vegetación en lugares públicos, sobre la calle o vía pública. 

En consecuencia se calcularon las métricas de área de copa en relación al área del sector urbano (`cobertura_copa.su`) y al área pública del sector urbano (`cobertura_copa.ap`). En la figura \@ref(fig:metricas-coberturacont) se ven los mapas en escala continua y en la figura \@ref(fig:metricas-coberturadeciles) se reproducen los mismos mapas usando una escala en deciles. Visualmente, cobertura de copa parece en espacio público parece aproximarse mejor a los patrones de distribución que se evidencia cuando usamos la división uniforme del terreno en hexágonos (figura \@ref(fig:au-geo-hex)), razón por la cual la preferiremos sobre `cobertura_copa.su` para los análsis.


```{r metricas-coberturacont, fig.asp= 0.618, fig.cap= "Métricas de cobertura de copa: área neta, porcentaje respecto del sector censal y porcentaje respecto del área pública "}

pl_copa<-plots_map_su_df(analisis.cali.df,metricas.ca[c(1,5,6)])
grid.arrange(grobs =pl_copa, nrow = 1)

```


```{r metricas-coberturadeciles, fig.cap= "Métricas de cobertura de copa: área neta, porcentaje respecto del sector censal y porcentaje respecto del área pública "}

su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.ca.ntl.long,by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.arboles %in% metricas.ca[c(1,5,6)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.arboles, nrow = 1)+
  tema_lgnd_abajo()

```

Finalmente se muestra los histogramas y el resúmen de las métricas de cobertura arbórea calculadas. 

```{r hist-metricas-copa, fig.cap="Histograma de las métricas de la cobertura de copa"}
#histogramas arboles -----

analisis.cali.df %>% select(one_of(metricas.ca[c(1,5,6)])) %>%
  gather( key = metricas.arboles,
          value = valores,
          area_copa:cobertura_copa.ap) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30,
                 color = "white", fill="forestgreen")+
  facet_wrap(~metricas.arboles, scales = "free", ncol = 1)
```

```{r resumen-cobcopa}
analisis.cali.df %>% select(one_of(metricas.ca[c(1,5,6)])) %>%
summary()
```




## Datos del censo de población

Los datos del censo fueron descargados del aplicativo con que cuenta el DANE para dar acceso al censo de población 2005 [@censo_sistema_dane]. Los datos agregados por sectores censales los inspeccionamos a través de los resúmenes estadistico, histogramas y mapas, de forma análoga a lo realizado hasta ahora con el resto de variables. 

### Característica de la población

La tabla \@ref(tab:vars-poblacion) resumen las variables consideradas inicialmente en este trabajo, sin embargo, algunas de ellas no contienen suficiente variabilidad o el número de individuos es muy bajo en comparación con el total de la población. En la tabla \@ref(tab:totales-poblacion) se observa el bajo número de personas que pertenecen al pueblo Rom (gitanos), Palenqueros de San Basilio (departamento de Bolívar) y de Raizales del Archipiélago de San Andrés, Providencia y Santa Catalina (SAI), por lo que son descartados del análisis. La población indígena es también baja, pero no tanto como para descartarla inmediatamente.

```{r totales-poblacion}
nombre_fila<-c("Población Total","Población afrodescendiente, negros o mulatos","Población indígena","Población Rom","Población Palenqueros","Población raizales de SAI")
tot_pob<-totales.cali[11:16] %>% as_vector(.,"numeric")
tabla.tmp<-data.frame(nombre_fila,unname(tot_pob))
knitr::kable(tabla.tmp, col.names = c("Tipo","Cantidad") ,caption = "Totales de población en la ciudad de Cali")

```

La figura \@ref(fig:mapas-poblacion-cont) muestra los datos de las variables de población en espacio geografico de la ciudad usando una escala continua y la figura \@ref(fig:mapas-poblacion-deciles) lo hace usando una escala discreta (deciles).

```{r mapas-poblacion-cont, fig.asp=1.5,fig.cap="Mapas de las variables de población seleccionadas (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.poblacion[c(2,3,4,6,7)])
grid.arrange(grobs =pl_poblacion, nrow =2)

```

```{r mapas-poblacion-deciles, fig.asp=1.2,fig.cap="Mapas de las variables de población seleccionadas (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.poblacion.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.poblacion %in% metricas.poblacion[c(2,3,4,6,7)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.poblacion, nrow = 2)+
  tema_lgnd_abajo()
```

Los histogramas de estas variables en la figura \@ref(fig:hist-poblacion) siguen la tendencia que se ha venido observando en los histogramas de cobertura arbórea y de variables de acceso a espacios verdes : las distribuciones no son *normales*, tienen una inclinación a la derecha.

```{r hist-poblacion, fig.asp=1,fig.cap="Histogramas de las variables de población "}
# histogramas datos poblacion  
analisis.cali.df %>% select(one_of(metricas.poblacion)) %>%
  gather( key = metricas.poblacion,
          value = valores,
          superior_postgrado:con_alguna_limitacion,indigena,negro_mulato_afrocolombiano) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="magenta")+
  facet_wrap(~metricas.poblacion, scales = "free", ncol = 2)
```

Además de las variables seleccionadas podemos calcular indicadores que se relacionan con el teóricamente como la densidad de población: dado que los árboles compiten por el espacio con los seres humanos es de esperarse que a mayor cantidad de personas haya menos lugar para los árboles. Podemos de nuevo calcular indicadores porcentualización de las condiciones de la población para facilitar la comparaciones y acentuar las diferencias entre los diferente sectores.

A continuación se muestran los mapas en escala continua (figura \@ref(fig:mapas-poblacion-mod-cont)), discreta (figura \@ref(fig:mapas-poblacion-mod-deciles)) e histogramas (figura \@ref(fig:hist-poblacion-mod)) de los indicadores porcentuales de las condiciones y la densidad de población.

```{r mapas-poblacion-mod-cont, fig.asp=1.5,fig.cap="Mapas de las variables de población seleccionadas como porcentajes (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.poblacion.mod[c(1,2,3,5,6)])
grid.arrange(grobs =pl_poblacion, nrow =2)

```

```{r mapas-poblacion-mod-deciles, fig.asp=1.2,fig.cap="Mapas de las variables de población seleccionadas como porcentajes (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.poblacion.mod.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.poblacion.mod %in% metricas.poblacion.mod[c(1,2,3,5,6)]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.poblacion.mod, nrow = 2)+
  tema_lgnd_abajo()
```

```{r hist-poblacion-mod, fig.asp=1,fig.cap="Histogramas de las variables de población como porcentaje"}
# histogramas datos poblacion  
analisis.cali.df %>% select(one_of(metricas.poblacion.mod[c(1,2,3,5,6)])) %>%
  gather( key = metricas.poblacion,
          value = valores,
          densidad_poblacion:superior_postgrado.porcentaje) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="magenta")+
  facet_wrap(~metricas.poblacion, scales = "free", ncol = 2)
```

Podemos notar que la transformación realizada al expresar las variables como porcentaje reduce la inclinación hacia la derecha de los histogramas e inclusive la corrige para el caso de personas con alguna limitación. 

Para finalizar con la inspección de los datos sobre la población se proveen el resumen estadístico de las variables.

```{r resumen-poblacion}
analisis.cali.df %>% select(one_of(c(metricas.poblacion[c(2,3,4,6,7)],metricas.poblacion.mod[c(1,2,3,5,6)]))) %>%
summary()
```

### Características de las viviendas

Además de las rasgos étnicos, condiciones de estudio y limitaciones de la población el censo de 2005 tiene disponibles datos sobre el tipo de viviendas (casa, apartamento, tipo cuarto, casa indígena, otros), y el uso habitacional, comercial y la cantidad de unidades especiales de alojamiento L.E.A dado a los predios. La vocación comercial o residencial de un barrio puede ser un factor en el desarrollo del arbolado urbano, ya sea por las condiciones físicas como por la intervención de sus habitantes. Estas variables pueden también expresarse como porcentaje de la cantidad de predios de vivienda en el caso de los tipos o como porcentaje de la cantidad de predios en el caso del uso como unidad de vivienda, económica o L.E.A.

A continuación presentamos el resumen, los mapas por sector urbano (figuras \@ref(fig:mapas-usopredios-cont) y \@ref(fig:mapas-usopredios-deciles))y los histogramas (figura \@ref(fig:hist-usopredios))de las variables sobre el uso de los predios.

```{r mapas-usopredios-cont, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo de uso de los predios como porcentaje de la cantidad de predios (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.predios[c(13:15)])
grid.arrange(grobs =pl_poblacion, nrow =1)

```

```{r mapas-usopredios-deciles, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo de uso de los predios como porcentaje de la cantidad de predios (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.predios.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.predios %in% metricas.predios[13:15]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.predios, nrow = 1)+
  tema_lgnd_abajo()
```

```{r hist-usopredios, fig.asp=0.7,fig.cap="Histogramas de las variables de uso de predios como porcentaje"}
#histogramas predios ----

analisis.cali.df %>% select(one_of(metricas.predios[13:15])) %>%
  gather( key = metricas.predios,
          value = valores,
          viviendas.porcentaje:LEA.porcentaje) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="steelblue")+
  facet_wrap(~metricas.predios, scales = "free", ncol = 1)
```

El uso de L.E.A tiene una distribución concentrada en uno pocos SU, por lo que podemos descartarla para los análisis de regresión. Existe también cierta complementariedad entre el uso de vivienda y los usos económicos de los predios, porque seguramente, si existe una correlación entre estas variables y la cobertura de copa o el acceso a espacios verdes una de las dos puede bastar para incluir esta dimensión en los modelos de regresion.

A continuación presentamos el resumen, los mapas por sector urbano (figuras \@ref(fig:mapas-viviendas-cont) y \@ref(fig:mapas-viviendas-deciles))y los histogramas (figura \@ref(fig:hist-viviendas))de las variables sobre los tipos de vivienda.

```{r mapas-viviendas-cont, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo viviendas como porcentaje (escala contínua)"}

pl_poblacion<-plots_map_su_df(analisis.cali.df,metricas.predios[c(9:11)])
grid.arrange(grobs =pl_poblacion, nrow =1)

```

```{r mapas-viviendas-deciles, fig.asp=0.8,fig.cap="Mapas de las variables sobre el tipo viviendas como porcentaje (en deciles)"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(metricas.predios.ntl.long, by = c("id"="SETU_CCDGO")) %>%
  filter(metricas.predios %in% metricas.predios[9:11]) %>%
  ggplot()+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~metricas.predios, nrow = 1)+
  tema_lgnd_abajo()
```

```{r hist-viviendas, fig.asp=0.7,fig.cap="Histogramas de los tipo de vivienda como porcentaje"}
#histogramas predios ----

analisis.cali.df %>% select(one_of(metricas.predios[9:11])) %>%
  gather( key = metricas.predios,
          value = valores,
          casa.porcentaje:cuarto.porcentaje) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="steelblue")+
  facet_wrap(~metricas.predios, scales = "free", ncol = 1)
```

Esta primera inspección a los datos permitió descartar algunas variables a usar en los modelos de regresión sobre las coberturas y los espacios verdes, conocer la distribución espacial de los datos y perfilar las posibles variables a incluir. Sin embargo, la percepción suele ser engañosa, vemos patrones en todas partes, así que es necesario acompañar estas intuiciones con métricas estadísticas y gráficas sobre las relaciones entre las variables dependientes e independientes para ser más asertivos en las decisiones del proceso de modelado. 

## Análisis estadísticos

### Criterios y selección de sectores censales

Antes de iniciar un analaisis de regresion es importante establecer ciertos criterios pra inclusion o no de ciertos datos dentro del conjunto de varores para la regresion y calculo de la correlacion. Estos criterios estan ligados 
 creterios de excepcion de sectores urbanos a ser incluidos en el analsis de regresion:
 
- sectores sin personas
- sectores sin viviendas
- sectores area de espacio publico mayor que el 60 % del area del sector
- sectores area de calle mayor que el 80 % del area del sector
- sectores area privada mayor que el 90 % del area del sector

```{r code-excluidos, eval=FALSE, echo=TRUE}
 analisis.cali.df %>% 
   filter(is.na(personas_edad)) %>%
   select(SETU_CCDGO) -> sin_personas
 
 analisis.cali.df %>% 
   filter(uso_vivienda == 0) %>%
   select(SETU_CCDGO) -> sin_viviendas

 analisis.cali.df %>% 
   filter(area_ep.porcentaje > 0.6 ) %>%
   select(SETU_CCDGO)  -> ep_60
 
 analisis.cali.df %>% 
   filter(area_privada.porcentaje > 0.85 ) %>%
   select(SETU_CCDGO) -> privada_85
 
 analisis.cali.df %>% 
   filter(area_calle.porcentaje > 0.8 ) %>%
   select(SETU_CCDGO) -> calle_80
 
 analisis.cali.df %>% 
   filter(is.na(area_copa)) %>%
   select(SETU_CCDGO) -> sin_arboles_censado
 
 
 su.exc.apriori<-c("0204","1736",# sector con alto porcentaje no urbanizado
                   "1709",# maroria del area por fuera del perimetro urbano
                   "1317")# laguna del pandaje
```

Además de estos criterios se excluyeron los sectores donde está la Laguna el Pondaje, que cubre una porción muy importante del sector que no se ve reflejado en las otras métricas, los sectores con una porción mayor al 60% por fuera del perímetro urbano o sin urbanización visible en las imagenes satelitales. Así los sectores excluidos del análisis se muestran en los mapas \@ref(fig:mapa-excluidos) y \@ref(fig:mapa-excluidos-tipo) por criterio usado. 

```{r mapa-excluidos, fig.cap="Mapa de los sectores excluidos"}
ggplot()+
   geom_polygon(data = su.f,
                aes(x = long ,y = lat, group = group),
                fill = "grey70")+
   geom_polygon(data = subset(su.f, id %in% su.exc$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "descartados"),
                alpha = 0.5)+
   coord_equal()+
   scale_fill_manual(name ="SU",values = "blue")+
   theme_void()
```

```{r mapa-excluidos-tipo, fig.cap="Mapa de los sectores excluidos por criterio usado"}
 ggplot()+
   geom_polygon(data = su.f,
                aes(x = long ,y = lat, group = group),
                fill = "grey70")+
   geom_polygon(data = subset(su.f, id %in% sin_arboles_censado$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin arboles censados"))+
   geom_polygon(data = subset(su.f, id %in% sin_personas$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin personas"))+
   geom_polygon(data = subset(su.f, id %in% sin_viviendas$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin viviendas"))+
   geom_polygon(data = subset(su.f, id %in% ep_60$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Ep > 60%"))+
   geom_polygon(data = subset(su.f, id %in% privada_85$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Privado > 85%"))+
   geom_polygon(data = subset(su.f, id %in% calle_80$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Calle > 80%"))+
   geom_polygon(data = subset(su.f, id %in% su.exc.apriori),
                aes(x = long ,y = lat, group = group,fill = "a priori"))+
   geom_text_repel( data = data.frame(centroides.su) %>% 
                filter( setu_ccgdo %in% su.exc.criterios$SETU_CCDGO),
              aes(x = x, y =y, label =setu_ccgdo))+
   
   coord_equal()+
  scale_fill_manual(name="Criterios",values = brewer.pal(7,"Set1"))+
   theme_void()
```

Para el análisis de las zonas verdes, no se tiene en cuenta el criterio de exclusión de SU sin árboles y se incluye la Laguna del Pondaje. Los mapas de las zonas se ven el la figura \@ref(fig:mapa-excluidos-ev) y \@ref(fig:mapa-excluidos-tipo-ev).

```{r mapa-excluidos-ev, fig.cap="Mapa de los sectores excluidos para el análisis de EV"}
ggplot()+
   geom_polygon(data = su.f,
                aes(x = long ,y = lat, group = group),
                fill = "grey70")+
   geom_polygon(data = subset(su.f, id %in% su.exc.EV$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "descartados"),
                alpha = 0.5)+
   coord_equal()+
   theme_void()
```

```{r mapa-excluidos-tipo-ev, fig.cap="Mapa de los sectores excluidos por criterio usado para el análisis de EV"}
 ggplot()+
   geom_polygon(data = su.f,
                aes(x = long ,y = lat, group = group),
                fill = "grey70")+
   geom_polygon(data = subset(su.f, id %in% sin_personas$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin personas"),
                alpha = 0.5)+
   geom_polygon(data = subset(su.f, id %in% sin_viviendas$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "sin viviendas"),
                alpha = 0.5)+
   geom_polygon(data = subset(su.f, id %in% privada_85$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Privado > 85%"),
                alpha = 0.5)+
   geom_polygon(data = subset(su.f, id %in% calle_80$SETU_CCDGO),
                aes(x = long ,y = lat, group = group,fill = "Calle > 80%"),
                alpha = 0.5)+
   geom_polygon(data = subset(su.f, id %in% su.exc.apriori[-4]),
                aes(x = long ,y = lat, group = group,fill = "Apriori"),
                alpha = 0.5)+
   geom_text_repel( data = data.frame(centroides.su) %>% 
                filter( setu_ccgdo %in% su.exc.criterios$SETU_CCDGO),
              aes(x = x, y =y, label =setu_ccgdo))+
   
   coord_equal()+
   theme_void()
```

### Modelando la cobertura de copa

Las variables a incluir en los modelos lineales deben cumplir una serie de condiciones para ser elegidas como candidatas:

- *Mostrar una correlación fuerte* (típicamente mayor a 0.6 se considera una asociación fuerte).
- *Las variables independientes o predictoras no deben estar fuertemente correlacionadas entre ellas*.
- *Las observaciones deben ser independientes*. En nuestro caso significa que no debe existir relación espacial o temporal entre los diferentes sectores. Justamente esto se pondrá a prueba con los test estadísticos y los graficos de diagnostico sobre la distribución de los residuos de la regresión: se espera que dicha dependencia esté motivada por la vecindad de los sectores.
- *Las variables dependientes e independientes deben tener una distribución normal*. Esta condición no suele ser estricta, pues lo importante es que al calcular los coeficientes de la regresión obtengamos una distribución normal de los residuos (sin ningún patrón, ruido). De no ser así, es posible que las variables no sean independientes o que exista información significativa en los residuos, por ejemplo, porque existe autocorrelación espacial en la variable dependiente y entonces la regresión lineal no obtiene resultados confiables para los coeficientes.


Para hacer más tratable y gradual el proceso de complejizar el modelo iniciaremos el análisis con las variables sobre la población, que son las de mayor interés en un estudio dado su enfoque en la  justicia ambiental, para luego incorporar las variables de los dominios relacionados con el uso de los predios, los tipos de viviendas y la existencia de espacios verdes como parques, bulevares, escenarios deportivos o plazas, que como se vio en la sección \@ref(sec-ca2015) (revisar figura \@ref(fig:au-emplaz-veg))  alojan una cantidad considerable de los individuos arbóreos de la ciudad.

Las variables a modelar son la área de copa en metros^2^ (`area_copa`) y la cobertura de copa como porcentaje del área pública total (`cobertura_copa.ap`), conformda por la vías y calles más el área de espacio públicos) (ver figura \@ref(fig:mapa-copa-dep)).

```{r mapa-copa-dep, fig.cap="Sectores urbanos de las variables dependientes sobre cobertura de copa"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(dep.arboles.ntl.long,by = c("id"="SETU_CCDGO")) %>%
  filter(dep.arboles %in% dependientes.arboles) %>%
  ggplot()+
  geom_polygon(data = su.f, aes(x= long, y = lat, group = group), fill = "grey60")+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~dep.arboles, nrow = 1)+
  tema_lgnd_abajo()

```

 

#### Correlaciones y gráficos de dispersión entre pares

Para asegurarnos de que las variables no están correlacionadas entre si, usaremos los coeficientes de correlación de Pearson, usado para detectar relaciones lineales, usualmente en variables con distribución normal, y el coeficiente de Spearman para detectar relaciones en variables con otras distribuciones o que exhiben relaciones no lineales. Para tener una idea más amplia sobre esa relación que expresan los coeficiente de correlación se incluyen gráficas de dispersión entre las variables independientes, y con las dependientes.


En la figura \@ref(fig:bivar-poblacion-abs) se explora las relaciones entre las variables de población en las unidades originales de los datos (número de personas); la matriz triangular superior muestra los coeficientes de correlación de Pearson, la diagonal contiene el histogram de frecuencias de la variable y la matriz triangular inferior muestra un gráfico de dispersión y la línea de tendencia usando un modelo lineal entre cada par de variables. Es notoria la alta correlación entre tener ningún estudio y tener alguna limitación física (0.88);  pertenecer a una comunidad afrodescendiente y carecer de estudios (0.92) o ser afrodescendiente y tener alguna limitación (0.88). Esto representa una suma de condiciones desfavorables relacionadas entre sí, que desde el punta del vista del modelo sólo podrán ser representadas por una de las variables, la que mejor se relacione con la cobertura de copa y evitar así colinealidad entre los predictores.



```{r bivar-poblacion-abs, fig.asp=1, fig.cap="Comparación por pares entre predictores de población"}
ggpairs(
  regresion.arboles[,indep.poblacion.abs], lower = list(continuous = wrap_fn_with_params(lowerFn, method = "lm")),
  diag = list(continuous = GGally:: wrap_fn_with_params("barDiag", colour = "white",fill ="steelblue")),
  upper = list(continuous = wrap_fn_with_params("cor", size = 4)),
  title = "Comparación por pares entre predictores de población"
)+ theme_grey(base_size = 8)

```

Cuando realizamos la misma comparación entre las variables porcentuales (más la densidad poblacional) se observan patrones similares(ver figura \@ref(fig:bivar-poblacion-mod)): existe una alta correlación negativa entre el porcentaje de población afro de un sector y la tenencia de estudios superiores (-0.71), una fuerte asociación positiva entre el porcentaje de personas afro de un sector y el porcentaje de personas que carecen de estudios (0.68). También hay una fuerte relación inversa entre el porcentaje de personas de un sector sin estudios y el porcentaje de ellos que tiene estudios superiores (-0.8). Estas variables evitaremos usarlas como predictores en una misma formulación para no sesgar la estimación con problemas de colinealidad. Existe también una asociación, no tan fuerte pero importante, entre la densidad de población y sectores con mayor porcentaje de personas afro (0.47) y una asociación negativa entre la densidad de población y el porcentaje de personas con estudios superiores (-0.51). Estos resultados hablan de una concentración de condiciones desfavorables para la población, posiblemente acompañado de una segregación racial alta.

```{r bivar-poblacion-mod, fig.asp=1, fig.cap="Comparación por pares entre predictores de población porcentuales"}
ggpairs(
  regresion.arboles[,indep.poblacion.percent], lower = list(continuous = wrap_fn_with_params(lowerFn, method = "lm")),
  diag = list(continuous = wrap_fn_with_params("barDiag", colour = "white",fill ="steelblue")),
  upper = list(continuous = wrap_fn_with_params("cor", size = 4)),
  title = "Comparación por pares entre predictores de población porcentuales y la densidad de población"
)+ theme_grey(base_size = 8)

```

Para completar la inspección de las relaciones entre predictores la figura \@ref(fig:bivar-poblacion-mod-abs) muestra la relación entre las variables provistas en por el censo de población en unidades de personas y las versiones porcentuales que calculamos. El número en el recuadro de cada subgráfica es el coeficiente de correlación de Pearson. Aunque procuraremos incluir cada una de las condiciones evitando redundar al incluir la misma variable en sus dos versiones en un mismo modelo, es interesante que la división entre el número de personas totales del sector atenúa la correlación entre la variable observada y su contraparte porcentual.

```{r bivar-poblacion-mod-abs, fig.asp=1, fig.cap="Comparación por pares entre predictores de población porcentuales y predictores en unidades de personas"}
# entre predictoras y version porcentual
ggduo(regresion.arboles,
      columnsX =indep.poblacion.abs, 
      columnsY =indep.poblacion.percent,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
  title = "Comparación por pares entre predictores en unidades de personas y porcentuales"
)+ theme_grey(base_size = 8)

```


Ya que hemos explorado visualmente la dispersión entre los datos crudos, podemos usar forma resumida, usando gráficos de azulejos o de matriz para consultar la intensidad de estas relaciones, no solo las lineales que revela el coeficiente de Pearson, sino usando el coeficiente de Spearman. La figura \@ref() sintetiza las relaciones lineales entre las variables dependientes, mientras que la figura \@ref() lo hace para las no lineales. 

```{r tile-poblacion-pearson, fig.asp=1,fig.cap="Coeficiente Pearson entre varibles de población"} 
pintar_corrmatrix(regresion.arboles,indep.poblacion)+
  labs(title="Coeficiente Pearson entre varibles de población")


```

```{r tile-poblacion-spearman, fig.asp=1,fig.cap="Coeficiente Spearman entre varibles de población"}
pintar_corrmatrix(regresion.arboles,indep.poblacion, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre varibles de población")

```

Para seleccionar las variables que mejor predicen la cobertura de copa aplicamos un procedimiento análogo al realizado con las variables dependientes entre sí. Con base en los coeficientes de correlación de Pearson (figura \@ref(fig:tile-copa-poblacion-pearson)) y Spearman (figura \@ref(fig:tile-copa-poblacion-spearman)) entre las variables dependientes e independientes, y teniendo en cuenta las restricciones de colinealidad entre las variables dependientes, seleccionamos las variables a usar en el modelo lineal. 

Así pues, para el área de copa (`area_copa`) los predictores seleccionados son`` `r str_c(indep.poblacion.copa.sel, collapse = ", ") ` `` y para la cobertura de copa en área pública (`cobertura_copa.ap`) los predictores seleccionados son`` `r str_c(indep.poblacion.copa.ap.sel, collapse = ", ") ` `` 

```{r tile-copa-poblacion-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre coberturas de copa y variables de población"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.poblacion, y=dependientes.arboles)+
  labs(title="Pearson entre cobertura de copa y variables de población")

```


```{r tile-copa-poblacion-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre coberturas de copa y variables de población"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.poblacion, y=dependientes.arboles, method_cor = "spearman")+
  labs(title="Spearman entre cobertura de copa y variables de población")
```


Se recomienda especificar correctamente los modelos lineales cuando existen relaciones con correlaciones negativas, pues es posible que sea mejor usar el inverso de la variable. Para probar si al hacerlo dichas variables tienen incrementos en los coeficientes de correlación respecto de las variables dependientes. Como se observa en las figuras \@ref(fig:duolin-poblacion-copa) y \@ref(fig:duonolin-poblacioninv-copa) las mejoras son solo en la varible de `afro.porcentaje.inv` en el segundo dígito decimal. Como son tan pequeñas las diferencias opto por no usar las variables transformdas por la funcion inversa pues esto reduce el intervalo en que varian, reduciendo asi su poder explicativo. 




```{r duolin-poblacion-copa,cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población y variables dependientes de la cobertura de copa (regresión lineal + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =c("superior_postgrado",indep.poblacion.copa.ap.sel),
      columnsY =dependientes.arboles,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      # types = list(continuous = wrap_fn_with_params(lm_with_cor,
      #                                method_cor = "spearman",
      #                                method_smooth= "loess")),
      title = "Predictores de población vs. cobertura de copa (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)


```

```{r duonolin-poblacioninv-copa, cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población (usando el inverso de la variable con correlaciones negativas: $f(x)=\\frac{1}{x+1}$) y las variables dependientes de la cobertura de copa ( regresión lineal  + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =c("superior_postgrado",indep.poblacion.cobertura.ap), 
      columnsY =dependientes.arboles,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      # types = list(continuous = wrap_fn_with_params(lm_with_cor,
      #                                method_cor = "spearman",
      #                                method_smooth= "loess")),
title = "Predictores de población (invertido) vs. cobertura de copa (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)
```


#### Modelos de regresión lineal 

Antes ajustar los modelos suele ser común en los modelos de regresión ajustar la distribución de las variables dependientes (y a veces las independientes) por motivos teóricos usando transformaciones logarítmicas o de raíz cuadra para eliminar no linealidades entre las variables dependientes y las independientes, y reducir posibles fenómenos de heterocedasticidad debido a estas no-linealidades. Siguiendo el ejemplo, ajustaremos 5 modelos: uno por cada variable dependiente en sus tres versiones, sin transforma, con una tranformacion logaritmica (exepto para la cobertura_copa.ap pues por tener valores ya entre [0,1] produce valores negativos) y otra de la raiz cuadra. 

Los histogramas de las variables dependientes tranformadas se muestran en la figura \@ref(fig:hist-copa-trnsf). 
```{r hist-copa-trnsf, fig.asp=1.5,fig.cap="Histogramas de las variables de cobertura de copa transformadas"}
# histogramas 

regresion.arboles %>% select(one_of(c(dependientes.copa.trnsf,dependientes.copa.ap.trnsf))) %>%
  gather( key = indep.poblacion,
          value = valores,
          1:5) %>%
  ggplot()+
  geom_histogram(aes(x = valores),bins = 30, 
                 color = "white", fill="forestgreen")+
  facet_wrap(~indep.poblacion, scales = "free", ncol = 1)

```

Las mejoras sobre el modelo de regresión que puedan hacer estas transformaciones pueden apreciarse en los gráficos de dispersión de las variables independientes transformadas vs. las dependientes o/y en los coeficientes de correlación de Pearson. Como se observa en las figuras \@ref(fig:duolin-poblacion-copa-trnsf) y \@ref(fig:duolin-poblacion-cob-trnsf) hay leves mejoras al aplicar las transformaciones.    

```{r duolin-poblacion-copa-trnsf,cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población y variables dependientes de la área de copa transformdas (regresión lineal + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =indep.poblacion.copa.sel, 
      columnsY =dependientes.copa.trnsf,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      title = "Predictores de población vs. área de copa transformda (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)


```


```{r duolin-poblacion-cob-trnsf,cache=TRUE,fig.asp=0.62,fig.cap="Gráficas de dispersión entre predictores de población y variables dependientes de la cobertura de copa transformdas (regresión lineal + coeficiente de Pearson)"}
# entre predictoras y dependientes no lineal
ggduo(regresion.arboles,
      columnsX =indep.poblacion.copa.ap.sel, 
      columnsY =dependientes.copa.ap.trnsf,
      types = list(continuous = wrap_fn_with_params(lm_with_cor)),
      title = "Predictores de población vs. cobertura de copa transformda (regresión lineal + Pearson)"
)+ theme_grey(base_size = 8)


```

También es sabido que dividir o multiplicar por alguna constante no tiene ningún efecto en la calidad de la estimación , pero sí sobre los coeficientes de la regresión. Esto suele ser sensible a la hora de interpretar los cambios marginales de cada una de las variables independientes y su efecto sobre la variable dependiente. Sin embargo, lo que interesa para este estudio no es la interpretación de esos cambio sino la importancia relativa de cada variable y comparar los cambios de los coeficientes de regresión para el ajuste de cada modelo y/o las mejoras que pueda operar un modelos autorregresivo en caso de encontrase autocorrelación en los residuos de la regresión lineal. Por esta razón, normalizar los valores puede ser una ventaja pues mantiene los coeficiente mejor acotados. La normalización se aplica posterior a las transformaciones propuestas y se realiza dividiendo por el máximo valor de los datos de cada variable para mantener valores en el intervalo [0,1], dado que los valores son todos iguales o mayores que 0.

Al aplicar test para verificar que las condiciones de un buen ajuste (no hay sesgos en el estimador o una mala especificación del modelo) de un modelo lineal se cumplen:

- La media de los residuos es 0 o muy cercana.
- La distribución de los residuos es normal.
- Los residuos muestran homocedasticidad (la varianza es constante)

Para verificar la normalidad de los residuos usaremos el test de Shapiro–Wilk [@shapiro1965analysis ] y para la verificar si existe homocedasticidad el test de Breusch–Pagan [@breusch1979simple]. Además se acompaña de gráficas de diagnóstico de los resultados de cada modelo.
El siguiente código en **R** crea las 5 regresiones lineales propuestas y se resumen en la la tablas \@ref(tab:comp-lmcopa) y \@ref(tab:comp-lmcopaap)

```{r code-lm-area_copa, echo=TRUE,eval=TRUE}

dependiente <- "area_copa"
independientes  <- indep.poblacion.copa.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mn.area_copa.sel<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mn.area_copa.sel)
sm

```


```{r code-lm-log.area_copa,echo=TRUE,eval=TRUE}


dependiente <- "log.area_copa"
independientes  <- indep.poblacion.copa.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.log.area_copa.sel<-crear_lm_from_df(regresion.arboles.mn)
modelo<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mxn.log.area_copa.sel)
sm

```



```{r code-lm-sqrt.area_copa,echo=TRUE,eval=TRUE}

dependiente <- "sqrt.area_copa"
independientes  <- indep.poblacion.copa.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.sqrt.area_copa.sel<-crear_lm_from_df(regresion.arboles.mn)
summary(lm.mxn.sqrt.area_copa.sel)

```

Como se muestra en la tabla \@ref(tab:comp-lmcopa)De las 3 formulaciones de usadas para modelar el área de copa la que mejor ajuste obtuvo fue el que transforma la variable dependiente usando la raíz cuadrada (`log.area_copa`). Aunque el modelo de `sqrt.area_copa` explica el 60% de la variabilidad en los datos (Adjusted R-squared:  0.604), la versión logaritmica tiene un MSE y Akaike menor, y los residuos son normales (el test Shapiro). Este modelo considera las variables `superior_postgrado` y `densidad_poblacion` como muy significativas, ambos con coeficientes obteniendo valores consistentes con el signo de las correlaciones calculadas previamente en análisis bivariado de la figura \@ref(fig:duolin-poblacion-copa-trnsf).

```{r comp-lmcopa}
tabla<-fitstats_lm_df(lm.mn.area_copa.sel) %>% 
  rename(AC=fitstats) %>%
  left_join(fitstats_lm_df(lm.mxn.log.area_copa.sel),by="medidasfit") %>%
  rename(`Log(AC)`=fitstats) %>%
   left_join(fitstats_lm_df(lm.mxn.sqrt.area_copa.sel),by="medidasfit") %>%
  rename(`Sqrt(AC)`=fitstats)
kable(tabla,caption = "Resúmen ajuste modelos área copa preliminares",digits = 5)

```


Los modelos del porcenataje de cobertura de copa son lo siguientes:

```{r code-lm-cobertura_copa.ap,echo=TRUE, size="small"}


dependiente <- "cobertura_copa.ap"
independientes  <- indep.poblacion.copa.ap.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.cobertura_copa.ap<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mxn.cobertura_copa.ap)
sm


```


```{r code-lm-sqrt.cobertura_copa.ap,echo=TRUE, size="small"}


dependiente <- "sqrt.cobertura_copa.ap"
independientes  <- indep.poblacion.copa.ap.sel
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mxn.sqrt.cobertura_copa.ap<-crear_lm_from_df(regresion.arboles.mn)
sm<-summary(lm.mxn.sqrt.cobertura_copa.ap)
sm

```

Como se observa en la tabla \@ref(tab:comp-lmcopaap) el porcentaje de cobertura copa en el área pública, el mejor ajuste se obtuvo con la variable sin transformación `cobertura_copa.ap`. Este modelo considera que solo la variable `superior_postgrado.porcentaje` como muy significativas, y explica  casi el 46% de la variabilidad (Adjusted R-squared: `r summary(lm.mxn.cobertura_copa.ap)$adj.r.squared`) con MSE y Akaike menores. El coeficiente de la densidad de población obtiene un valor positivo y poco significativo, contrario al signo de la correlación obtenida en el análisis bivariado de la figura \@ref(fig:duolin-poblacion-cob-trnsf), por lo que es descartado.

```{r comp-lmcopaap}
tabla<-fitstats_lm_df(lm.mxn.cobertura_copa.ap) %>% 
  rename(`%CC`=fitstats) %>%
   left_join(fitstats_lm_df(lm.mxn.sqrt.cobertura_copa.ap),by= "medidasfit") %>%
  rename(`Sqrt(%CC)`=fitstats)
kable(tabla,caption = "Resúmen ajuste de porcentaje de cobertura de copa preliminares", digits = 5)

```


Reduzcamos ambos modelos eliminando las variables no significativas. Para el mejor modelo del área de copa el siguiente código realiza el trabajo resumir los resultados en gráficas diagnósticas y los tests de normalidad y homocedasticidad en la tabla \@ref(tab:fitlm-copa-best).

```{r code-best-lm-areacopa, eval=TRUE, echo=TRUE }
dependiente <- "log.area_copa"
independientes  <- c("superior_postgrado","densidad_poblacion")
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.best.area_copa<-lm(log.area_copa.mxn~superior_postgrado.mxn+
                        densidad_poblacion.mxn,
                      data = regresion.arboles.mn)
sm<-summary(lm.best.area_copa)
sm

```



```{r diagn-best-lm-areacopa, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal del área de copa"}

graf<-autoplot(lm.best.area_copa)
title1=grid::textGrob(format(as.formula(lm.best.area_copa)) %>%
                        str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)


```

Los resultados de los tests (tabla \@ref(tab:fitlm-copa-best)) rechazan que los residuos sean normales, pero la varianza pasa el test Breusch-Pagan de homocedasticidad. Es posibles que los estimadores sean ineficientes y que existan efecto no considerados en el modelo dada la no normalidad de los residuos. Las gráficas diagnosticas (figura \@ref(fig:diagn-best-lm-areacopa)) muestran que existe no linealidades en los residuos, pues se observa como la linea de tendencia hace curvas respecto de la horizontal. Para probar si es posible tener un modelo mejor especificado se introduce en la sección [análisis geoestadisticos](#geostat) basados en la autocorrelación espacial. 


```{r fitlm-copa-best}
tabla<-fitstats_lm_df(lm.best.area_copa) %>% 
  rename(`Area Copa`=fitstats)
frml<-as.formula(lm.best.area_copa) %>% as.character()
#titulo<-str_c("Resúmen ajuste OLS:",frml[2],sep = " ")
kable(tabla,caption = "Resúmen ajuste OLS: log(area copa)", digits = 5)

```


El mismo procedimiento lo aplicamos para el mejor modelo de cobertura de copa. El siguiente código construye el modelo y realiza los test descritos anteriormente.  


```{r code-best-lm-copaap, eval=TRUE, echo=TRUE }
dependiente <- "cobertura_copa.ap"
independientes  <- c("superior_postgrado.porcentaje")
# max normalizado 
var_names<-c(dependiente,independientes)
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.best.cobertura.ap<-lm(cobertura_copa.ap.mxn~superior_postgrado.porcentaje.mxn,
                         data = regresion.arboles.mn)
sm<-summary(lm.best.cobertura.ap)
sm

```


```{r diagn-best-lm-copaap, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal del porcentaje de cobertura de copa"}

graf<-autoplot(lm.best.cobertura.ap, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.best.cobertura.ap)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
```



```{r fitlm-copaap-best}
tabla<-fitstats_lm_df(lm.best.cobertura.ap) %>% 
  rename(`%Cobertura de Copa`=fitstats)
# frml<-as.formula(lm.best.cobertura.ap) %>% as.character()
# titulo<-str_c("Resúmen ajuste OLS:",frml[2],sep = " ")
kable(tabla,caption = "Resúmen ajuste OLS: cobertura copa.ap", digits = 5)

```


Los resultados de los tests rechazan que los residuos sean normales y que la varianza sea constante (tabla \@ref(tab:fitlm-copaap-best)), sin embargo, es notorio el aumento de la varianza con el aumento de los valores ajustados; la curva de tendencia de los residuos vs. los valores ajustados sigue una linea de tendencia que se distancia de la horizontal confirmando la heterocedasticidad de los residuos (figura \@ref(fig:diagn-best-lm-copaap)). Igualmente veremos si la introducción de elementos de la teoría geoestadística permite mejorar la especificación del modelo.





#### Introducción de dimensiones no poblacionales al modelo lineal

Para la inclusión de otras variables agregadas por sector urbano aplicamos el procedimiento realizado para la selección de las variables de población usando como criterio la inclusión de variables con coeficientes de correlación que muestren una asociación fuerte con las variables de cobertura de copa. Las figuras \@ref(fig:tile-prediosev-pearson) y \@ref(fig:tile-prediosev-spearman) se ven los coeficientes de Pearson y Spearman, respectivamente, entre las variables sobre el uso los predios, tipo de viviendas y área (y porcentaje) de espacios verdes en cada sector urbano. Como se observa, existe una fuerte (perfecta) asociación negativa entre el porcentaje de casas y apartamentos, lo que obliga a solo escoger una de las dos en caso de haber una fuerte relación entre alguna de ellas con las variables de cobertura de copa. También hay una fuerte asociación positiva entre el área de espacios verdes y el porcentaje de área de espacio verdes en un sector urbano. Como mencionamos antes solo incluiremos una de las dos en caso de que ambas resulten fuertemente asociadas con las variables dependientes.  

```{r tile-prediosev-pearson, fig.asp=1,fig.cap="Coeficiente Pearson entre variables de uso de los predios y espacios verdes en los sectores urbanos"}
pintar_corrmatrix(regresion.arboles,indep.predios)+
  labs(title="Pearson entre características de predios y EV")
```

```{r tile-prediosev-spearman, fig.asp=1,fig.cap="Coeficiente Pearson entre variables de uso de los predios y espacios verdes en los sectores urbanos"}
pintar_corrmatrix(regresion.arboles,indep.predios, method_cor = "spearman")+
  labs(title="Spearman entre entre características de predios y EV")
```

Las figuras \@ref(fig:tile-copa-prediosev-pearson) y \@ref(fig:tile-copa-prediosev-spearman) muestran la correlación entre las potenciales nuevas variables a incluir en el modelo y las variables dependientes de cobertura y área de copa. Para el área de copa se seleccionan el área de espacios verdes (`area_ep`) y el porcentaje de viviendas tipo cuarto (`cuarto.porcentaje`). Para el modelo de porcentaje de cobertura de se seleccionan `apartamento.porcentaje`, `cuarto.porcentaje` y `area_ep.porcentaje`.

```{r tile-copa-prediosev-pearson, fig.asp=0.65, fig.cap= "Coeficiente Pearson entre coberturas de copa y variables de predios y EV"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.predios, y=dependientes.arboles)+
  labs(title="Coeficiente Pearson entre cobertura de copa y uso de los predios")
```


```{r tile-copa-prediosev-spearman, fig.asp=0.65,fig.cap="Coeficiente Pearson entre coberturas de copa y variables de predios y EV"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.predios, y=dependientes.arboles, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre  cobertura de copa y uso de los predios")
```

La nueva formulación del modelo de área de copa obtiene los siguientes resultados:

```{r code-mode-best-lm-areacopa, eval=TRUE, echo=TRUE}

# introducimos las varibles nuevas
dependiente <- "log.area_copa"
independientes  <- c("superior_postgrado","densidad_poblacion",indep.predios.copa.sel)
# max normalizado 
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mod.area_copa<-lm(log.area_copa.mxn~superior_postgrado.mxn+
                        densidad_poblacion.mxn+
                        cuarto.porcentaje.mxn+
                        area_ep.mxn,
                      data = regresion.arboles.mn)
sm<-summary(lm.mod.area_copa)
sm

```


```{r comp-lmcopa-pob-mod}
tabla<-fitstats_lm_df(lm.best.area_copa) %>% 
  rename(`Log(AC)~pob`=fitstats) %>%
   left_join(fitstats_lm_df(lm.mod.area_copa),by= "medidasfit") %>%
  rename(`log(AC)~pob+otras`=fitstats)
kable(tabla,caption = "Comparación OLS para el área de copa (AC) con variables de población y con otras dimensiones", digits = 5)

```

Las variables introducidas tienen todas p-value significativos, y a pesar de la inclusión de más términos al modelo existe una mejora en el Criterio de Información de Akaike (baja de $`r AIC(lm.best.area_copa)`$ a $`r AIC(lm.mod.area_copa)`$). Los resultados de los test evidencian que aunque hay mejoras en Adjusted R-squared ( de $`r summary(lm.best.area_copa)$adj.r.squared`$ a $`r summary(lm.mod.area_copa)$adj.r.squared`$) y en MSE (de $`r mean(summary(lm.best.area_copa)$residuals^2)`$ a $`r mean(summary(lm.mod.area_copa)$residuals^2)`$) sigue existiendo no normalidad en los residuos y posibles no linealidades, como se observa también en las gráficas diagnosticas de la regresión \@ref(fig:diagn-mod-best-lm-copa).


```{r diagn-mod-best-lm-copa, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de área de copa con los nuevos términos"}

graf<-autoplot(lm.mod.area_copa, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.mod.area_copa)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)

```


Para el caso del porcentaje de cobertura de copa los resultados obtenidos con la introduccion de las nuevas varibles son los siguientes:

```{r code-mode-best-lm-copaap, eval=TRUE, echo=TRUE}
# coberbtura AP
dependiente <- "cobertura_copa.ap"
independientes  <- c("superior_postgrado.porcentaje",indep.predios.copa.ap.sel)
# max normalizado 
var_names<-c(dependiente,independientes)
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
lm.mod.cobertura.ap<-lm(cobertura_copa.ap.mxn~superior_postgrado.porcentaje.mxn+
                          apartamento.porcentaje.mxn+
                          cuarto.porcentaje.mxn+
                          area_ep.porcentaje.mxn,
                        data = regresion.arboles.mn)
sm<-summary(lm.mod.cobertura.ap)
sm

```


```{r comp-lmcopaap-pob-mod}
tabla<-fitstats_lm_df(lm.best.cobertura.ap) %>% 
  rename(`%CC ~ pob`=fitstats) %>%
   left_join(fitstats_lm_df(lm.mod.cobertura.ap),by= "medidasfit") %>%
  rename(`%CC ~ pob+otras`=fitstats)
kable(tabla,caption = "Comparación OLS para el porcentaje de cobertura de copa con variables de población y otras dimensiones", digits = 5)

```

Las variables introducidas tienen todas p-value no significativos. La inclusión de más términos al modelo empeoran el Criterio de Información de Akaike (sube de $`r AIC(lm.best.cobertura.ap)`$ a $`r AIC(lm.mod.cobertura.ap)`$). Los resultados de los test no dan evidencian de mejoras importantes en Adjusted R-squared ( de $`r summary(lm.best.cobertura.ap)$adj.r.squared`$ a $`r summary(lm.mod.cobertura.ap)$adj.r.squared`$ ) o en MSE (de $`r mean(summary(lm.best.cobertura.ap)$residuals^2)`$ a $`r mean(summary(lm.mod.cobertura.ap)$residuals^2)`$). Sigue existiendo no normalidad en los residuos y heterocedasticidad, como se verifica en las gráficas diagnosticas de la regresión \@ref(fig:diagn-mod-best-lm-copaap).


```{r diagn-mod-best-lm-copaap, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de porcentaje de cobertura de copa con los nuevos términos"}

graf<-autoplot(lm.mod.cobertura.ap, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.mod.cobertura.ap)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
```


Finalmente presento los mapas de las variables dependientes de los 2 modelos seleccionados, comparandolas con el modelo ajustado y los residuos de ajuste, con el finde observar donde se localizan los errores en la predicción. La figura \@ref(fig:mapas-lm-copa) corresponde al ajuste del área de copa y la figura \@ref(fig:mapas-lm-copaap) al porcentaje de la cobertura de copa.

```{r mapas-lm-copa, fig.asp= 0.7,fig.cap="Variable dependiente, valor ajsutado por el modelo y residuos del OLS para log.area copa normalizada"}
pintar_mapa_su_lm2(regresion.arboles,lm.mod.area_copa,nrow =1)
```

```{r mapas-lm-copaap, fig.asp= 0.7,fig.cap="Variable dependiente, valor ajsutado por el modelo y residuos del OLS para cobertura copa.ap normalizada"}
pintar_mapa_su_lm2(regresion.arboles,lm.best.cobertura.ap,nrow =1)
```

### Acceso a espacios verdes

```{r mapa-dependienteEV-all, fig.asp= 0.7,fig.cap="Metricas de acceso a espacio verdes"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(dep.EV.ntl.long,by = c("id"="SETU_CCDGO")) %>%
  filter(dep.EV %in% dependientes.EV) %>%
  ggplot()+
  geom_polygon(data = su.f, aes(x= long, y = lat, group = group), fill = "grey60")+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~dep.EV, nrow = 1)+
  tema_lgnd_abajo()
```

En el caso de los EV contamos con una gran variedad de medidas sobre el acceso en relación con la distancia, el área disponible y diferentes formulaciones para aproximarse al concepto de acceso a un servicio ambiental (Figura \@ref(fig:mapa-dependienteEV-all)). Para acotar el alcance de este trabajo, nos concentramos en dos métricas: el porcentaje de área de espacio verde de un sector censal (`area_ep.porcentaje`), para aproximarse desde la idea de los beneficios principalmente a nivel local, y la razón área disponible distancia (`ia.areas.dist`), que tiende a formar agrupaciones de SU al rededor de las sectore donde se ubican espacios verdes, ya sea por número o por tamaño, que contemplan el fenómeno del acceso o beneficio como un proceso acotado por la distancia escogida de 1 kilómetro como radio de búsqueda; considerándola una distancia caminable para viajar en una ciudad como Cali. (Figura \@ref(fig:mapa-dependienteEV-sel))

```{r mapa-dependienteEV-sel, fig.asp= 0.7,fig.cap="Metricas de acceso a espacio verdes seleccionadas"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(dep.EV.ntl.long,by = c("id"="SETU_CCDGO")) %>%
  filter(dep.EV %in% dependientes.EV.sel) %>%
  ggplot()+
  geom_polygon(data = su.f, aes(x= long, y = lat, group = group), fill = "grey60")+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~dep.EV, nrow = 1)+
  tema_lgnd_abajo()
```


#### Correlaciones y distribuciones bivaridas

Las variables de población y su correlación con los indicadores de acceso seleccionados nos sirven para seleccionar una vez más las variables independientes para usar en los modelos de regresión lineal. Las figuras \@ref(fig:tile-ev-poblacion-pearson) y \@ref(fig:tile-ev-poblacion-spearman) resumen los resultados del cálculo de los coeficientes de Pearson y Spearman respectivamente. Como se observa, esta relación es muy débil, y en todos las variables (y para ambos coeficientes de correlación) es inferior a 0.3, un valor considerado muy bajo para incluir alguna de estas variables para que tenga éxito una aproximación lineal o no lineal al predecir o ajustar valores. Sin embargo, y como parte del proceso para indagar sobre el efecto en la estimación de parámetros de los modelos geoestadísticos, seleccionaremos las variables con mayor correlación: `densidad_poblacion`,`con_alguna_limitacion.porcentaje` mejor relacionadas con el índice de acceso `ia.areas.dist` y `ningun_estudio.porcentaje` para `area_ep.porcentaje`.

```{r tile-ev-poblacion-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre acceso a EV y variables de población"}
pintar_corrmatrix_XY(regresion.EV,x=indep.poblacion, y=dependientes.EV.sel)+
    labs(title="Pearson entre acceso a EV y variables de población")

```


```{r tile-ev-poblacion-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre acceso a EV y variables de población"}
pintar_corrmatrix_XY(regresion.EV,x=indep.poblacion, y=dependientes.EV.sel, method_cor = "spearman")+
  labs(title="Spearman entre acceso a EV y variables de población")
```

Resulta interesante ver, al igual que en el modelado de la cobertura de copa, si otras variables no poblacionales explican los resultados de los índices de acceso seleccionados. El conjunto de variables sobre el uso de los predios y sus coeficientes de correlación se muestran en las figuras \@ref(fig:tile-ev-uso-pearson) y \@ref(fig:tile-ev-uso-spearman). De nuevo las correlaciones son bajas, aparentemente poco explicativas de los índices de acceso. Las variables de uso de los predios que mejor se relacionan con los índices son: `unidad_economica.porcentaje` y el `cuarto.porcentaje`. 

```{r tile-ev-uso-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre acceso a EV y variables de uso de los predios"}
pintar_corrmatrix_XY(regresion.EV,x=indep.predios, y=dependientes.EV.sel)+
  labs(title="Coeficiente Pearson entre dependiente EV e \nindependientes uso de predios")

```


```{r tile-ev-uso-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre acceso a EV y variables de uso de los predios"}
pintar_corrmatrix_XY(regresion.EV,x=indep.predios, y=dependientes.EV.sel, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre dependiente EV e \nindependientes uso de predios")

```

El último bloque de variables indaga sobre las áreas y proporciones de las manzanas de cada sector censal y la vocación como pública o privada de los espacios dentro de un sector urbano. La figura \@ref(fig:tile-ev-fisica-pearson) y \@ref(fig:tile-ev-fisica-spearman) muestran que el área media de las manzanas (`area_media_manzana`) de los sectores urbanos se relaciona de forma positiva con ambos índices de acceso, mucho más fuertemente que las variables exploradas hasta el momento.  Aunque parece haber una fuerte correlación de los indicadores de acceso con las áreas privadas, públicas y del sector urbano, estas hacen parte de los cálculos que generan estos índices, produciendo en efecto ficticio en la correlación, razón por la que no haremos uso de ellas en la modelación.

```{r tile-ev-fisica-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre acceso a EV y variables sobre aspectos físicos de las manzanas y SU"}
pintar_corrmatrix_XY(regresion.EV,x=indep.estruct, y=dependientes.EV.sel)+
  labs(title="Coeficiente Pearson entre dependientes EV e \nindependientes físicas de predios y SU")

```


```{r tile-ev-fisica-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre acceso a EV y variables sobre aspectos físicos de las manzanas y SU"}
pintar_corrmatrix_XY(regresion.EV,x=indep.estruct, y=dependientes.EV.sel, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre dependientes EV e \nindependientes físicas de predios y SU")

```

A manera de resumen e información de apoyo al proceso de modelación se incluye las distribuciones de bivariadas de términos independientes escogidos con el análisis de correlación y los índices de acceso a modelar.

```{r bivar-ev, fig.asp=0.6, fig.cap="Distribución de variables independientes respecto de los índices de acceso a EV"}
ggduo(regresion.EV ,
      columnsX =independientes.EV, 
      columnsY =dependientes.EV.sel,
      types = list(continuous = wrap(lm_with_cor))
)+
  theme(strip.text.x = element_text(size = 4))

```

#### Modelos de regresion lineal 

A diferencia de la cobertura de copa, donde el proceso de modelado fue incluyendo términos gradualmente para observar otros componentes no poblacionales, para la los espacios verdes usaremos todos los términos seleccionados con los coeficientes de correlación para luego ver la significancia de las variables en el modelo y elegir el modelo con mejor ajuste usando criterio de información de Akaike (AIC) seleccionando los coeficientes significativos y comparando el AIC de la versión con todas la variables con el modelo simplificado. Para estos índices de acceso no usaremos variantes transformadas de la variable dependiente, solo se aplica una normalización a los datos.
Para el índice de acceso de porcentaje de área de espacios verdes en un sector urbano el modelo a ajusta el siguiente:


```{r code-lm-area_ep,echo=TRUE,eval=TRUE}

dependiente <- "area_ep.porcentaje"
independientes  <- independientes.EV
# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.area_ep.ptje<-crear_lm_from_df(regresion.EV.mn)
summary(lm.area_ep.ptje)

```

Los resultados muestran que las variables `cuarto.porcentaje`  `area_media_manzana` son significativas. Con el modelo simplificado obtenemos los siguientes resultados:

```{r code-lm-area_ep-sel,echo=TRUE,eval=TRUE}

dependiente <- "area_ep.porcentaje"
independientes  <- independientes.EV
# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.area_ep.ptje.sel<-lm(area_ep.porcentaje.mxn~cuarto.porcentaje.mxn+
                      # unidad_economica.porcentaje.mxn+
                      area_media_manzana.mxn#+
                      # densidad_poblacion.mxn+
                      #ningun_estudio.porcentaje.mxn
                      ,
                    data = regresion.EV.mn)
summary(lm.area_ep.ptje.sel)

```


En la tabla comparativa \@ref(tab:comp-lm-areaep) que resume las medidas de ajuste de ambos modelos se evidencia los residuos presentan heterocedasticidad y no normalidad, lo que lo hace candidato a explorar el modelo ajuste geoestadístico. Existe una mejora lógica en el AIC del modelo simplificado debido a la reducción de términos del modelo. Los gráficos \@ref(fig:diagn-lm-areaep-sel)  muestran los resultados del ajuste en relación con los residuos y \@ref(fig:mapas-lm-areaep) espacialmente. 

```{r comp-lm-areaep}
tabla<-fitstats_lm_df(lm.area_ep.ptje) %>% 
  rename(`Todas las variables`=fitstats) %>%
   left_join(fitstats_lm_df(lm.area_ep.ptje.sel),by= "medidasfit") %>%
  rename(`Variables seleccionadas`=fitstats)
kable(tabla,caption = "Comparación OLS del modelos con todas las variables y el modelo simplificado del porcentaje de area de espacio verde", digits = 5)

```

```{r diagn-lm-areaep-sel, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de porcentaje de area de espacio verde"}

graf<-autoplot(lm.area_ep.ptje.sel, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.area_ep.ptje.sel)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
```

```{r mapas-lm-areaep, fig.asp= 0.7,fig.cap="Variable dependiente, valor ajustado por el modelo y residuos del OLS para `area ep.porcentaje` normalizada"}
pintar_mapa_su_lm2(regresion.EV,lm.area_ep.ptje.sel,nrow =1)
```

Para el indice de acceso `ia.areas.dist` el modelo con todos lo terminos es el siguiente:

```{r code-lm-areadist,echo=TRUE,eval=TRUE}

dependiente <- "ia.areas.dist"
independientes  <- independientes.EV
# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.ia.areas.dist<-crear_lm_from_df(regresion.EV.mn)
summary(lm.ia.areas.dist)

```

Solo la densidad de población no es significativa, sin embargo, como se muestra en la tabla \@ref(tab:comp-lm-areasdist) , al eliminarla, empeora levemente el AIC, el MSE y el adj-Rsquare . Consideraremos el modelo sin simplificar para los ajustes geoestadístico. Los gráficos \@ref(fig:diagn-lm-areadist-sel)  muestran los resultados del ajuste del modelo con todas las variables en relación con los residuos y \@ref(fig:mapas-lm-areasdist) espacialmente. 

```{r code-lm-areadist-sel,echo=FALSE,eval=TRUE}
#Ajuste modelo simplificado
dependiente <- "ia.areas.dist"
independientes  <- independientes.EV
# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.ia.areas.dist.sel<-lm(ia.areas.dist.mxn~cuarto.porcentaje.mxn+
                           unidad_economica.porcentaje.mxn+
                           area_media_manzana.mxn+
                           #densidad_poblacion.mxn+
                           ningun_estudio.porcentaje.mxn+
                           con_alguna_limitacion.porcentaje.mxn,
                     data = regresion.EV.mn)
summary(lm.ia.areas.dist.sel)

```


```{r comp-lm-areasdist}
tabla<-fitstats_lm_df(lm.ia.areas.dist) %>% 
  rename(`Todas las variables`=fitstats) %>%
   left_join(fitstats_lm_df(lm.ia.areas.dist.sel),by= "medidasfit") %>%
  rename(`Variables seleccionadas`=fitstats)
kable(tabla,caption = "Comparación OLS de los modelos con todas las variables y el modelo simplificado de índice de acceso `ia.areas.dist`", digits = 5)

```

```{r diagn-lm-areadist-sel, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de 'ia.areas.dist'"}

graf<-autoplot(lm.ia.areas.dist, which = 1:4)
title1=grid::textGrob(format(as.formula(lm.ia.areas.dist.sel)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
```

```{r mapas-lm-areasdist, fig.asp= 0.7,fig.cap="Variable dependiente, valor ajustado por el modelo y residuos del OLS para `ia.areas.dist` normalizada"}
pintar_mapa_su_lm2(regresion.EV,lm.ia.areas.dist,nrow =1)
lm.ia.areas.dist.sel<-lm.ia.areas.dist
```

## Análisis geoestadísticos { #geostat }

Para los analsis geoestadisticos introducimos los modelos autoregresivos para obtener mejoras en la estimación de los coeficientes y en el ajuste de los modelo si existe algun tipo de autocorrelacion espacial en los residuos. Exite una variedad de estos modelos que capturan diferentes tipos de efectos: modelo autoregresivo SAR que capturan efectos de la variable dependiente, ecuación \@ref(eq:sar) , sobre las varibles las independientes ( spatial lag o retardo espacial en $X$ SLX, ecuación \@ref(eq:slx), en el error (modelo espacial del errore SEM,ecuación \@ref(eq:sem) o usando una combinacion del modelo de error y autoregresivo (modelo espacial de Durbin SD,ecuación \@ref(eq:sd). Todas estas aproximaciones introducen una matriz de $W_{n \times n}$, donde $n$ es el número de sitios, que captura la influencia de las variables en relación con su proximidad. Esta matriz $W$ es una estructura que restringe la influecia a priori en el modelo. Para observar el efecto que tiene esta matriz sobre los resultados del modelo usaremos 2 matrices distintas, y veremos su impacto en la estimación.

Para los análisis espaciales usaremos la libreria `spdep` [@R-spdep]

### Matrices de vecindad

La matriz $W$ representa la topología de vecindad entre los sectores censales. Existen la literatura diferentes tipos de vecindad: rook, bishop y queen son las más referenciadas. Esta vecindad está representada en la matriz con 1 cuando existe vecindad y 0 cuando no. Otra forma de cuantificar la interacción de esa vecindad es usando una matriz de inversos de la distancia entre los centroides de los sectores censales, con el fin de atenuar la interacción entre sectores muy alejados y tener una variable continua que representa esa influencia. En la figura \@ref(fig:w-su-todos) se muestra la matriz $W$ defina para vecinos que comparten un lado del polígono (vecindad rook) para todos los sectores de la ciudad de Cali.

```{r w-su-todos, fig.cap="Grafo de vecidad entre todos los SU de la ciudad de Cali"}
nb.su<-poly2nb(su, row.names = su$SETU_CCDGO)
par(mai=c(0,0,0,0))
plot(su, border="grey80")
plot(nb.su, coordinates(su), col='grey50', pch=19, cex=0.1,add=TRUE)
```

Sin embargo, la regresiones se realizaron sobre un subconjunto de los datos, y por tanto la estructura de esta matriz debe tener esto en cuenta, o mejor, no tener en cuenta la influencia de estos sectores excluidos. Así la matriz de vecindad para los SU usados para la estimación de los coeficientes de las regresiones lineales se ve en la figura \@ref(fig:w-su-reg).

```{r w-su-reg, fig.cap="Grafo de vecidad entre los SU seleccionados para el análisis"}

par(mai=c(0,0,0,0))
plot(su, border="grey80")
plot(W_cont, coordinates(su.arboles), col='orchid1',pch=19, cex=0.1, add=TRUE)
```

Las matrices de vecindad construidas para el análisis espacial son la *queen* $W_q$, que considera vecino a todos los sectores que comparten un lado o una esquina con un sector censal; y una matriz de distancia inversas entre los centroides de los SU, restringiendo la vecindad a aquellos centroides que están a menos de 1 km ($W_d$). El valor de un kilometro es arbitrario, aunque razonable en la escala humana. Los grafos que representan las 2 matrices $W$ se muestran en la figura \@ref(fig:ws-su-reg). 

```{r ws-su-reg, fig.asp=1.5 ,out.width='48%' ,fig.cap="Matrices de vecindad del análisis espacial",fig.align="center",fig.show="hold"}
plot(W_queen,coords=coordinates(su.arboles),pch=19, cex=0.1, col="gray", main="Queen")
title(main = "Queen")
plot(W_dist1000.inv,coords=coordinates(su.arboles),pch=19, cex=0.1, col="gray", main="Distancia inversa a 1km")
title(main = "Distancia inversa a 1km")

```

La matriz $W_d$ impone un estructura de interacciones que puede relacionar sectores en una zona que no necesariamente comparten ningún lado o esquina pero que están cercanos, mientras que $W_q$ se restringe a condiciones de vecindad sólo entre sectores contiguos. En esa medida puede existir juego para dar interpretación teórica al fenómeno de derrame o influencia que ejercen sobre el ajuste de los modelos. Un ejemplo puede ser que la dependencia espacial de las cobertura de árboles que expresa $W_d$ es una característica en una zona no limitada por las divisiones del territorio con base en los desarrollos urbanísticos (barrios) sino que se ajustan más a fenómenos de dispersión continuos con base en el alcance escogido. Así, la $W_q$ puede interpretarse como una forma de dar relevancia a la continuidad entre barrios y su importancia como unidad de desarrollo urbano en las variaciones de la variable a predecir. 

### Modelado espacial de la cobertura de copa

#### Autocorrelación espacial

Para indagar sobre la información o patrones espaciales de los residuos de los modelos de regresión usaramos el índice de Moran I. El índice de Moran I es el coeficiente de correlación para la relación entre una variable y sus valores circundantes. Si encontramos una correlación espacial significativa en los residuos, esto sugiere que agregando esa estructura en el modelo podremos obtener una estimación más eficiente de los coeficientes, y en consecuencia un mejor entendimiento de la relación entre esas variables. Hay que recordar que en este ejercicio no estamos queriendo entender una población por una muestra, estamos calculando estos coeficientes sobre el total de la población, y por tanto los coeficientes pueden interpretarse como la fuerza de esa relación. La confianza en esa estimación depende de que los residuos obtenidos sean tenga un valor medio de 0, y que no puedan distinguirse del ruido. La ecuación \@ref(eq:moranI) define matemáticamente el índice:


\begin{equation}
 I=\frac {N}{\sum _{i}\sum _{j}w_{ij}} \frac {\sum _{i}\sum _{j}w_{ij}(X_{i}-{\bar {X}})(X_{j}-{\bar {X}})}{\sum _{i}(X_{i}- \bar{X})^{2}}
(\#eq:moranI)
\end{equation}

donde $N$ es el número de unidades espaciales indexados por $i$ y  $j$; $X$ es la variable de interés; $\bar {X}$ es la media de $X$; y $w_{ij}$ es un elemento de una matriz de pesos espaciales $W$. Un valor de 0 de Moran’I indica un patrón espacial aleatorio. Si existe autocorrelación los valores son positivos y el máximo es 1. Si los valores son negativos decimos que existe dispersión, siendo -1 el mínimo valor posible representando la dispersión perfecta.

El gráfico de Moran es una forma de observar el valor de la pendiente (el índice de autocorrelación) graficando los valores retardados (spatial lag: es como dijimos previamente el valor medio de los valores vecinos) de la variable en cuestión en el eje $y$ y la variable en el $x$. El valor **$p$** del test estadístico nos dice qué tan seguros estamos que esa pendiente no es plana, por lo que se espera que sean menores que el valor límite de significancia $\alpha = 0.05$  

> El hecho de que de la Morán I es una suma de productos cruzados individuales es explotado por los "indicadores locales de asociación espacial" (LISA) para evaluar la agrupación de las unidades individuales mediante el cálculo de la I de Moran local para cada unidad espacial y la evaluación de la significación estadística para cada I. [@wikilisa]

Los mapas que acompaña el resultado númerico y el grafico de Moran son el valor z-normalizado del LISA, el valor $p$ y el mapa de clusters. En este ultimo mapa las regiones resaltadas en rojo tienen valores altos de la variable y tienen vecinos con valores altos también (high-high). El área azul es low-low los vecinos presentab valores bajos al igual que sus vecinos. Mientras que las regiones azul pálido son low-high y las áreas rosadas son high-low muestran correlación negativa, es dicir valores muy diferentes a los de sus vecinos. Las regiones fuertemente coloreadas son aquellas que contribuyen significativamente a un resultado positivo de autocorrelación espacial global, mientras que los colores más claros contribuyen significativamente a un resultado de autocorrelación negativo.

Examinemos primero la autocorrelación de las varibles dependientes.

##### Variables dependientes


```{r code-moran-copa-w, echo=TRUE}
moran.test(lm.mod.area_copa$model$log.area_copa.mxn, listw=W_queen)
moran.test(lm.mod.area_copa$model$log.area_copa.mxn, listw=W_dist1000.inv, zero.policy = TRUE)

```

```{r moranplot-copa-w, fig.cap="Gráfico de Moran para los residuos del modelo lineal para del área de cobertura de copa usando $W_{q}$",fig.show="hold",out.width='49%'}

moran.plot(lm.mod.area_copa$model$log.area_copa.mxn, 
             listw=W_queen, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="log.area_copa", 
             ylab="log.area_copa (Spatial Lag)", main="Gráfico de Moran Wq") 
moran.plot(lm.mod.area_copa$model$log.area_copa.mxn, 
             listw=W_dist1000.inv, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="log.area_copa", 
             ylab="log.area_copa (Spatial Lag)", main="Gráfico de Moran Wd") 

```



La matrix $W_q$ capatura mucho mejor de forma global la autocorrelacieon del area de copa. Los mapas LISA muestran los focos de esta autocorrelación usando la matriz para $W_q$ (figura \@ref(fig:mapas-lisa-copa-wq)) y para $W_d$ (figura \@ref(fig:mapas-lisa-copa-wd)) . 

```{r mapas-lisa-copa-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de `log.area copa`"}

pintar_mapa_su_LISA_var(regresion.arboles,"log.area_copa",W_queen, wname = "W_q",nrow =1)

```
En los estos mapas de LISA de ambas matrices se observan que los sectores en rojo (H-H) y azul (L-L) identifacan los lugares con autocorrelación positiva, formando grupos. No se presentan valores negativos de autocorrelación.   

```{r mapas-lisa-copa-wd,fig.asp=0.618,fig.cap="Mapas LISA para la matriz $W_d$ de `log.area copa`"}

pintar_mapa_su_LISA_var(regresion.arboles,"log.area_copa",W_dist1000.inv, wname = "W_d", nrow =1)

```



Para la variable dependiente porcentaje de cobertura de copa los resulados del análisis de autocorrelación se presentan a continuación.

```{r code-moran-copaap-w, echo=TRUE}
moran.test(lm.best.cobertura.ap$model$cobertura_copa.ap.mxn, listw=W_queen)
moran.test(lm.best.cobertura.ap$model$cobertura_copa.ap.mxn, listw=W_dist1000.inv, zero.policy = TRUE)

```

```{r moranplot-copaap-w, fig.cap="Gráfico de Moran para los residuos del modelo lineal para el porcenatajes cobertura de copa usando $W_{q}$",fig.show="hold",out.width='49%'}

moran.plot(lm.best.cobertura.ap$model$cobertura_copa.ap.mxn, 
             listw=W_queen, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="cobertura_copa.ap", 
             ylab="cobertura_copa.ap (Spatial Lag)", main="Gráfico de Moran Wq") 
moran.plot(lm.best.cobertura.ap$model$cobertura_copa.ap.mxn, 
             listw=W_dist1000.inv, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="cobertura_copa.ap", 
             ylab="cobertura_copa.ap (Spatial Lag)", main="Gráfico de Moran Wd") 

```


Ambos diseños de matriz revelan precencia clara de autocorrelación espacial, pero la matrix $W_d$ captura un legeramente mejor con un valor positivo y significativa, produciendo *clusters* de sectores urbanos más con más sectores urbanos. Los mapas LISA muestran los focos de esta autocorrelación usando la matriz para $W_q$ (figura \@ref(fig:mapas-lisa-copaap-wq)) y para $W_d$ (figura \@ref(fig:mapas-lisa-copaap-wd)) . No se presentan valores negativos de autocorrelación. 

```{r mapas-lisa-copaap-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de `cobertura copa.ap`"}

pintar_mapa_su_LISA_var(regresion.arboles,"cobertura_copa.ap",W_queen, wname = "W_q",nrow =1)

```

```{r mapas-lisa-copaap-wd,fig.asp=0.618,fig.cap="Mapas LISA para la matriz $W_d$ de `cobertura copa.ap`"}

pintar_mapa_su_LISA_var(regresion.arboles,"cobertura_copa.ap",W_dist1000.inv, wname = "W_d", nrow =1)

```


##### Residuos de los OLS

El siguiente código calcula los índices de autocorrelación de los residuos del mejor modelo lineal de área de copa  (`` `r str_c("sqrt.copa_area.mxn",str_c(names(lm.mod.area_copa$model)[-1],collapse =" + "), sep= " ~ ") ` ``) para ambas matrices $W$ y construye los gráficos de Moran y mapas LISA \@ref(fig:moranplot-rescopa-w) para $W_q$ y para $W_d$. 

```{r code-moran-rescopa-wq, echo=TRUE}
lm.morantest(lm.mod.area_copa, W_queen, alternative="two.sided",zero.policy = T)
lm.morantest(lm.mod.area_copa, W_dist1000.inv, alternative="two.sided",zero.policy = T)
```

```{r moranplot-rescopa-w, fig.cap="Gráfico de Moran para los residuos del modelo lineal para del área de cobertura de copa usando $W_{q}$ y $W_{d}$ ",fig.show="hold",out.width='49%'}

moran.plot(lm.mod.area_copa$residuals, 
             listw=W_queen, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wq")
moran.plot(lm.mod.area_copa$residuals, 
             listw=W_dist1000.inv, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wd") 


```

Para ambos casos el valor de Moran Global es mayor que 0 y significativo, aunque no es muy alto, si existe una tendencia en los datos y ambas matrices capturan el efecto. $W_d$ lo hace mejor en los residuos, mientras $W_q$ lo hace mejor con la varible dependiente. En las figuras \@ref(fig:mapas-lisa-rescopa-wq) y \@ref(fig:mapas-lisa-rescopa-wd) observamos que los grupos de sectores son más pequeños que los de las variables dependientes, lo que podría deberse a que las variables independientes presentan un patron espacial similar, y que por consiguiente, al introducir estos retardos al modelo van a ayudar a absorver esa diferencias para mejorar la estimación. 

```{r mapas-lisa-rescopa-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de los residuos del modelo lineal para del área de copa"}

pintar_mapa_su_LISA_lmres(regresion.arboles,lm.mod.area_copa,W_queen,  wname = "Wq",nrow =1)
  
```

```{r mapas-lisa-rescopa-wd,fig.asp=0.618,fig.cap="Mapas LISA para la matriz $W_d$ dede los residuos del modelo lineal para del área de copa"}

pintar_mapa_su_LISA_lmres(regresion.arboles,lm.mod.area_copa,W_dist1000.inv, wname = "Wd",nrow =1)

```



El mismo análisis se aplica al modelo de porcentaje de cobertura de copa (`` `r str_c("cobertura_copa.ap.mxn",str_c(names(lm.best.cobertura.ap$model)[-1],collapse =" + "), sep= " ~ ") ` ``). 


```{r code-moran-rescopaap-wq, echo=TRUE}
lm.morantest(lm.best.cobertura.ap, W_queen, alternative="two.sided",zero.policy = T)
lm.morantest(lm.best.cobertura.ap, W_dist1000.inv, alternative="two.sided",zero.policy = T)
```

```{r moranplot-rescopaap-w, fig.cap="Gráfico de Moran para los residuos del modelo lineal para el porcentaje de cobertura de copa usando $W_{q} y $W_{d}$",fig.show="hold",out.width='49%'}

moran.plot(lm.best.cobertura.ap$residuals, 
             listw=W_queen, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wq")
moran.plot(lm.best.cobertura.ap$residuals, 
             listw=W_dist1000.inv, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.arboles$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wd") 


```

Para ambos matrices el valor de Moran Global es mayor que 0 y significativo, casi el doble más alto que para el modelo de área de copa; el indicador porcentual de cobertura y el residuo del modelo para ajustarlo muestra el mismo trocamiento en la idoneidad de las matrices: el efecto es más fuerte con $W_d$ para la variable dependiente y levemente mayor con $W_q$ en los residuos. En las figuras \@ref(fig:mapas-lisa-rescopaap-wq) y \@ref(fig:mapas-lisa-rescopaap-wd) una vez más observamos que los grupos de sectores son más pequeños que los de las variables dependientes, lo que, como dijimos, se debe a que las variables independientes presentan un patrón espacial similar, y se espera que al introducir estos efectos espaciales al modelo mejora la confiabilidad de la estimación. 

```{r mapas-lisa-rescopaap-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de los residuos del modelo lineal para el porcentaje de cobertura copa"}

pintar_mapa_su_LISA_lmres(regresion.arboles,lm.best.cobertura.ap,W_queen,  wname = "Wq",nrow =1)
  
```

```{r mapas-lisa-rescopaap-wd,fig.asp=0.618,fig.cap="Mapas LISA para la matriz $W_d$ dede los residuos del modelo lineal para del área de copa"}

pintar_mapa_su_LISA_lmres(regresion.arboles,lm.best.cobertura.ap,W_dist1000.inv, wname = "Wd",nrow =1)

```


Los resultados nos invitan a proceder a realizar un ajuste en ambos modelos introduciendo algún tipo de estructura espacial. Posiblemente la matriz $W_q$ sea la candidata para el área de copa si se piensa en un modelo autorregresivo, pues parece capturar mejor en los test de autocorrelación global la existencia de grupos formados por fenomenos de dispersión o derrame en la distribución de la copa. En el caso de usar modelos de error espacial SEM posiblemente la candidata sea $W_d$ por capturar mejor la autocorrelación en los residuos. En busca de simplicar el análsis y concentrarnos entre los modelos usaremos $W_q$ para el área de copa; para el porcentaje de cobertura de copa la matriz que usaremos $W_d$ usando el mismo criterio. 

#### Ajuste de modelos espaciales

Mejorar la especificación de los modelos lineales incluyendo términos de retardo espacial en la variable dependiente (SAR \@ref(eq:sar)) se hace para obtener una adecuada estimación de los coeficientes de las otras covariables en el modelo. Si optamos por un modelo de error espacial  (SEM \@ref(eq:sem)) implica que no es necesario plantear efectos distintivos de la variable dependiente rezagada, y que es posible que ese efecto sea por otras variables no tenidas en cuenta: el agrupamiento espacial observado en la variable dependiente se explica simplemente por el patrón geográfico de variables independientes medidas y no medidas. El modelo SAR, en cambio, incorpora la influencia de variables independientes no medidas, pero también estipula un efecto adicional de valores de atributos vecinos, es decir, la variable dependiente rezagada. 
Si incluimos el retardo sólo de las variables independientes (SLX \@ref(eq:slx)) esperamos que los cambios en las dimensiones expresadas con las predictores produce un efecto de derrame o influencia en los sectores vecinos. 

¿Qué significa decir que la cantidad de cobertura de copa está relacionada con la de los sectores vecinos?¿Son los procesos de reproducción del arbolado urbano un fenómeno independiente de las intervenciones de sus habitantes y de los urbanizadores?¿Los habitantes que ven árboles en las cuadras o barrios aledaños deciden sembrar árboles en su vecindario?¿Existen similitudes en las condiciones estructurales de los barrios en ciertas zonas de la ciudad que prefieren las personas con mejores condiciones sociales( tener estudios superiores p.e)?¿Qué tipo de pérdidas en la cobertura de copa están motivadas por la densificación de un sector? ¿Cómo afectan los cambios en los tipos de oferta habitacional en un sector la cobertura de copa de los sectores vecinos? (las viviendas tipo cuarto suelen ofrecerse en pensiones y ser más económicas que las casas o apartamentos).

La pregunta a hacerse es cómo saber cuál de los diferentes modelos espaciales es el que mejor representa el fenómeno que estamos modelando y si los datos respaldan nuestras convicciones teóricas. Si el modelo de retraso espacial que especifique es realmente el correcto, entonces ninguna dependencia espacial debe permanecer en los residuos, y podremos elaborar sobre el tipo de procesos que pueden verse representados.


Una alternativa metodológica es probar los 4 tipos de modelos con la matriz $W_d$ que resultó capturar mejor la asociacion espacial en los datos y comparar sus resultados.

##### Área de copa 

```{r code-laglm-copa-wq, echo=TRUE}
#SAR

sar.mod.log.area_copa.wq<-lagsarlm(formula = as.formula(lm.mod.area_copa),
         data = lm.mod.area_copa$model,
         listw = W_queen, zero.policy = T,tol.solve=1.0e-30)
sar.sm<-summary(sar.mod.log.area_copa.wq,Nagelkerke=T)
sar.sm

# SEM
sem.mod.log.area_copa.wq<-errorsarlm(formula = as.formula(lm.mod.area_copa),
                                      data = lm.mod.area_copa$model,
                                      listw = W_queen, zero.policy = T,tol.solve=1.0e-30)
sem.sm<-summary(sem.mod.log.area_copa.wq,Nagelkerke=T)
sem.sm
#SD 

sd.mod.log.area_copa.wq<-lagsarlm(formula = as.formula(lm.mod.area_copa),
         data = lm.mod.area_copa$model,
         listw = W_queen, zero.policy = T,tol.solve=1.0e-30,type = "mixed")
sd.sm<-summary(sd.mod.log.area_copa.wq,Nagelkerke=T)
sd.sm

#SLX
slx.mod.log.area_copa.wq<-lmSLX(formula = as.formula(lm.mod.area_copa),
                           data = lm.mod.area_copa$model,
                           listw = W_queen, zero.policy = T)

slx.sm<-summary(slx.mod.log.area_copa.wq)
slx.sm
AIC(slx.mod.log.area_copa.wq)

```


```{r tabla-comp-modelos-copa }

tabla<-fitstats_laglm_df(lm.mod.area_copa,W_queen) %>% 
  rename(`OLS`=fitstats) %>%
   left_join(fitstats_laglm_df(slx.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  rename(`SD`=fitstats)

knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de área de copa")


```


Al comparar los resultados de las métricas de ajuste se identifica al modelo SD o mixto(variables con retardo y autocorrelación) con el mejor AIC. El modelo SD ha logrado eliminar la autocorrelación espacial global en los residuos, al igual que SAR y SEM (ver figura \@ref(fig:moranplot-resmodel-all-wq)). Aunque persiste la no normalidad de los residuos y la heterocedasticidad como los muestran los test y las gráficas diagnósticas, el error cometido disminuye y los coeficientes pueden considerarse más confiables. El $\rho$ y $\lambda$ de las estimaciones con términos de autoregresivos es significativo, lo que implica que la inclusión de los retardos funciona correctamente, aunque solo en los coeficientes de la variable retardada `cuarto.porcentaje` es significativo, aunque esta no tiene un coeficiente significativo como variable sin retardo, sugiriendo que interesa su efecto sobre el área de copa en los sectores vecinos a los focos de mayor concentración de viviendas tipo cuarto, pero no es importante en el resto de sectores. Como era de esperarse el porcentaje de área de espacios verdes es significativo en las variables sin retardo, pero no genera ningún efecto de derrame en la cobertura de copa de los sectores vecinos. A pesar de que los test de normalidad y heterocedasticidad no son existosos, las gráficas diagnósticas muestran que los problemas se presentan en los valores extremos. 

```{r moranplot-resmodel-all-wq, fig.cap="Gráfico de Moran para los residuos de los modelos espaciales de área de copa usando $W_{q}$", fig.show="hold", out.width="49%"}
moran.plot(sar.mod.log.area_copa.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sar", 
           ylab="residuos sar (Spatial Lag)", main="Gráfico de Moran SAR") 

moran.plot(sem.mod.log.area_copa.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sem", 
           ylab="residuos sem (Spatial Lag)", main="Gráfico de Moran SEM") 

moran.plot(slx.mod.log.area_copa.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos slx", 
           ylab="residuos slx (Spatial Lag)", main="Gráfico de Moran SLX") 

moran.plot(sd.mod.log.area_copa.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sd", 
           ylab="residuos sd (Spatial Lag)", main="Gráfico de Moran SD") 
```


```{r diag-model-espaciales, fig.asp=1.4, fig.cap="Diagnóstico comparativo entre modelos"}
diagPltsSAR<-diagPlotlaglm(sar.mod.log.area_copa.wq)
diagPltsSEM<-diagPlotlaglm(sem.mod.log.area_copa.wq)
diagPltsSD<-diagPlotlaglm(sd.mod.log.area_copa.wq)
diagPltsSLX<-diagPlotlaglm(slx.mod.log.area_copa.wq)
diagPltsOLS<-diagPlotlaglm(lm.mod.area_copa)

#diagPlotsAll<-arrangeGrob(grobs = c(diagPltsOLS,diagPltsSLX,diagPltsSD,diagPltsSEM,diagPltsSAR),ncol = 3, nrow = 5)
grid.arrange (arrangeGrob(grobs = diagPltsOLS, ncol = 3,left ="OLS"),
              arrangeGrob(grobs = diagPltsSLX, ncol = 3,left = "SLX"),
              arrangeGrob(grobs = diagPltsSAR, ncol = 3,left =  "SAR"),
              arrangeGrob(grobs = diagPltsSEM, ncol = 3,left = "SEM"),
              arrangeGrob(grobs = diagPltsSD,ncol = 3, left = "SD"),nrow =5)
```


##### Porcentaje de cobertura de área de copa 

El mismo ejercio se aplica al porcentaje de cobertura de copa.

```{r code-laglm-copaap-wq, echo=TRUE}
#SAR

sar.cobertura.ap.wq<-lagsarlm(formula = as.formula(lm.best.cobertura.ap),
         data = lm.best.cobertura.ap$model,
         listw = W_queen, zero.policy = T,tol.solve=1.0e-30)
sar.sm<-summary(sar.cobertura.ap.wq,Nagelkerke=T)
sar.sm

# SEM
sem.cobertura.ap.wq<-errorsarlm(formula = as.formula(lm.best.cobertura.ap),
                                      data = lm.best.cobertura.ap$model,
                                      listw = W_queen, zero.policy = T,tol.solve=1.0e-30)
sem.sm<-summary(sem.cobertura.ap.wq,Nagelkerke=T)
sem.sm
#SD 

sd.cobertura.ap.wq<-lagsarlm(formula = as.formula(lm.best.cobertura.ap),
         data = lm.best.cobertura.ap$model,
         listw = W_queen, zero.policy = T,tol.solve=1.0e-30,type = "mixed")
sd.sm<-summary(sd.cobertura.ap.wq,Nagelkerke=T)
sd.sm

#SLX
slx.cobertura.ap.wq<-lmSLX(formula = as.formula(lm.best.cobertura.ap),
                           data = lm.best.cobertura.ap$model,
                           listw = W_queen, zero.policy = T)

slx.sm<-summary(slx.cobertura.ap.wq)
slx.sm
AIC(slx.cobertura.ap.wq)

```

```{r tabla-comp-modelos-copaap  }

tabla<-fitstats_laglm_df(lm.best.cobertura.ap,W_queen) %>% 
  rename(`OLS`=fitstats) %>%
   left_join(fitstats_laglm_df(slx.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  rename(`SD`=fitstats)
knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de porcentaje de área de copa")


```



Al comparar los resultados de las métricas de ajuste se identifica al modelo SAR con el mejor rendimiento en el ajuste del modelo. El coeficiente de correlación $\rho$ es alto y muy significativo, lo que nos dice que es una mejora la inclusión de las características espaciales en los datos, y se reflejados en el índice de Akaike que tiene una mejora visible (de   $`r AIC(lm.best.cobertura.ap)`$ a $`r AIC(sar.cobertura.ap.wq)`$). Consistentemente la variable de **estudios superiores** en la población refleja el patrón de agrupamiento de la cobertura de copa teniendo la mayor importancia para la estimación; pero es poco significativa como variable retardada, y es por esto que los modelos de error espacial SEM y el mixto (SD) no son mejores que el autorregresivo. Todos los modelos espaciales logran reducir la autocorrelación en los residuos (ver figura \@ref(fig:moranplot-resmodel-all-copaap-wq)) lo que hace más confiables los coeficientes estimados, pero en el modelo SAR se mantiene una importancia en el efecto de la densidad de población como determinante para la reducción de la cobertura de copa. 

```{r moranplot-resmodel-all-copaap-wq, fig.cap="Gráfico de Moran para los residuos de los modelos espaciales del porcenatje de área de copa usando $W_{q}$", fig.show="hold", out.width="49%"}
moran.plot(sar.cobertura.ap.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sar", 
           ylab="residuos sar (Spatial Lag)", main="Gráfico de Moran SAR") 

moran.plot(sem.cobertura.ap.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sem", 
           ylab="residuos sem (Spatial Lag)", main="Gráfico de Moran SEM") 

moran.plot(slx.cobertura.ap.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos slx", 
           ylab="residuos slx (Spatial Lag)", main="Gráfico de Moran SLX") 

moran.plot(sd.cobertura.ap.wq$residuals, 
           listw=W_queen, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sd", 
           ylab="residuos sd (Spatial Lag)", main="Gráfico de Moran SD") 
```


```{r diag-model-espaciales-copaap, fig.asp=1.4, fig.cap="Diagnóstico comparativo entre modelos de porcentaje de copa"}
diagPltsSAR<-diagPlotlaglm(sar.cobertura.ap.wq)
diagPltsSEM<-diagPlotlaglm(sem.cobertura.ap.wq)
diagPltsSD<-diagPlotlaglm(sd.cobertura.ap.wq)
diagPltsSLX<-diagPlotlaglm(slx.cobertura.ap.wq)
diagPltsOLS<-diagPlotlaglm(lm.best.cobertura.ap)

#diagPlotsAll<-arrangeGrob(grobs = c(diagPltsOLS,diagPltsSLX,diagPltsSD,diagPltsSEM,diagPltsSAR),ncol = 3, nrow = 5)
grid.arrange (arrangeGrob(grobs = diagPltsOLS, ncol = 3,left ="OLS"),
              arrangeGrob(grobs = diagPltsSLX, ncol = 3,left = "SLX"),
              arrangeGrob(grobs = diagPltsSAR, ncol = 3,left =  "SAR"),
              arrangeGrob(grobs = diagPltsSEM, ncol = 3,left = "SEM"),
              arrangeGrob(grobs = diagPltsSD,ncol = 3, left = "SD"),nrow =5)
```



### Modelado espacial de espacios verdes

El proceso de ajuste de los modelos geoestadísticos para el análisis de espacios verdes hace uso de los mismos elementos metodológicos usados para la cobertura de copa. Se construyen dos matrices de velocidad usando un kernel de vecindad Queen $W_q$y otro con base en un radio de busqueda de 1 kilómetro $W_d$. El primer paso es evaluar cuál de las matrices captura mejor la autocorrelación de los residuos de los modelos lineales y de las variables dependientes. Seguidamente se compara los diferentes modelos espaciales para seleccionar el de mejor ajuste y finalmente se evalúa la significancia de las variables y el valor de los coeficientes de la regresión y la mejora en el ajuste con relación a los modelos lineales. 

#### Matrices de vecindad

Las dos matrices de vecindad construidas con los SU seleccionados para el análisis de regresión lineal. Las dos matrices resultantes se muestran en la figura \@ref(fig:)

```{r ws-su-reg-ev, fig.asp=1.5 ,out.width='48%' ,fig.cap="Matrices de vecindad del análisis espacial de espacios verdes",fig.align="center",fig.show="hold"}
plot(W_queen.ev,coords=coordinates(su.EV),pch=19, cex=0.1, col="gray", main="Queen")
title(main = "Queen")
plot(W_dist1000.inv.ev,coords=coordinates(su.EV),pch=19, cex=0.1, col="gray", main="Distancia inversa a 1km")
title(main = "Distancia inversa a 1km")

```

#### Autocorrelación espacial


##### Variables dependientes

Comparemos el efecto de cada una de las matrices sobre el indicador `area_ep.porcentaje` 

```{r code-moran-areaep-ws, echo=TRUE}
moran.test(regresion.EV$area_ep.porcentaje, listw=W_dist1000.inv.ev,zero.policy = TRUE)
moran.test(regresion.EV$area_ep.porcentaje, listw=W_queen.ev)

```



```{r code-moran-areadist-w, echo=TRUE}
moran.test(regresion.EV$ia.areas.dist, listw=W_dist1000.inv.ev,zero.policy = TRUE)
moran.test(regresion.EV$ia.areas.dist, listw=W_queen.ev)

```

La matriz $W_q$ captura con mayor fuerza la autocorrelación espacial de `area_ep.porcentaje`. Al repetir el test para `ai.areas.dist` una vez más $W_q$ captura con mayor intensidad la autocorrelación espacial del indicador, que es mucho mayor que en `area_ep.porcentaje`, posiblemente por representar una característica local del acceso. Hay que anotar aquí que el cálculo del índice `ia.areas.dist` en su construcción usa una distancia de radio de búsqueda de 1 kilómetro; en su definición el indicador está influenciado por sus vecinos por lo que se forman grupos o clusters alrededor de ciertos sectores urbanos. Resulta pues interesante no sea $W_d$ la que capture mejor el agrupamiento.

Para indagar sobre los patrones espaciales de los dos indicadores usando $W_q$ se muestran los mapas de LISA en la figura \@ref(fig:mapas-lisa-ev-wq). Se aprecia que se forman cluster alrededor de tres zonas en el caso del porcentaje de área de espacio verde y dos para el indicador de la relación areas-distancia, coincidentes con el anterior. Ahí se encuentran equipamentos de ciudad como un cementerio de gran tamaño, las universidades, zonas conservadas de riveras de ríos. El grupo que se forma al oriente de la ciudad es donde se encuentra la laguna del Pondaje.


```{r mapas-lisa-ev-wq,fig.asp=0.618,fig.show="hold", fig.cap="Mapas LISA para la matriz $W_q$ de ambos indicadores de acceso a EV"}

pintar_mapa_su_LISA_var(regresion.EV,"area_ep.porcentaje",W_queen.ev, wname = "Wq",nrow =1)
pintar_mapa_su_LISA_var(regresion.EV,"ia.areas.dist",W_queen.ev, wname = "Wq",nrow =1)

```



##### Residuos de los OLS

Examinemos ahora los residuos  de cada modelo lineal seleccionado. Aplicamos el test de Moran primero al modelo de  `area_ep.porcentaje` con ambas matrices de vecindad. La figura \@ref(fig:moranplot-resareaep-w) muestra el mismo resultado gráficamente.

```{r code-moran-resareaep-w, echo=TRUE}
lm.morantest(lm.area_ep.ptje.sel, W_queen.ev, alternative="two.sided",zero.policy = T)
lm.morantest(lm.area_ep.ptje.sel, W_dist1000.inv.ev, alternative="two.sided",zero.policy = T)
```

```{r moranplot-resareaep-w, fig.cap="Gráfico de Moran para los residuos del modelo lineal para el porcentaje de área de espacio verde", fig.show="hold",out.width='49%'}

moran.plot(lm.area_ep.ptje.sel$residuals, 
             listw=W_queen.ev, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.EV$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wq")
moran.plot(lm.area_ep.ptje.sel$residuals, 
             listw=W_dist1000.inv.ev, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.EV$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wd") 


```

Al igual que con la variable dependiente, $W_q$ captura con mayor intensidad autocorrelación en los residuos. Los resultados de aplicar el test a `ia.areas.dist` confirman que la matriz de vecindad que usaremos para el ajuste es $W_q$.

```{r code-moran-resareasdist-w, echo=TRUE}
lm.morantest(lm.ia.areas.dist.sel, W_queen.ev, alternative="two.sided",zero.policy = T)
lm.morantest(lm.ia.areas.dist.sel, W_dist1000.inv.ev, alternative="two.sided",zero.policy = T)
```

```{r moranplot-resareasdist-w, fig.cap="Gráfico de Moran para los residuos del modelo lineal para el indicador `ia.areas.dist`", fig.show="hold",out.width='49%'}

moran.plot(lm.ia.areas.dist.sel$residuals, 
             listw=W_queen.ev, 
             
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.EV$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wq")
moran.plot(lm.ia.areas.dist.sel$residuals, 
             listw=W_dist1000.inv.ev, 
             zero.policy = TRUE,
             pch=16, col="grey50",
             cex=.5, quiet=T, 
             labels=as.character(regresion.EV$SETU_CCDGO),
             xlab="residuos", 
             ylab="residuos (Spatial Lag)", main="Gráfico de Moran Wd") 


```

Los mapas de LISA para los residuos de ambos modelos con la matriz $W_q$ se muestran a continuación. 

```{r mapas-lisa-resev-wq,fig.asp=0.618,fig.show="hold", fig.cap="Mapas LISA para la matriz $W_q$ de los residuos de los modelos lineales para los indicadores de acceso a EV"}

pintar_mapa_su_LISA_lmres(regresion.EV,lm.area_ep.ptje.sel,W_queen.ev, wname = "Wd",nrow =1)
pintar_mapa_su_LISA_lmres(regresion.EV,lm.ia.areas.dist.sel,W_queen.ev, wname = "Wd",nrow =1)

```

#### Ajuste de modelos espaciales

Probamos los 4 tipos de modelos con la matriz $W_q$ que resultó capturar mejor la asociacion espacial en los datos y comparamos sus resultados.

##### Porcentaje de espacio verde 
```{r code-laglm-areaep-wq, echo=TRUE}
#SAR

sar.areas_ep<-lagsarlm(formula = as.formula(lm.area_ep.ptje.sel),
                                    data = lm.area_ep.ptje.sel$model,
                                    listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30)

sar.sm<-summary(sar.areas_ep,Nagelkerke=T)
sar.sm

# SEM
sem.areas_ep<-errorsarlm(formula = as.formula(lm.area_ep.ptje.sel),
                           data = lm.area_ep.ptje.sel$model,
                           listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30)
sem.sm<-summary(sem.areas_ep,Nagelkerke=T)
sem.sm
#SD 

sd.areas_ep<-lagsarlm(formula = as.formula(lm.area_ep.ptje.sel),
                        data = lm.area_ep.ptje.sel$model,
                        listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30,
                        type = "mixed")
sd.sm<-summary(sd.areas_ep,Nagelkerke=T)
sd.sm

#SLX
slx.areas_ep<-lmSLX(formula = as.formula(lm.area_ep.ptje.sel),
                      data = lm.area_ep.ptje.sel$model,
                      listw = W_queen.ev, zero.policy = T)

slx.sm<-summary(slx.areas_ep)
slx.sm
AIC(slx.areas_ep)

```


```{r tabla-comp-modelos-areaep }

tabla<-fitstats_laglm_df(lm.area_ep.ptje.sel,W_queen.ev) %>% 
  rename(`OLS`=fitstats) %>%
   left_join(fitstats_laglm_df(slx.areas_ep, W_queen.ev),by= "medidasfit") %>%
  rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.areas_ep,W_queen.ev),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.areas_ep,W_queen.ev),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.areas_ep,W_queen.ev),by= "medidasfit") %>%
  rename(`SD`=fitstats)

knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de porcentaje de área de EV")


```


Al comparar los resultados de las métricas de ajuste se identifica al modelo SEM con el mejor AIC. El modelo SEM  logra eliminar la autocorrelación espacial global en los residuos, al igual que SD  (ver figura \@ref(fig:moranplot-resmodel-areaep-all-wq)). Aunque persiste la no normalidad de los residuos y la heterocedasticidad como los muestran los test y las gráficas diagnósticas, el error cometido disminuye y los coeficientes pueden considerarse más confiables. El  $\lambda$ de las estimaciones con términos autoregresivos es significativo, esto sugiere que no es necesario plantear efectos distintivos de la variables dependiente rezagada, y que es posible que ese efecto sea por otras variables no tenidas en cuenta: el agrupamiento espacial observado en la variable dependiente se explica simplemente por el patrón geográfico de variables independientes medidas y no medidas, pero no genera ningún efecto de derrame en el acceso a espacios verdes de los sectores vecinos. A pesar de que los test de normalidad y heterocedasticidad no son existosos, las gráficas diagnósticas muestran que los problemas se presentan en los valores extremos. 

```{r moranplot-resmodel-areaep-all-wq, fig.cap="Gráfico de Moran para los residuos de los modelos espaciales de porcentaje de área de EV $W_{q}$", fig.show="hold", out.width="49%"}
moran.plot(sar.areas_ep$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.EV$SETU_CCDGO),
           xlab="residuos sar", 
           ylab="residuos sar (Spatial Lag)", main="Gráfico de Moran SAR") 

moran.plot(sem.areas_ep$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.EV$SETU_CCDGO),
           xlab="residuos sem", 
           ylab="residuos sem (Spatial Lag)", main="Gráfico de Moran SEM") 

moran.plot(slx.areas_ep$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
             labels=as.character(regresion.EV$SETU_CCDGO),
           xlab="residuos slx", 
           ylab="residuos slx (Spatial Lag)", main="Gráfico de Moran SLX") 

moran.plot(sd.areas_ep$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.EV$SETU_CCDGO),
           xlab="residuos sd", 
           ylab="residuos sd (Spatial Lag)", main="Gráfico de Moran SD") 
```


```{r diag-model-areaep-espaciales, fig.asp=1.4, fig.cap="Diagnóstico comparativo entre modelos"}
diagPltsSAR<-diagPlotlaglm(sar.areas_ep)
diagPltsSEM<-diagPlotlaglm(sem.areas_ep)
diagPltsSD<-diagPlotlaglm(sd.areas_ep)
diagPltsSLX<-diagPlotlaglm(slx.areas_ep)
diagPltsOLS<-diagPlotlaglm(lm.area_ep.ptje.sel)

#diagPlotsAll<-arrangeGrob(grobs = c(diagPltsOLS,diagPltsSLX,diagPltsSD,diagPltsSEM,diagPltsSAR),ncol = 3, nrow = 5)
grid.arrange (arrangeGrob(grobs = diagPltsOLS, ncol = 3,left ="OLS"),
              arrangeGrob(grobs = diagPltsSLX, ncol = 3,left = "SLX"),
              arrangeGrob(grobs = diagPltsSAR, ncol = 3,left =  "SAR"),
              arrangeGrob(grobs = diagPltsSEM, ncol = 3,left = "SEM"),
              arrangeGrob(grobs = diagPltsSD,ncol = 3, left = "SD"),nrow =5)
```



##### Índice de acceso área-distancia 


```{r code-laglm-areasdist-wq, echo=TRUE}
#SAR

sar.areas.dist<-lagsarlm(formula = as.formula(lm.ia.areas.dist.sel),
         data = lm.ia.areas.dist.sel$model,
         listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30)

sar.sm<-summary(sar.areas.dist,Nagelkerke=T)
sar.sm

# SEM
sem.areas.dist<-errorsarlm(formula = as.formula(lm.ia.areas.dist.sel),
                                      data = lm.ia.areas.dist.sel$model,
                                      listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30)
sem.sm<-summary(sem.areas.dist,Nagelkerke=T)
sem.sm
#SD 

sd.areas.dist<-lagsarlm(formula = as.formula(lm.ia.areas.dist.sel),
                                    data = lm.ia.areas.dist.sel$model,
                                    listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30,
                                    type = "mixed")
sd.sm<-summary(sd.areas.dist,Nagelkerke=T)
sd.sm

#SLX
slx.areas.dist<-lmSLX(formula = as.formula(lm.ia.areas.dist.sel),
                           data = lm.ia.areas.dist.sel$model,
                           listw = W_queen.ev, zero.policy = T)

slx.sm<-summary(slx.areas.dist)
slx.sm
AIC(slx.areas.dist)

```


```{r tabla-comp-modelos-areasdist }

tabla<-fitstats_laglm_df(lm.ia.areas.dist.sel,W_queen.ev) %>% 
  rename(`OLS`=fitstats) %>%
   left_join(fitstats_laglm_df(slx.areas.dist, W_queen.ev),by= "medidasfit") %>%
  rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.areas.dist,W_queen.ev),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.areas.dist,W_queen.ev),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.areas.dist,W_queen.ev),by= "medidasfit") %>%
  rename(`SD`=fitstats)

knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de áreas-distancia de EV")


```


Al comparar los resultados de las métricas de ajuste se identifica al modelo SD con el mejor AIC. El modelo SD  logra eliminar la autocorrelación espacial global en los residuos al exhibir un valor de significancia mucho mayor que 0.05, al igual que SEM y SAR (ver figura \@ref(fig:moranplot-resmodel-areasdist-all-wq)). Aunque persiste la no normalidad de los residuos y la heterocedasticidad como los muestran los test y las gráficas diagnósticas, el error cometido disminuye y los coeficientes pueden considerarse más confiables. El $\rho$ de las estimaciones con términos autoregresivos es significativo, esto sugiere que una parte de los efectos de derrame de las varibles significativas (`lag.area_media_manzana`, `unidad_economica.porcentaje`) en el acceso a espacios verdes de los sectores vecinos explica bien los grupos que se forman. Es posible que estar cerca de un sector con manzanas grandes y que tal vez sus parque pueden ser mas grandes explica la influencia positiva en el acceso p.e. de tener equipamentos de ciudad grandes en algun sector aledaño. En el modelo SD una parte de la mejora en el ajuste puede puede provenir de dimensiones no modeladas. Los test de normalidad y heterocedasticidad no son existosos, las gráficas diagnósticas muestran que los problemas se presentan en los valores extremos. 

```{r moranplot-resmodel-areasdist-all-wq, fig.cap="Gráfico de Moran para los residuos de los modelos espaciales de acceso área-distancia $W_{q}$", fig.show="hold", out.width="49%"}
moran.plot(sar.areas.dist$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sar", 
           ylab="residuos sar (Spatial Lag)", main="Gráfico de Moran SAR") 

moran.plot(sem.areas.dist$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sem", 
           ylab="residuos sem (Spatial Lag)", main="Gráfico de Moran SEM") 

moran.plot(slx.areas.dist$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos slx", 
           ylab="residuos slx (Spatial Lag)", main="Gráfico de Moran SLX") 

moran.plot(sd.areas.dist$residuals, 
           listw=W_queen.ev, 
           zero.policy = TRUE,
           pch=16, col="black",
           cex=.5, quiet=T, 
           labels=as.character(regresion.arboles$SETU_CCDGO),
           xlab="residuos sd", 
           ylab="residuos sd (Spatial Lag)", main="Gráfico de Moran SD") 
```


```{r diag-model-areasdist-espaciales, fig.asp=1.4, fig.cap="Diagnóstico comparativo entre modelos"}
diagPltsSAR<-diagPlotlaglm(sar.areas.dist)
diagPltsSEM<-diagPlotlaglm(sem.areas.dist)
diagPltsSD<-diagPlotlaglm(sd.areas.dist)
diagPltsSLX<-diagPlotlaglm(slx.areas.dist)
diagPltsOLS<-diagPlotlaglm(lm.ia.areas.dist.sel)

#diagPlotsAll<-arrangeGrob(grobs = c(diagPltsOLS,diagPltsSLX,diagPltsSD,diagPltsSEM,diagPltsSAR),ncol = 3, nrow = 5)
grid.arrange (arrangeGrob(grobs = diagPltsOLS, ncol = 3,left ="OLS"),
              arrangeGrob(grobs = diagPltsSLX, ncol = 3,left = "SLX"),
              arrangeGrob(grobs = diagPltsSAR, ncol = 3,left =  "SAR"),
              arrangeGrob(grobs = diagPltsSEM, ncol = 3,left = "SEM"),
              arrangeGrob(grobs = diagPltsSD,ncol = 3, left = "SD"),nrow =5)
```



