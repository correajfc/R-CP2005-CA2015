# Resultados {#results}

## Modelando la cobertura de copa

### Variables dependientes

El proceso de selección de las variables a incluir en los modelos inicia con la inspección visual de las distribuciones bivariadas de las candidatas a predictores. Se busca identificar las variables correlacianadas entre sí para evitar incluir información redundante en los modelos. En la figura \@ref(fig:bivar-poblacion-abs) se explora las relaciones entre las variables de población (número de personas en un SU con una condición específica). La matriz triangular superior muestra los coeficientes de correlación de Pearson, la diagonal contiene el histogram de frecuencias de la variable y la matriz triangular inferior muestra un gráfico de dispersión y la línea de tendencia usando un modelo lineal entre cada par de variables. Es notoria la alta correlación entre población con ningún estudio y tener alguna limitación física ($\simeq 0.88$);  pertenecer a una comunidad afrodescendiente y carecer de estudios ($\simeq0.92$) o ser afrodescendiente y tener alguna limitación ($\simeq0.88$). Esto representa una suma de condiciones desfavorables relacionadas entre sí, que desde el punto de vista del modelo sólo podrán ser representadas por la variable que mejor se relacione con la cobertura de copa y evitar así colinealidad entre los predictores.



```{r bivar-poblacion-abs, fig.asp=1, fig.cap="Comparación por pares entre predictores de población"}
ggpairs(
  regresion.arboles[,indep.poblacion.abs], lower = list(continuous = wrap_fn_with_params(lowerFn, method = "lm")),
  diag = list(continuous = GGally:: wrap_fn_with_params("barDiag", colour = "white",fill ="steelblue")),
  upper = list(continuous = wrap_fn_with_params("cor", size = 4)),
  title = "Comparación por pares entre predictores de población"
)+ theme_grey(base_size = 8)+
  theme(strip.text = element_text(size = 7))

```

Las mismas variables expresadas como porcentaje de la población de un SU muestran patrones similares (ver figura \@ref(fig:bivar-poblacion-mod)): existe una alta correlación negativa entre el porcentaje de población afro de un sector y la tenencia de estudios superiores ($\simeq-0.71$), una fuerte asociación positiva entre el porcentaje de personas afro de un sector y el porcentaje de personas que carecen de estudios ($\simeq 0.68$). También hay una fuerte relación inversa entre el porcentaje de personas de un sector sin estudios y el porcentaje de ellos que tiene estudios superiores ($\simeq-0.8$). Estos resultados refuerzan la concentración de condiciones desfavorables para la población explicadas por la condición racial.

```{r bivar-poblacion-mod, fig.asp=1, fig.cap="Comparación por pares entre predictores de población porcentuales"}
ggpairs(
  regresion.arboles[,indep.poblacion.percent], lower = list(continuous = wrap_fn_with_params(lowerFn, method = "lm")),
  diag = list(continuous = wrap_fn_with_params("barDiag", colour = "white",fill ="steelblue")),
  upper = list(continuous = wrap_fn_with_params("cor", size = 4)),
  title = "Comparación por pares entre predictores de población porcentuales y la densidad de población"
)+ theme_grey(base_size = 8)+
  theme(strip.text = element_text(size = 6))

```

Los gráficos de azulejos son una forma resumida para consultar la intensidad de estas relaciones (figura \@ref(fig:tile-poblacion-pearson)) lineales entre las variables dependientes usando el coeficiente de correlación de Pearson, y las no lineales mediante el coeficiente de Spearman (figura \@ref(fig:tile-poblacion-spearman)).

```{r tile-poblacion-pearson, fig.asp=1,fig.cap="Coeficiente Pearson entre variables de población"} 
pintar_corrmatrix(regresion.arboles,indep.poblacion)+
  labs(title="Coeficiente Pearson \nentre variables de población")

```

```{r tile-poblacion-spearman, fig.asp=1,fig.cap="Coeficiente Spearman entre varibles de población"}
pintar_corrmatrix(regresion.arboles,indep.poblacion, method_cor = "spearman")+
  labs(title="Coeficiente Spearman \nentre variables de población")

```

Con base en los coeficientes de correlación de Pearson (figura \@ref(fig:tile-copa-poblacion-pearson)) y Spearman (figura \@ref(fig:tile-copa-poblacion-spearman)) entre las variables dependientes e independientes, y teniendo en cuenta las restricciones de colinealidad entre las variables dependientes, se seleccionaron las siguientes variables para los modelos lineales:

- Para el área de copa (`area_copa`) los predictores seleccionados son`` `r str_c(indep.poblacion.copa.sel, collapse = ", ") ` ``. 

- Para la cobertura de copa (`cobertura_copa.ap`) los predictores seleccionados son`` `r str_c(indep.poblacion.copa.ap.sel, collapse = ", ") ` `` 


```{r tile-copa-poblacion-pearson, fig.asp=0.6,fig.cap="Coeficiente Pearson entre cobertura de copa\n y variables de población"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.poblacion, y=dependientes.arboles)+
  labs(title="Pearson entre cobertura de copa \ny variables de población")

```

```{r tile-copa-poblacion-spearman, fig.asp=0.6,fig.cap="Coeficiente Spearman entre cobertura de copa\n y variables de población"}
pintar_corrmatrix_XY(regresion.arboles,x=indep.poblacion, y=dependientes.arboles, method_cor = "spearman")+
  labs(title="Spearman entre cobertura de copa \ny variables de población")
```


Para la selección de variables sobre uso de los predios, los tipos de vivienda y área de espacio público se aplicó el mismo proceso. Para el área de copa se seleccionaron el área de espacios verdes (`area_ep`) y el porcentaje de viviendas tipo cuarto (`cuarto.porcentaje`). Para el modelo de porcentaje de cobertura de se seleccionan `apartamento.porcentaje`, `cuarto.porcentaje` y `area_ep.porcentaje`.


### Modelos de regresión lineal AU

Antes de evaluar los modelos se aplicaron varias transformaciones en busca de normalizar las distribuciones de las variables dependientes. Las que mejor resultado arrojaron en la formulación de los modelos fueron la transformación logarítmica para el caso del área de copa y la variable sin transformar en el caso de la cobertura de copa.

La tabla \@ref(tab:coef-lm-copa) resume los coeficientes de la regresión para el área de copa, la tabla \@ref(tab:coef-lm-cobertura) resume los coeficientes de la regresión para la cobertura de copa, y la tabla \@ref(tab:ajuste-lmcopa-pob-predios) resume las métricas de ajuste de ambos modelos.

Los resultados de los test Shapiro-Wilk indican no normalidad en los residuos en ambos modelos, heterocedasticidad como muestra el test Breusch-Pagan y posibles no linealidades como se observa en las gráficas diagnósticas de la regresión de ambos modelos( ver gráficos \@ref(fig:diagn-mod-best-lm-copa) y \@ref(fig:diagn-mod-best-lm-copaap)). 

Sin embargo, el ajuste de ambos modelos tiene media de los residuos muy cercanas a 0, al igual que el error cuadrático medio (MSE). En el caso de la área de copa se obtiene un *adjR-square* de `r summary(lm.mod.area_copa) %>% broom::glance() %>% .$adj.r.squared %>% scales::percent()`, que es aceptable. Las variables significativas para el área de copa son  `r c(indep.poblacion.copa.sel,indep.predios.copa.sel)[c(1,2,5,6)] %>% backtick()`. Los resultados confirman que al nivel de toda el área de estudio, las condiciones de acceso a la educación de la población, la densidad de población, el tipo de vivienda y la disponibilidad de EV se correlaciona con el acceso a servicios ambientales del AU.

Para la cobertura de copa la única variable significativa es `r indep.poblacion.copa.ap.sel[1] %>% backtick()`. Este único indicador porcentual, que hace una descripción local y comparable entre los SU, explica el `r summary(lm.mod.cobertura.ap) %>% broom::glance() %>% .$adj.r.squared %>% scales::percent()` de la variabilidad de los datos, reforzando la importancia del indicador de acceso a educación superior como predictor del acceso a servicios ambientales del AU.

Para la siguientes fases se ingnoraron las variables no significativas de los modelos lineales. 



```{r code-lm-areacopa, eval=TRUE, echo=FALSE, results='hide'}
dependiente <- "log.area_copa"
independientes  <- c(indep.poblacion.copa.sel,indep.predios.copa.sel)
# max normalizado 
var_names<-c(dependiente,names(regresion.arboles[,independientes]))
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
f <- paste(str_c(dependiente,".mxn"),
           "~", paste(str_c(independientes,".mxn"), 
                      collapse=" + "))
lm.area_copa<-lm(f, 
                     data = regresion.arboles.mn)
sm<-summary(lm.mod.area_copa)
sm

```

```{r coef-lm-copa}
nombres_coef <- summary(lm.area_copa)$coefficients %>% row.names() %>% str_remove_all(".mxn") %>% str_replace_all("[\\._]"," ") %>% str_replace("\\(Intercept\\)","Intercepto")
t1<-summary(lm.area_copa)$coefficients %>% as_data_frame()
t1 %>% bind_cols(terminos = nombres_coef,.) %>% 
knitr::kable( digits=3, caption = "Coeficientes OLS de área de copa - Log(AC)" , booktabs = TRUE, col.names = c("Término","Estimado","Error std.","t-valor","Pr(>|t|)"))

```




```{r code-lm-cobertura, eval=TRUE, echo=FALSE, results= "hide"}
# coberbtura AP
dependiente <- "cobertura_copa.ap"
independientes  <- c(indep.poblacion.copa.ap.sel,
                     indep.predios.copa.ap.sel)
# max normalizado 
var_names<-c(dependiente,independientes)
regresion.arboles.mn<-max_nomalization(regresion.arboles,var_names)
f <- paste(str_c(dependiente,".mxn"),
           "~", paste(str_c(independientes,".mxn"), 
                      collapse=" + "))
lm.mod.cobertura.ap<-lm(f, 
                        data = regresion.arboles.mn)
sm<-summary(lm.mod.cobertura.ap)
sm

```

```{r coef-lm-cobertura}

nombres_coef <- summary(lm.mod.cobertura.ap)$coefficients %>% row.names() %>% str_remove_all(".mxn") %>% str_replace_all("[\\._]"," ") %>% str_replace("\\(Intercept\\)","Intercepto")
t1<-summary(lm.mod.cobertura.ap)$coefficients %>% as_data_frame()
t1 %>% bind_cols(terminos = nombres_coef,.) %>% 
knitr::kable( digits=5, caption = "Coeficientes OLS de cobertura de copa - (CC)" , booktabs = TRUE, col.names = c("Término","Estimado","Error std.","t-valor","Pr(>|t|)"))

```




```{r ajuste-lmcopa-pob-predios}
tabla<-fitstats_lm_df(lm.area_copa) %>% 
  rename(`Log(AC)`=fitstats) %>%
   left_join(fitstats_lm_df(lm.mod.cobertura.ap),by= "medidasfit") %>%
  rename( `%CC`=fitstats)
kable(tabla,caption = "Resumen métricas de ajuste OLS para el área de copa (AC) y cobertura de copa (CC) ", digits = 5)


```





```{r diagn-mod-best-lm-copa, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de área de copa"}

graf<-autoplot(lm.area_copa, which = 1:4)
# nuevos textos
yLabs <- c("Residuos","Residuos estandarizados",TeX("$\\sqrt{|Residuos estandarizados|}$"),"Distancia de Cook") 
xLabs <- c("Valores ajustados", "Cuantiles teóricos", "Valores ajustados", "Índice de la observación")
titulos <- c("Residuos vs Valores Ajustados","Gráfico Q-Q","Gráfico Escala-Locacion","Distancia de Cook")
# modifcar grafico indivudualmente
for (i in 1:4)
  graf[i] <- graf[i] + xlab(xLabs[i]) + ylab(yLabs[i])+ggtitle(titulos[i])+theme_minimal(base_size = 9)

# desplegar grafico
title1=grid::textGrob(format(as.formula(lm.area_copa)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)

```


```{r diagn-mod-best-lm-copaap, fig.cap="Gráficas diagnósticas para el análisis de regresión lineal de porcentaje de cobertura de copa"}

graf<-autoplot(lm.mod.cobertura.ap, which = 1:4)
# nuevos textos
yLabs <- c("Residuos","Residuos estandarizados",TeX("$\\sqrt{|Residuos estandarizados|}$"),"Distancia de Cook") 
xLabs <- c("Valores ajustados", "Cuantiles teóricos", "Valores ajustados", "Índice de la observación")
titulos <- c("Residuos vs Valores Ajustados","Gráfico Q-Q","Gráfico Escala-Locacion","Distancia de Cook")
# modifcar grafico indivudualmente
for (i in 1:4)
  graf[i] <- graf[i] + xlab(xLabs[i]) + ylab(yLabs[i])+ggtitle(titulos[i])+theme_minimal(base_size = 9)

# desplegar grafico
title1=grid::textGrob(format(as.formula(lm.mod.cobertura.ap)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)
```


### Modelado espacial AU

Las matrices de vecindad construidas para el análisis espacial son la *queen* $W_q$, que considera vecino a todos los sectores que comparten un lado o una esquina con un SU; y una matriz de distancia inversas entre los centroides de los SU, restringiendo la vecindad a aquellos centroides que están a menos de 1 km ($W_d$). El valor de un kilómetro es arbitrario, aunque razonable en la escala humana. Los grafos que representan las 2 matrices $W$ se muestran en la figura \@ref(fig:ws-su-reg). 

```{r ws-su-reg, fig.asp=1.5 ,out.width='48%' ,fig.cap="Matrices de vecindad del análisis espacial",fig.align="center",fig.show="hold"}
plot(W_queen,coords=coordinates(su.arboles),pch=19, cex=0.1, col="gray", main="Queen")
title(main = "Queen")
plot(W_dist1000.inv,coords=coordinates(su.arboles),pch=19, cex=0.1, col="gray", main="Distancia inversa a 1 Km")
title(main = "Distancia inversa a 1 Km")
```


####  Autocorrelación variables dependientes

Se analizó la autocorrelacieon de las variables dependientes para encontrar agrupaciones existentes en los datos que pueden ser explicados por la estructura de vecindad. Los resultados de los test de Moran I para ambas variables dependientes muestran que existen patrones de agrupamiento y que puede rechazarse la hipótesis nula de que los procesos espaciales subyacentes son aleatorios (ver tablas \@ref(tab:moran-copa-w) y \@ref(tab:moran-copaap-w)). 

Ambos diseños de matriz revelan presencia clara de autocorrelación espacial. La matrix $W_q$ captura mejor la autocorrelación del área de copa. En el caso de la cobertura de copa la matriz $W_d$ presenta un valor ligeramente mayor de autocorrelación. 

Los mapas LISA muestran los grupos de sectores que configuran la autocorrelación del área de copa usando la matriz para $W_q$ (figura \@ref(fig:mapas-lisa-copa-wq)) y los grupos de la variable cobertura de copa usando la matriz $W_d$ (figura \@ref(fig:mapas-lisa-copaap-wd)). 

Los grupos que se forman muestran patrones distintos en los dos indicadores seleccionados para caraterizar los beneficios del arbolado urbano. Sin embargo, existen SU comunes en los grupos conformados pero con diferencias en la extensión de los conglomerados identificados. Esto se debe a que cada uno de los indicadores expresa un concepto distinto del disfrute de ese beneficio: el área de copa muestra las diferencias desde una perspetiva global, es decir, con base en el valor absoluto de área de copa de un SU en relación al total de area disponible en toda la ciudad. El indicador de cobertura de copa expresa el beneficio de forma relativa entre los SU al dividir el área de copa disponible en un SU entre el área pública de ese SU. 

Es clara la similitud entre los grupos obtenidos para una misma variable dependendiente con ambos diseños de matriz $W$ (figura \@ref(fig:mapas-lisa-copa-wq) y figura \@ref(fig:mapas-lisa-copa-wd) para el área de copa y \@ref(fig:mapas-lisa-copaap-wq) y \@ref(fig:mapas-lisa-copaap-wd) para la cobertura de copa), posiblemente porque no existen diferencias notables entre los dos tipos de estructura de vecindad propuestas (figura \@ref(fig:ws-su-reg)). 

Lo relevante en los resultados de los análisis con ambos diseños de matriz es que la vecindad de los SU exhibe un grado de autocorrelación espacial y por lo tanto los grupos de alta y baja prestación en los servicios ecosistémicos del AU configuran evidencia de los sesgos espaciales en la distribución de dichos beneficios, rechanzado la hipotesis nula de distribucion espacial aleatoria o uniforme.




```{r moran-copa-w}
mt<-moran.test(lm.best.area_copa$model$log.area_copa.mxn, listw=W_queen) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

mt2<-moran.test(lm.best.area_copa$model$log.area_copa.mxn, listw=W_dist1000.inv, zero.policy = TRUE) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Área de copa para $W_q$ y $W_d$" , booktabs = TRUE)

```



```{r moran-copaap-w}
mt<-moran.test(lm.best.cobertura.ap$model$cobertura_copa.ap.mxn, listw=W_queen) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

mt2<-moran.test(lm.best.cobertura.ap$model$cobertura_copa.ap.mxn, listw=W_dist1000.inv, zero.policy = TRUE) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Porcentaje de cobertura de copa para $W_q$ y $W_d$" , booktabs = TRUE)

```



```{r mapas-lisa-copa-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de `log.area copa`"}

pintar_mapa_su_LISA_var(regresion.arboles,"log.area_copa",W_queen, wname = "Wq",nrow =1)

```

```{r mapas-lisa-copa-wd,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_d$ de `log.area copa`"}

pintar_mapa_su_LISA_var(regresion.arboles,"log.area_copa",W_dist1000.inv, wname = "Wd",nrow =1)

```

```{r mapas-lisa-copaap-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de `cobertura copa.ap`"}

pintar_mapa_su_LISA_var(regresion.arboles,"cobertura_copa.ap",W_queen, wname = "Wq",nrow =1)

```

```{r mapas-lisa-copaap-wd,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_d$ de `cobertura copa.ap`"}

pintar_mapa_su_LISA_var(regresion.arboles,"cobertura_copa.ap",W_dist1000.inv, wname = "Wd",nrow =1)

```


#### Autocorrelación residuos de los OLS

Para evaluar la utlidad de aplicar modelos espaciales de regresión se examinó la existencia de autocorrelación en los residuos de los modelos de regresión lineal. Se comparó si alguno de las estructuras de vecindad produce resultados significativamente mejores en la deteción de autocorrelación espacial.  

La tabla \@ref(tab:moran-rescopa-w) muestra ambos diseños de matriz $W$ presentan un valor de Moran Global mayor que 0 y significativo para los residuos del OLS de área de copa, al igual que para los residuos del OLS del porcentaje de cobertura (ver \@ref(tab:moran-rescopaap-w)).  

En ambos modelos el resultado de autocorrelación espacial suguiere que al introducir retardos espaciales y la estrucutura de vecidad pueden mejorar la estimación de los coeficientes de la regresión y las métricas de desempeño del ajuste.



```{r moran-rescopa-w}
mt<-moran.test(lm.best.area_copa$residuals, listw=W_queen) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

mt2<-moran.test(lm.best.area_copa$residuals, listw=W_dist1000.inv, zero.policy = TRUE) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Residuos de OLS Área de copa para $W_q$ y $W_d$" , booktabs = TRUE)

```



```{r moran-rescopaap-w}
mt<-moran.test(lm.best.cobertura.ap$residuals, listw=W_queen) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

mt2<-moran.test(lm.best.cobertura.ap$residuals, listw=W_dist1000.inv, zero.policy = TRUE) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Residuos de OLS Porcentaje de cobertura de copa para $W_q$ y $W_d$" , booktabs = TRUE)

```



#### Modelo espacial área de copa 

Las métricas de ajuste de los modelos con las matrices de vecindad $W_d$ (ver tabla \@ref(tab:tabla-comp-modelos-copa-wd)) y $W_q$ (tabla \@ref(tab:tabla-comp-modelos-copa-wq)) para el área de copa muestran que los modelos espaciales logran eliminar la autocorrelación espacial global en los residuos. Es importante anotar que la heterocedasticidad reportada en la tabla \@ref(tab:ajuste-lmcopa-pob-predios) del modelo OLS desaparece al descartar la variables independientes con $p$-valores no significativos, por lo que no se le puede adjudicar al uso de los terminos espaciales. Todos los modelos mejoran las métricas de error respecto del OLS y ninguno logra la normalidad en los residuos, aunque en las gráficas diagnósticas se aprecia una semblanza aceptable (ver figura \@ref(fig:diag-model-espaciales)) con problemas en valores extremos.   

Al comparar los resultados usando el desempeño en AIC, el mejor fue el SEM con la matriz $W_d$, seguido del SD con $W_q$, con leves diferencias entre las métricas. En cuanto a $\lambda$ (tabla \@ref(tab:cauto-sem-copa)) y $\rho$ (tabla \@ref(tab:cauto-sd-copa-wq)) , los términos autorregresivos, son significativos para SEM $W_d$ y para SD con $W_q$ repectivamente. 

El resultado del modelo SEM confirma la significancia de las variables de cantidad personas con estudios superiores y porcentaje de espacio verde con coeficientes de valores positivos, en ese orden de importancia. La densidad de población y la presencia de viviendas tipo cuarto, con coeficientes negativos, son factores que disminuyen la disponibilidad de área de copa en un SU (ver tabla \@ref(tab:coef-sem-copa-wd)). Existen cambios y ajustes en los valores de los coeficientes con relación al modelo OLS, que dadas las mejoras en las métricas de ajuste hacen más confiables las estimaciones. 

 





```{r code-laglm-copa-wq, echo=FALSE, results="hide"}
#SAR

sar.mod.log.area_copa.wq<-lagsarlm(formula = as.formula(lm.best.area_copa),
         data = lm.best.area_copa$model,
         listw = W_queen, 
         zero.policy = T,
         tol.solve=1.0e-30)
sar.sm<-summary(sar.mod.log.area_copa.wq,
                Nagelkerke=T)
sar.sm

# SEM
sem.mod.log.area_copa.wq<-errorsarlm(formula = as.formula(lm.best.area_copa),
                                      data = lm.best.area_copa$model,
                                      listw = W_queen, 
                                     zero.policy = T,tol.solve=1.0e-30)
sem.sm<-summary(sem.mod.log.area_copa.wq,Nagelkerke=T)
sem.sm
#SD 

sd.mod.log.area_copa.wq<-lagsarlm(formula = as.formula(lm.best.area_copa),
         data = lm.best.area_copa$model,
         listw = W_queen, 
         zero.policy = T,
         tol.solve=1.0e-30,
         type = "mixed")
sd.sm<-summary(sd.mod.log.area_copa.wq,
               Nagelkerke=T)
sd.sm

# #SLX
# slx.mod.log.area_copa.wq<-lmSLX(formula = as.formula(lm.best.area_copa),
#                            data = lm.best.area_copa$model,
#                            listw = W_queen, 
#                            zero.policy = T)
# 
# slx.sm<-summary(slx.mod.log.area_copa.wq)
# slx.sm
# AIC(slx.mod.log.area_copa.wq)

```


```{r code-laglm-copa-wd, echo=FALSE, results="hide"}
#SAR

sar.mod.log.area_copa.wd<-lagsarlm(formula = as.formula(lm.best.area_copa),
         data = lm.best.area_copa$model,
         listw = W_dist1000.inv, 
         zero.policy = T,
         tol.solve=1.0e-30)
sar.sm<-summary(sar.mod.log.area_copa.wd,
                Nagelkerke=T)
sar.sm

# SEM
sem.mod.log.area_copa.wd<-errorsarlm(formula = as.formula(lm.best.area_copa),
                                      data = lm.best.area_copa$model,
                                      listw = W_dist1000.inv, 
                                     zero.policy = T,tol.solve=1.0e-30)
sem.sm<-summary(sem.mod.log.area_copa.wd,Nagelkerke=T)
sem.sm
#SD 

sd.mod.log.area_copa.wd<-lagsarlm(formula = as.formula(lm.best.area_copa),
         data = lm.best.area_copa$model,
         listw = W_dist1000.inv, 
         zero.policy = T,
         tol.solve=1.0e-30,
         type = "mixed")
sd.sm<-summary(sd.mod.log.area_copa.wd,
               Nagelkerke=T)
sd.sm

# #SLX
# slx.mod.log.area_copa.wq<-lmSLX(formula = as.formula(lm.best.area_copa),
#                            data = lm.best.area_copa$model,
#                            listw = W_queen, 
#                            zero.policy = T)
# 
# slx.sm<-summary(slx.mod.log.area_copa.wq)
# slx.sm
# AIC(slx.mod.log.area_copa.wq)

```



```{r tabla-comp-modelos-copa-wq }

tabla<-fitstats_laglm_df(lm.best.area_copa,W_queen) %>% 
  rename(`OLS`=fitstats) %>%
  #  left_join(fitstats_laglm_df(slx.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  # rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.mod.log.area_copa.wq,W_queen),by= "medidasfit") %>%
  rename(`SD`=fitstats)

knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de área de copa $W_q$")


```



```{r tabla-comp-modelos-copa-wd }

tabla<-fitstats_laglm_df(lm.best.area_copa,W_dist1000.inv) %>% 
  rename(`OLS`=fitstats) %>%
  #  left_join(fitstats_laglm_df(slx.mod.log.area_copa.wd.inv,W_dist1000.inv),by= "medidasfit") %>%
  # rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.mod.log.area_copa.wd,W_dist1000.inv),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.mod.log.area_copa.wd,W_dist1000.inv),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.mod.log.area_copa.wd,W_dist1000.inv),by= "medidasfit") %>%
  rename(`SD`=fitstats)

knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de área de copa con $W_d$")


```




```{r diag-model-espaciales, fig.asp=1, fig.cap="Diagnóstico comparativo entre modelos modelos espaciales de área de copa"}

diagPltsSEM<-diagPlotlaglm(sem.mod.log.area_copa.wd)
diagPltsSD<-diagPlotlaglm(sd.mod.log.area_copa.wq)
# diagPltsSLX<-diagPlotlaglm(slx.mod.log.area_copa.wq)
diagPltsOLS<-diagPlotlaglm(lm.best.area_copa)

#diagPlotsAll<-arrangeGrob(grobs = c(diagPltsOLS,diagPltsSLX,diagPltsSD,diagPltsSEM,diagPltsSAR),ncol = 3, nrow = 5)
grid.arrange (arrangeGrob(grobs = diagPltsOLS, ncol = 3,left ="OLS"),
              # arrangeGrob(grobs = diagPltsSLX, ncol = 3,left = "SLX"),
              # arrangeGrob(grobs = diagPltsSAR, ncol = 3,left =  "SAR"),
              arrangeGrob(grobs = diagPltsSEM, ncol = 3,left = "SEM Wd"),
              arrangeGrob(grobs = diagPltsSD,ncol = 3, left = "SD Wq"),nrow =3)
```


```{r coef-sem-copa-wd}
t1<-summary(sem.mod.log.area_copa.wd)$Coef
knitr::kable(t1, digits=3,caption = 'Coeficientes del modelo SEM de área de copa $W_d$', booktabs = TRUE)
```

```{r cauto-sem-copa}
sm<-summary(sem.mod.log.area_copa.wd)
r1<-round(c(sm$lambda,sm$LR1$statistic,sm$LR1$p.value),digits = 3)
r1<-unname(r1)
t2<-rbind(c("$\\lambda$","Likelihood ratio","p-value"),
          r1)
knitr::kable(unname(t2), digits=3,caption = 'Coeficiente de autocorrelación modelo SEM de área de copa $W_d$', booktabs = TRUE)
```


```{r coef-sd-copa-wq}
t1<-summary(sd.mod.log.area_copa.wq)$Coef
knitr::kable(t1, digits=3,caption = 'Coeficientes del modelo SD de área de copa $W_q$', booktabs = TRUE)
```

```{r cauto-sd-copa-wq}
sm<-summary(sd.mod.log.area_copa.wq)
r1<-round(c(sm$rho,sm$LR1$statistic,sm$LR1$p.value),digits = 3)
r1<-unname(r1)
t2<-rbind(c("$\\rho$","Likelihood ratio","p-value"),
          r1)
knitr::kable(unname(t2), digits=3,caption = 'Coeficiente de autocorrelación modelo SD de área de copa $W_q$', booktabs = TRUE)
```

#### Modelo espacial porcentaje de cobertura de área de copa 


```{r code-laglm-copaap-wq, echo=FALSE, results= "hide"}
#SAR

sar.cobertura.ap.wq<-lagsarlm(formula = as.formula(lm.best.cobertura.ap),
         data = lm.best.cobertura.ap$model,
         listw = W_queen, 
         zero.policy = T,
         tol.solve=1.0e-30)
sar.sm<-summary(sar.cobertura.ap.wq,Nagelkerke=T)
sar.sm

# SEM
sem.cobertura.ap.wq<-errorsarlm(formula = as.formula(lm.best.cobertura.ap),
                                      data = lm.best.cobertura.ap$model,
                                      listw = W_queen,
                                zero.policy = T,
                                tol.solve=1.0e-30)
sem.sm<-summary(sem.cobertura.ap.wq,
                Nagelkerke=T)
sem.sm
#SD 

sd.cobertura.ap.wq<-lagsarlm(formula = as.formula(lm.best.cobertura.ap),
         data = lm.best.cobertura.ap$model,
         listw = W_queen, zero.policy = T,
         tol.solve=1.0e-30,
         type = "mixed")
sd.sm<-summary(sd.cobertura.ap.wq,Nagelkerke=T)
sd.sm

#SLX
slx.cobertura.ap.wq<-lmSLX(formula = as.formula(lm.best.cobertura.ap),
                           data = lm.best.cobertura.ap$model,
                           listw = W_queen, 
                           zero.policy = T)

slx.sm<-summary(slx.cobertura.ap.wq)
slx.sm
AIC(slx.cobertura.ap.wq)

```

```{r code-laglm-copaap-wd, echo=FALSE, results= "hide"}
#SAR

sar.cobertura.ap.wd<-lagsarlm(formula = as.formula(lm.best.cobertura.ap),
         data = lm.best.cobertura.ap$model,
         listw = W_dist1000.inv, 
         zero.policy = T,
         tol.solve=1.0e-30)
sar.sm<-summary(sar.cobertura.ap.wd,Nagelkerke=T)
sar.sm

# SEM
sem.cobertura.ap.wd<-errorsarlm(formula = as.formula(lm.best.cobertura.ap),
                                      data = lm.best.cobertura.ap$model,
                                      listw = W_dist1000.inv,
                                zero.policy = T,
                                tol.solve=1.0e-30)
sem.sm<-summary(sem.cobertura.ap.wd,
                Nagelkerke=T)
sem.sm
#SD 

sd.cobertura.ap.wd<-lagsarlm(formula = as.formula(lm.best.cobertura.ap),
         data = lm.best.cobertura.ap$model,
         listw = W_dist1000.inv, zero.policy = T,
         tol.solve=1.0e-30,
         type = "mixed")
sd.sm<-summary(sd.cobertura.ap.wd,Nagelkerke=T)
sd.sm

# #SLX
# slx.cobertura.ap.wd<-lmSLX(formula = as.formula(lm.best.cobertura.ap),
#                            data = lm.best.cobertura.ap$model,
#                            listw = W_queen, 
#                            zero.policy = T)
# 
# slx.sm<-summary(slx.cobertura.ap.wd)
# slx.sm
# AIC(slx.cobertura.ap.wd)

```


Las métricas de ajuste de los modelos con las matrices de vecindad $W_d$ (ver tabla \@ref(tab:tabla-comp-modelos-copaap-wd)) y $W_q$ (tabla \@ref(tab:tabla-comp-modelos-copaap-wq)) para el porcentaje de cobertura de copa muestran que los modelos espaciales logran eliminar la autocorrelación espacial global en los residuos, excepto el SAR con $W_d$. Todos los modelos mejoran las métricas de error respecto del OLS y ninguno logra la normalidad en los residuos ni eliminar la heterocedasticidad como se aprecia en las gráficas diagnósticas (ver figura \@ref(fig:diag-model-espaciales-copaap)).   

Al comparar los resultados usando el desempeño en AIC, el mejor fue el SD con la matriz $W_d$.  $\rho$, el término autorregresivo, es de un valor alto y muy significativo para el modelo SD con $W_d$ (tabla \@ref(tab:cauto-sd-copaap-wd)). 

El resultado del modelo SD confirma la significancia de la única variable independiente: porcentaje de personas con estudios superiores, con coeficiente positivo, identificándolo como un factores relacionado con alta proporción de área de copa en un SU (ver tabla \@ref(tab:coef-sd-copaap)). Existen una reducción del valor del coeficiente con relación al modelo OLS.

La variable de **estudios superiores** en la población refleja el patrón de agrupamiento espacial de la cobertura de copa pero es poco significativa como variable retardada, cuestión que pone dudas sobre si el SD proponga una interpretación acertada o diferente de un modelo autoregresivo puro (SAR).


```{r tabla-comp-modelos-copaap-wq  }

tabla<-fitstats_laglm_df(lm.best.cobertura.ap,W_queen) %>% 
  rename(`OLS`=fitstats) %>%
  #  left_join(fitstats_laglm_df(slx.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  # rename(`SLX`=fitstats) %>%
    left_join(fitstats_laglm_df(sar.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.cobertura.ap.wq,W_queen),by= "medidasfit") %>%
  rename(`SD`=fitstats)
knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de porcentaje de área de copa $W_q$")


```

```{r tabla-comp-modelos-copaap-wd  }

tabla<-fitstats_laglm_df(lm.best.cobertura.ap,W_dist1000.inv) %>% 
  rename(`OLS`=fitstats) %>%
   # left_join(fitstats_laglm_df(slx.cobertura.ap.wd,W_dist1000.inv),by= "medidasfit") %>%
  # rename(`SLX`=fitstats) %>%
    left_join(fitstats_laglm_df(sar.cobertura.ap.wq,W_dist1000.inv),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.cobertura.ap.wd,W_dist1000.inv),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.cobertura.ap.wd,W_dist1000.inv),by= "medidasfit") %>%
  rename(`SD`=fitstats)
knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de porcentaje de área de copa $W_d$")


```





```{r diag-model-espaciales-copaap, fig.asp=0.67, fig.cap="Diagnóstico comparativo entre modelos de porcentaje de copa"}
# diagPltsSAR.wq<-diagPlotlaglm(sar.cobertura.ap.wq)
diagPltsSD.wd<-diagPlotlaglm(sd.cobertura.ap.wd)
diagPltsOLS<-diagPlotlaglm(lm.best.cobertura.ap)

#diagPlotsAll<-arrangeGrob(grobs = c(diagPltsOLS,diagPltsSLX,diagPltsSD,diagPltsSEM,diagPltsSAR),ncol = 3, nrow = 5)
grid.arrange (arrangeGrob(grobs = diagPltsOLS, ncol = 3,left ="OLS"),
              # arrangeGrob(grobs = diagPltsSLX, ncol = 3,left = "SLX"),
              # arrangeGrob(grobs = diagPltsSAR, ncol = 3,left =  "SAR"),
              # arrangeGrob(grobs = diagPltsSAR.wq, ncol = 3,left = "SAR Wq"),
              arrangeGrob(grobs = diagPltsSD.wd,ncol = 3, left = "SD Wd"),nrow =2)
```


```{r cauto-sd-copaap-wd}
sm<-summary(sd.cobertura.ap.wd)
r1<-round(c(sm$rho,sm$LR1$statistic,sm$LR1$p.value),digits = 3)
r1<-unname(r1)
t2<-rbind(c("$\\rho$","Likelihood ratio","p-valor"),
          r1)
knitr::kable(unname(t2), digits=3,caption = 'Coeficiente de autocorrelación modelo SD $W_d$ de porcentaje de área de copa ', booktabs = TRUE)
```

```{r coef-sd-copaap}
sm<-summary(sd.cobertura.ap.wd)
t1<-summary(sd.cobertura.ap.wd)$Coef
knitr::kable(t1, digits=3,caption = 'Coeficientes del modelo SD de porcentaje de área de copa $W_d$', booktabs = TRUE)
```




## Acceso a espacios verdes

En el caso de los EV la literatura ofrece variedad de medidas sobre acceso en relación con la distancia o con el área disponible. Se eligieron dos métricas: el porcentaje de área de espacio verde de un sector censal (`area_ep.porcentaje`), para cuantificar beneficios a nivel local; y la razón área disponible entre distancia (`ia.areas.dist`) (ecuación \@ref(eq:areas-dists)) que expresa el acceso más allá de los límites del SU. El valor es cercano a cero cuando el área disponible es cercana a cero o cuando la distancia es mucho mayor que el área media de espacio verde en el radio de búsqueda, limitado a 1000 $m$, un orden de mangitud menor que el área media de EV (`r regresion.EV$area_ep %>% mean() %>% scales::comma(accuracy = 0.1)` $m^2$ ). La distancia promedio del centroide de un SU al conjunto de EV es `r ia.1000.n %>% mean(na.rm = T) %>%  round(digits = 3) %>% scales::comma(accuracy = 0.1)` $m$ . Como se observa en la figura \@ref(fig:mapa-dependienteEV-sel), esta medición parece un versión interpolada del indicador local de acceso `area_ep.porcentaje`, y hace evidentes un patrón espacial de grupos con mejor acceso a EV, no uniforme ni aleatoreo. 

Al examinar la distribución de los valores de estos indicadores (figuras \@ref(fig:hist-areaep) y \@ref(fig:hist-areasdist)) se observa que en ambos indicadores existe asimetría positiva, lo que muestra una concentración de valores por debajo del promedio del indicador y un conjunto reducido de SU muy por encima.  


```{r mapa-dependienteEV-sel, fig.asp= 0.7,fig.cap="Métricas de acceso a espacio verdes seleccionadas"}
su.f %>% dplyr::select(-area_su)  %>%
  left_join(dep.EV.ntl.long,by = c("id"="SETU_CCDGO")) %>%
  filter(dep.EV %in% dependientes.EV.sel) %>%
  ggplot()+
  geom_polygon(data = su.f, aes(x= long, y = lat, group = group), fill = "grey60")+
  geom_polygon(aes(x= long, y = lat, group = group, fill = factor(valores)))+
  coord_equal()+
  scale_fill_viridis( name = "deciles",
                      direction = 1, 
                      discrete = T, 
                      na.value = "grey50",
                      guide = guide_legend(direction = "horizontal",
                                           label.position = "bottom",
                                           title.position = 'top',
                                           nrow = 1))+
  facet_wrap(~dep.EV, nrow = 1)+
  tema_lgnd_abajo()
```



```{r hist-areaep, fig.cap="Distribucion del indicador de acceso local a EV ", fig.show="hold",fig.asp=0.5}
ggplot(regresion.EV)+
  geom_histogram(aes(x = area_ep.porcentaje),bins = 100, 
                 color = "white", fill="darkgreen")+
  geom_vline(xintercept = mean(regresion.EV$area_ep.porcentaje),linetype ="dashed")+
  annotate("text",label =glue("Promedio: {scales::percent(mean(regresion.EV$area_ep.porcentaje))}"),x = mean(regresion.EV$area_ep.porcentaje),y =50, size =4, hjust = -0.05)+
  theme_bw()+
  labs(title ="Histograma",
       x = "Porcentaje de área de EV en un SU",
       y="Cantidad SU")

```



```{r hist-areasdist, fig.cap="Distribucion del indicador de acceso a EV área-distancia ", fig.show="hold",fig.asp=0.5}

promedio_area_dist <- mean(regresion.EV$ia.areas.1000)/mean(regresion.EV$ia.1000)
ggplot(regresion.EV)+
  geom_histogram(aes(x = ia.areas.dist),bins = 100, 
                 color = "white", fill="magenta")+
  # geom_vline(xintercept = promedio_area_dist,linetype ="dashed")+
  geom_vline(xintercept = mean(regresion.EV$ia.areas.dist),linetype ="dotted")+
  # annotate("text",label =glue("{scales::comma(promedio_area_dist,accuracy = .1)}: Razón entre valores promedios de área y distincia"),x = promedio_area_dist ,y =50, size =3, hjust = 0)+
    annotate("text",label =glue(" Promedio del índice: {mean(regresion.EV$ia.areas.dist) %>% scales::comma(accuracy = .1)}"),x = promedio_area_dist ,y =40, size =3, hjust =0)+
  theme_bw()+
  labs(title ="Histograma",
       x = "Razón área distancia",
       y="Cantidad SU")

```



### Correlaciones y distribuciones bivariadas

Las figuras \@ref(fig:tile-ev-poblacion-pearson) y \@ref(fig:tile-ev-poblacion-spearman) resumen los resultados del cálculo de los coeficientes de Pearson y Spearman respectivamente de las variables poblacionales y los indicadores de acceso. Esta relación es muy débil, y en todas las variables (y para ambos coeficientes de correlación) es inferior a 0.3, un valor considerado bajo para seleccionar una variable como candidata a predictor de una regresión lineal. Sin embargo, como parte del proceso para indagar sobre el efecto en la estimación de parámetros de los modelos geoestadísticos, se incluyeron las de mejor correlación: `densidad_poblacion`,`con_alguna_limitacion.porcentaje`  para el índice de acceso `ia.areas.dist` y `ningun_estudio.porcentaje` para `area_ep.porcentaje`.

```{r tile-ev-poblacion-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre acceso a EV y variables de población"}
pintar_corrmatrix_XY(regresion.EV,x=indep.poblacion, y=dependientes.EV.sel)+
    labs(title="Pearson entre acceso a EV \ny variables de población")

```


```{r tile-ev-poblacion-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre acceso a EV y variables de población"}
pintar_corrmatrix_XY(regresion.EV,x=indep.poblacion, y=dependientes.EV.sel, method_cor = "spearman")+
  labs(title="Spearman entre acceso a EV \ny variables de población")
```

El conjunto de variables sobre el uso de los predios y sus coeficientes de correlación con las varibles dependientes se muestran en las figuras \@ref(fig:tile-ev-uso-pearson) y \@ref(fig:tile-ev-uso-spearman). De nuevo las correlaciones son bajas, y aparentemente poco explicativas de los índices de acceso. Las variables de uso de los predios que mejor se relacionan con los índices son: `unidad_economica.porcentaje` y el `cuarto.porcentaje`. 

```{r tile-ev-uso-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre acceso a EV y variables de uso de los predios"}
pintar_corrmatrix_XY(regresion.EV,x=indep.predios, y=dependientes.EV.sel)+
  labs(title="Coeficiente Pearson entre dependiente EV e \nindependientes uso de predios")

```


```{r tile-ev-uso-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre acceso a EV y variables de uso de los predios"}
pintar_corrmatrix_XY(regresion.EV,x=indep.predios, y=dependientes.EV.sel, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre dependiente EV e \nindependientes uso de predios")

```

El último bloque de variables indaga sobre las áreas y proporciones de las manzanas de cada sector censal y la vocación como pública o privada de los espacios dentro de un sector urbano. La figura \@ref(fig:tile-ev-fisica-pearson) y \@ref(fig:tile-ev-fisica-spearman) muestran que el área media de las manzanas (`area_media_manzana`) de los sectores urbanos se relaciona de forma positiva con ambos índices de acceso, mucho más fuertemente que las variables poblacionales y de uso de predios. Aunque parece haber una fuerte correlación de los indicadores de acceso con las áreas privadas, públicas y del sector urbano, estas hacen parte de los cálculos que generan estos índices, produciendo en efecto ficticio en la correlación, razón por la que se incluyen en la modelación.

```{r tile-ev-fisica-pearson, fig.asp=0.65,fig.cap="Coeficiente Pearson entre acceso a EV y variables sobre aspectos físicos de las manzanas y SU"}
pintar_corrmatrix_XY(regresion.EV,x=indep.estruct, y=dependientes.EV.sel)+
  labs(title="Coeficiente Pearson entre dependientes EV e \nindependientes físicas de predios y SU")

```


```{r tile-ev-fisica-spearman, fig.asp=0.65,fig.cap="Coeficiente Spearman entre acceso a EV y variables sobre aspectos físicos de las manzanas y SU"}
pintar_corrmatrix_XY(regresion.EV,x=indep.estruct, y=dependientes.EV.sel, method_cor = "spearman")+
  labs(title="Coeficiente Spearman entre dependientes EV e \nindependientes físicas de predios y SU")

```


En resumen, las variables independientes escogidas para los modelos lineales son:

- Para el `area_ep.porcentaje` los predictores seleccionados son `r str_c(c(indep.poblacion.area_ep.porcentaje.sel, indep.predios_estruct.area_ep.ptje.sel)%>% backtick(), collapse = ", ")  ` . 

- Para `ia.areas.dist`  los predictores seleccionados son `r str_c(c(indep.poblacion.ia.areas.dist.sel,indep.predios_estruct.areas.dist.sel) %>% backtick(), collapse = ", ") `  


### Modelos de regresión lineal EV


La tabla \@ref(tab:coef-lm-ptjeAEV) muestra los coeficientes de la regresión para el porcentaje de EV; la tabla \@ref(tab:coef-lm-areadist) muestra los coeficientes de la regresión para índice áreas-distancia, y la tabla \@ref(tab:ajuste-lmEV-pob-predios) resume las métricas de ajuste de ambos modelos.

Los resultados de los test Shapiro-Wilk indican no normalidad en los residuos en ambos modelos, heterocedasticidad como muestra el test Breusch-Pagan y posibles no linealidades como se observa en las gráficas diagnósticas de la regresión de ambos modelos( ver gráficos \@ref(fig:diagn-lm-areaptj-sel) y \@ref(fig:diagn-lm-areadist-sel)). El nivel explicativo de la variabilidad de los datos de ambos modelos es bajo. Sin embargo, el ajuste de ambos modelos tiene media de los residuos muy cercanas a 0, al igual que el error cuadrático medio (MSE). 


Las variables significativas para el `area_ep.porcentaje` son `r c(indep.poblacion.area_ep.porcentaje.sel, indep.predios_estruct.area_ep.ptje.sel)[c(2,3)] %>% backtick()`. Estos resultados muestran que no existe evidencia significativa de que el acceso a EV en un SU esté relacionado con variables etnicas, de discapacidad o de acceso a la educación. Sin embargo es muy importante la relación positiva con aspectos estructurales representados por el área media de las manzanas (`area_media_manzana`) y una relación negativa con el porcentaje de viviendas tipo cuarto (`cuarto.porcentaje`), estas últimas concentradas en la zona centro y de ladera del área urbana de Santiago de Cali (ver figura \@ref(fig:mapas-usopredios-cont)).

Para la relación de área distancia se confirma la significancia de `r indep.predios_estruct.areas.dist.sel[2] %>% backtick()` y, en ausencia de la variable `cuarto.porcentaje`, se incorpora `unidad_economica.porcentaje` que exhibe un patrón espacial similar. A diferencia del índice local de acceso, en `ia.areas.dist` se evidenció una relación negativa con el porcentaje de personas con alguna limitación (`con_alguna_limitacion.porcentaje`).  


Para la siguientes fases se ingnoraron las variables no significativas de los modelos lineales. 



```{r code-lm-area_ep,echo=FALSE,eval=TRUE,results= "hide"}

dependiente <- "area_ep.porcentaje"
independientes  <- c(indep.poblacion.area_ep.porcentaje.sel, indep.predios_estruct.area_ep.ptje.sel)
# independientes  <- independientes.EV
# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.area_ep.ptje<-crear_lm_from_df(regresion.EV.mn)
summary(lm.area_ep.ptje)

```

```{r code-lm-area_ep-sel,echo=FALSE,eval=TRUE, results="hide"}

dependiente <- "area_ep.porcentaje"
independientes  <- independientes.EV
# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.area_ep.ptje.sel<-lm(area_ep.porcentaje.mxn~cuarto.porcentaje.mxn+
                      # unidad_economica.porcentaje.mxn+
                      area_media_manzana.mxn#+
                      # densidad_poblacion.mxn+
                      #ningun_estudio.porcentaje.mxn
                      ,
                    data = regresion.EV.mn)
summary(lm.area_ep.ptje.sel)

```

```{r coef-lm-ptjeAEV}

# t1<-summary(lm.area_ep.ptje)$coefficients
# knitr::kable(t1, digits=5, caption = "Coeficientes OLS de porcentaje de área de espacios verdes " , booktabs = TRUE)


nombres_coef <- summary(lm.area_ep.ptje)$coefficients %>% row.names() %>% str_remove_all(".mxn") %>% str_replace_all("[\\._]"," ") %>% str_replace("\\(Intercept\\)","Intercepto")
t1<-summary(lm.area_ep.ptje)$coefficients %>% as_data_frame()
t1 %>% bind_cols(terminos = nombres_coef,.) %>% 
knitr::kable( digits=5, caption = "Coeficientes OLS de Porcentaje de EV" , booktabs = TRUE, col.names = c("Término","Estimado","Error std.","t-valor","Pr(>|t|)"))

```









```{r code-lm-areadist,echo=FALSE,eval=TRUE, results="hide" }

dependiente <- "ia.areas.dist"
# independientes  <- independientes.EV
independientes  <- c(indep.poblacion.ia.areas.dist.sel,indep.predios_estruct.areas.dist.sel)


# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.ia.areas.dist<-crear_lm_from_df(regresion.EV.mn)
summary(lm.ia.areas.dist)

```

```{r code-lm-areadist-sel,echo=FALSE,eval=TRUE,results="hide"}
#Ajuste modelo simplificado
dependiente <- "ia.areas.dist"
independientes  <- independientes.EV
# max normalizado 
var_names<-c(dependiente,names(regresion.EV[,independientes]))
regresion.EV.mn<-max_nomalization(regresion.EV,var_names)
lm.ia.areas.dist.sel<-lm(ia.areas.dist.mxn~
                           # cuarto.porcentaje.mxn+
                           unidad_economica.porcentaje.mxn+
                           area_media_manzana.mxn+
                           #densidad_poblacion.mxn+
                           # ningun_estudio.porcentaje.mxn+
                           con_alguna_limitacion.porcentaje.mxn,
                     data = regresion.EV.mn)
summary(lm.ia.areas.dist.sel)

```

```{r coef-lm-areadist}

# t1<-summary(lm.ia.areas.dist)$coefficients
# knitr::kable(t1, digits=5, caption = "Coeficientes OLS de porcentaje de indice de acceso areas-distancia " , booktabs = TRUE)

nombres_coef <- summary(lm.ia.areas.dist)$coefficients %>% row.names() %>% str_remove_all(".mxn") %>% str_replace_all("[\\._]"," ") %>% str_replace("\\(Intercept\\)","Intercepto")
t1<-summary(lm.ia.areas.dist)$coefficients %>% as_data_frame()
t1 %>% bind_cols(terminos = nombres_coef,.) %>% 
knitr::kable( digits=5, caption = "Coeficientes OLS de áreas-distancia" , booktabs = TRUE, col.names = c("Término","Estimado","Error std.","t-valor","Pr(>|t|)"))

```


```{r ajuste-lmEV-pob-predios}
tabla<-fitstats_lm_df(lm.area_ep.ptje.sel) %>% 
  rename(`%EV`=fitstats) %>%
   left_join(fitstats_lm_df(lm.ia.areas.dist.sel),by= "medidasfit") %>%
  rename( `Area-Distancia`=fitstats)
kable(tabla,caption = "Resumen métricas de ajuste OLS Indice contenedor (%EV) y de acceso área-distancia ", digits = 5)


```


```{r diagn-lm-areaptj-sel, fig.cap="Gráficas diagnósticas para OLS del Porcentaje de EV "}



graf<-autoplot(lm.area_ep.ptje.sel, which = 1:4)
# nuevos textos
yLabs <- c("Residuos","Residuos estandarizados",TeX("$\\sqrt{|Residuos estandarizados|}$"),"Distancia de Cook") 
xLabs <- c("Valores ajustados", "Cuantiles teóricos", "Valores ajustados", "Índice de la observación")
titulos <- c("Residuos vs Valores Ajustados","Gráfico Q-Q","Gráfico Escala-Locacion","Distancia de Cook")
# modifcar grafico indivudualmente
for (i in 1:4)
  graf[i] <- graf[i] + xlab(xLabs[i]) + ylab(yLabs[i])+ggtitle(titulos[i])+theme_minimal(base_size = 9)

# desplegar grafico
title1=grid::textGrob(format(as.formula(lm.area_ep.ptje.sel)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)


```



```{r diagn-lm-areadist-sel, fig.cap="Gráficas diagnósticas para OLS de índice área-distancia "}

# graf<-autoplot(lm.ia.areas.dist.sel, which = 1:4)
# title1=grid::textGrob(format(as.formula(lm.ia.areas.dist.sel)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
# grid.arrange( grobs =graf@plots, top=title1)


graf<-autoplot(lm.ia.areas.dist.sel, which = 1:4)
# nuevos textos
yLabs <- c("Residuos","Residuos estandarizados",TeX("$\\sqrt{|Residuos estandarizados|}$"),"Distancia de Cook") 
xLabs <- c("Valores ajustados", "Cuantiles teóricos", "Valores ajustados", "Índice de la observación")
titulos <- c("Residuos vs Valores Ajustados","Gráfico Q-Q","Gráfico Escala-Locacion","Distancia de Cook")
# modifcar grafico indivudualmente
for (i in 1:4)
  graf[i] <- graf[i] + xlab(xLabs[i]) + ylab(yLabs[i])+ggtitle(titulos[i])+theme_minimal(base_size = 9)

# desplegar grafico
title1=grid::textGrob(format(as.formula(lm.ia.areas.dist.sel)) %>% str_c(collapse = "\n"), gp=gpar(fontface="bold",fontsize=8))
grid.arrange( grobs =graf@plots, top=title1)



```






### Modelado espacial de espacios verdes

El proceso de ajuste de los modelos geoestadísticos para el análisis de espacios verdes hace uso de los mismos elementos metodológicos usados para la cobertura de copa. Se usaron las dos matrices de velocidad usando un kernel de vecindad Queen $W_q$ y otro con base en un radio de búsqueda de 1 kilómetro $W_d$ usadas en el análisis del AU (ver figura \@ref(fig:ws-su-reg)).


#### Autocorrelación variables dependientes

Se analizó la autocorrelacieon de las variables dependientes para encontrar agrupaciones existentes en los datos que pueden ser explicados por la estructura de vecindad. Los resultados de los test de Moran I para ambas variables dependientes muestran que existen patrones de agrupamiento y puede rechazarse la hipótesis nula de que los procesos espaciales subyacentes son aleatorios (ver tablas \@ref(tab:moran-areaep-w) y \@ref(tab:moran-areadist-w)). 

Ambos diseños de matriz revelan presencia clara de autocorrelación espacial. La matrix $W_q$ captura mejor la autocorrelación de ambos indicadores. El indicador `ai.areas.dist` exhibe un valor de autocorrelación mucho más alto que `area_ep.porcentaje`. El cálculo del índice `ia.areas.dist` en su construcción usa una distancia de radio de búsqueda de 1 kilómetro; en su definición el indicador está influenciado por sus vecinos por lo que se forman grupos o clusters alrededor de ciertos sectores urbanos. Resulta pues interesante no sea $W_d$ la que capture mejor el agrupamiento.

Los mapas LISA para ambos indicadores de acceso a EV usando la matriz $W_q$ muestran los grupos de sectores autocorrelacionados (figura \@ref(fig:mapas-lisa-areaep-wq) y \@ref(fig:mapas-lisa-areadist-wq)). Los grupos formados muestran agrupaciones de alto acceso a EV en relación al resto de la ciudad.
Se aprecia que se forman cluster alrededor de cuatro zonas en el caso del porcentaje de área de EV y dos para el indicador de relación áreas-distancia, coincidentes con el anterior. Esos sectores albergan equipamentos de ciudad como un cementerio de gran tamaño, las universidades y zonas conservadas de riberas de ríos. El grupo que se forma al oriente de la ciudad es donde se encuentra la laguna del Pondaje. 

Es relevante en los resultados de los análisis que los grupos de alta prestación en los servicios ecosistémicos de los EV configuran evidencia de los sesgos espaciales en la distribución de dichos beneficios. Puede pensarse que la mayor parte de la ciudad exhibe una distribución uniforme, sin embargo, como se muestra en los histogramas de distribución de los valores de ambos indicadores (ver figuras \@ref(fig:hist-areaep) y \@ref(fig:hist-areasdist)), la tendencia es a una baja disponibilidad y acceso a los EV. Puede entonces rechanzarse la hipótesis nula de distribucion espacial aleatoria o uniforme. 




```{r moran-areaep-w}
# mt<-moran.test(lm.area_ep.ptje.sel$model$area_ep.porcentaje.mxn, listw=W_queen.ev) %>% 
mt<-moran.test(regresion.EV$area_ep.porcentaje, listw=W_queen.ev) %>%   
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

# mt2<-moran.test(lm.area_ep.ptje.sel$model$area_ep.porcentaje.mxn, listw=W_dist1000.inv.ev, zero.policy = TRUE) %>%
mt2<-moran.test(regresion.EV$area_ep.porcentaje, listw=W_dist1000.inv.ev, zero.policy = TRUE) %>%
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Porcenatje de EV para $W_q$ y $W_d$" , booktabs = TRUE)

```



```{r moran-areadist-w}
mt<-moran.test(regresion.EV$ia.areas.dist, listw=W_queen.ev) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

mt2<-moran.test(regresion.EV$ia.areas.dist, listw=W_dist1000.inv.ev, zero.policy = TRUE) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Razón área distancia para $W_q$ y $W_d$" , booktabs = TRUE)

```



```{r mapas-lisa-areaep-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de `area_ep.porcentaje`"}

pintar_mapa_su_LISA_var(regresion.EV,"area_ep.porcentaje",W_queen.ev, wname = "Wq",nrow =1)

```



```{r mapas-lisa-areadist-wq,fig.asp=0.618, fig.cap="Mapas LISA para la matriz $W_q$ de `ia.areas.dist`"}

pintar_mapa_su_LISA_var(regresion.EV,"ia.areas.dist",W_queen.ev, wname = "Wq",nrow =1)

```






#### Autocorrelación residuos de los OLS

Para evaluar la utlidad de aplicar modelos espaciales de regresión se examinó la existencia de autocorrelación en los residuos de los modelos de regresión lineal. Se comparó si alguno de las estructuras de vecindad produce resultados significativamente mejores en la deteción de autocorrelación espacial.  

La tabla \@ref(tab:moran-resareaep-w) muestra ambos diseños de matriz $W$ presentan un valor de Moran Global mayor que 0 y significativo para los residuos del OLS del porcentaje de área de EV, al igual que para los residuos del OLS del indicador áreas-distancia (ver \@ref(tab:moran-resareadist-w)).  

En ambos modelos el resultado de autocorrelación espacial suguiere que al introducir retardos espaciales y la estrucutura de vecidad pueden mejorar la estimación de los coeficientes de la regresión y las métricas de desempeño del ajuste.



```{r moran-resareaep-w}
mt<-moran.test(lm.area_ep.ptje.sel$residuals, listw=W_queen.ev) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

mt2<-moran.test(lm.area_ep.ptje.sel$residuals, listw=W_dist1000.inv.ev, zero.policy = TRUE) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Residuos de OLS Porcentaje EV $W_q$ y $W_d$" , booktabs = TRUE)

```



```{r moran-resareadist-w}
mt<-moran.test(lm.ia.areas.dist.sel$residuals, listw=W_queen.ev) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)
nom_estimado_moran <- c("Estadístico Moran I","Expectativa","Varianza",
                        "Desviación estándar de Moran I","p-valor")

mt2<-moran.test(lm.ia.areas.dist.sel$residuals, listw=W_dist1000.inv.ev, zero.policy = TRUE) %>% 
  tidy() %>% 
  select(1:5) %>% 
  slice(1) %>% 
  unlist(use.names = F)

data_frame(metrica =nom_estimado_moran, 
           log_area =mt,
           cobertura =mt2) %>% 
knitr::kable(col.names = c(" ","$W_q$","$W_d$"),
             digits=5,
             caption = "Test de Moran - Residuos de OLS relación áreas distancias para $W_q$ y $W_d$" , booktabs = TRUE)

```




#### Modelo espacial porcentaje de espacio verde 

Dado que la matriz $W_q$ capturó mejor la asociación espacial en los datos para ambos indicadores de acceso a EV, se realizó el ajuste de los modelos espaciales solo con ese diseño.

Las métricas de ajuste de los modelos de porcentaje de área de EV (ver tabla \@ref(tab:tabla-comp-modelos-areaep)) muestran que los modelos espaciales logran eliminar la autocorrelación espacial global en los residuos. Todos los modelos mejoran las métricas de error respecto del OLS y ninguno logra la normalidad ni la homocedasticidad en los residuos.   


Al comparar los resultados de usando el desempeño en AIC se identificó al modelo SEM con el mejor ajuste. El modelo SEM logra eliminar la autocorrelación espacial global en los residuos. El coeficiente  $\lambda$ del término autorregresivos es alto y significativo (tabla \@ref(tab:cauto-sem-areaep)), lo que sugiere que no es necesario plantear efectos de la variables dependientes rezagadas, y que es posible que ese efecto sea por otras variables no tenidas en cuenta. Esta lectura del SEM es interesante y consistente con el significado local del indicador porcentaje de área de EV. 


El resultado del modelo SEM confirma la significancia y efecto positvo para el acceso EV del área de promedio de la manzana en un SU. La presencia de viviendas tipo cuarto, con coeficiente negativos, es un factor que coincide con la disminución de área de EV disponible (ver tabla \@ref(tab:coef-sem-areaep)). Existen cambios y ajustes en los valores de los coeficientes con relación al modelo OLS, que dadas las mejoras en las métricas de ajuste hacen más confiables las estimaciones. 



```{r code-laglm-areaep-wq, echo=FALSE, results="hide"}
#SAR

sar.areas_ep<-lagsarlm(formula = as.formula(lm.area_ep.ptje.sel),
                                    data = lm.area_ep.ptje.sel$model,
                                    listw = W_queen.ev, 
                       zero.policy = T,
                       tol.solve=1.0e-30)

sar.sm<-summary(sar.areas_ep,Nagelkerke=T)
sar.sm

# SEM
sem.areas_ep<-errorsarlm(formula = as.formula(lm.area_ep.ptje.sel),
                           data = lm.area_ep.ptje.sel$model,
                           listw = W_queen.ev, zero.policy = T,
                         tol.solve=1.0e-30)
sem.sm<-summary(sem.areas_ep,
                Nagelkerke=T)
sem.sm
#SD 

sd.areas_ep<-lagsarlm(formula = as.formula(lm.area_ep.ptje.sel),
                        data = lm.area_ep.ptje.sel$model,
                        listw = W_queen.ev, 
                      zero.policy = T,
                      tol.solve=1.0e-30,
                        type = "mixed")
sd.sm<-summary(sd.areas_ep,
               Nagelkerke=T)
sd.sm

#SLX
slx.areas_ep<-lmSLX(formula = as.formula(lm.area_ep.ptje.sel),
                      data = lm.area_ep.ptje.sel$model,
                      listw = W_queen.ev, 
                    zero.policy = T)

slx.sm<-summary(slx.areas_ep)
slx.sm
AIC(slx.areas_ep)

```


```{r tabla-comp-modelos-areaep }

tabla<-fitstats_laglm_df(lm.area_ep.ptje.sel,W_queen.ev) %>% 
  rename(`OLS`=fitstats) %>%
  #  left_join(fitstats_laglm_df(slx.areas_ep, W_queen.ev),by= "medidasfit") %>%
  # rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.areas_ep,W_queen.ev),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.areas_ep,W_queen.ev),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.areas_ep,W_queen.ev),by= "medidasfit") %>%
  rename(`SD`=fitstats)

knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de porcentaje de área de EV con $W_q$")


```



```{r coef-sem-areaep}
sm<-summary(sem.areas_ep)
t1<-summary(sem.areas_ep)$Coef
r1<-round(c(sm$rho,sm$LR1$statistic,sm$LR1$p.value),digits = 3)
r1<-unname(r1)
t2<-rbind(c("$\\lambda$","Likelihood ratio","p-value"),
          r1)
knitr::kable(t1, digits=3,caption = 'Coeficientes del modelo SEM de porcentaje de área de EV', booktabs = TRUE)
```


```{r cauto-sem-areaep}
sm<-summary(sem.areas_ep)
r1<-round(c(sm$lambda,sm$LR1$statistic,sm$LR1$p.value),digits = 3)
r1<-unname(r1)
t2<-rbind(c("$\\lambda$","Likelihood ratio","p-value"),
          r1)
knitr::kable(unname(t2), digits=3,caption = 'Coeficiente de autocorrelación modelo SEM de porcentaje de área de EV', booktabs = TRUE)
```




#### Modelo espacial del índice de acceso área-distancia 



Las métricas de ajuste de los modelos de indicador área-distancia (ver tabla \@ref(tab:tabla-comp-modelos-areasdist)) muestran que los modelos espaciales logran eliminar la autocorrelación espacial global en los residuos. Todos los modelos mejoran las métricas de error respecto del OLS, en particular el *Nagelkerke*, equivalente al *adj-Rsquare*, que mide el nivel explicativo del modelo en la variabilidad de los datos, subiendo de $\simeq 0.17$ a $\simeq 0.74$. 


Al comparar los resultados usando el desempeño en AIC se identificó al modelo SD con el mejor ajuste. El modelo SD logra eliminar la autocorrelación espacial global en los residuos. El coeficiente  $\rho$ del término autorregresivos es muy alto y significativo (tabla \@ref(tab:cauto-sd-areasdist)), lo que sugiere que los efectos de las variables dependientes rezagadas so significativos. Existen cambios y ajustes en los valores de los coeficientes con relación al modelo OLS, que dadas las mejoras en las métricas de ajuste hacen más confiables las estimaciones ( y se corrobora con las gráficas diagnósticas de la figura \@ref(fig:diag-model-areasdist-espaciales)). 


El resultado del modelo SD confirmó la significancia y efecto positvo pero bajo en el acceso a EV contar con unidades económicas dentro del SU. Es significativo y fuerte en el acceso a EV estar al rededor de SUs con manzanas de área promedio grande. Por otro lado se desestima que exista una relación con la variable  porcentaje personas con alguna limitación (ver tabla \@ref(tab:coef-sem-areasdist)). La escogencia del modelo SD se ajusta consistentemente con el propósito del indicador áreas-distancia de medir el acceso en un SU más allá de su límite geográfico.




```{r code-laglm-areasdist-wq, echo=FALSE, results="hide"}
#SAR

sar.areas.dist<-lagsarlm(formula = as.formula(lm.ia.areas.dist.sel),
         data = lm.ia.areas.dist.sel$model,
         listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30)

sar.sm<-summary(sar.areas.dist,Nagelkerke=T)
sar.sm

# SEM
sem.areas.dist<-errorsarlm(formula = as.formula(lm.ia.areas.dist.sel),
                                      data = lm.ia.areas.dist.sel$model,
                                      listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30)
sem.sm<-summary(sem.areas.dist,Nagelkerke=T)
sem.sm
#SD 

sd.areas.dist<-lagsarlm(formula = as.formula(lm.ia.areas.dist.sel),
                                    data = lm.ia.areas.dist.sel$model,
                                    listw = W_queen.ev, zero.policy = T,tol.solve=1.0e-30,
                                    type = "mixed")
sd.sm<-summary(sd.areas.dist,Nagelkerke=T)
sd.sm

#SLX
slx.areas.dist<-lmSLX(formula = as.formula(lm.ia.areas.dist.sel),
                           data = lm.ia.areas.dist.sel$model,
                           listw = W_queen.ev, zero.policy = T)

slx.sm<-summary(slx.areas.dist)
slx.sm
AIC(slx.areas.dist)

```

```{r tabla-comp-modelos-areasdist }

tabla<-fitstats_laglm_df(lm.ia.areas.dist.sel,W_queen.ev) %>% 
  rename(`OLS`=fitstats) %>%
  #  left_join(fitstats_laglm_df(slx.areas.dist, W_queen.ev),by= "medidasfit") %>%
  # rename(`SLX`=fitstats) %>%
   left_join(fitstats_laglm_df(sar.areas.dist,W_queen.ev),by= "medidasfit") %>%
  rename(`SAR`=fitstats) %>%
   left_join(fitstats_laglm_df(sem.areas.dist,W_queen.ev),by= "medidasfit") %>%
  rename(`SEM`=fitstats) %>%
   left_join(fitstats_laglm_df(sd.areas.dist,W_queen.ev),by= "medidasfit") %>%
  rename(`SD`=fitstats)

knitr::kable(tabla, digits = 5, caption = "Metricas de ajuste para los modelos de áreas-distancia de EV")


```



```{r coef-sd-areasdist}
sm<-summary(sd.areas.dist)
t1<-summary(sd.areas.dist)$Coef
knitr::kable(t1, digits=3,caption = 'Coeficientes del modelo SD índice de relación área distancia de EV', booktabs = TRUE)
```


```{r cauto-sd-areasdist}
sm<-summary(sd.areas.dist)
r1<-round(c(sm$rho,sm$LR1$statistic,sm$LR1$p.value),digits = 3)
r1<-unname(r1)
t2<-rbind(c("$\\rho$","Likelihood ratio","p-value"),
          r1)
knitr::kable(unname(t2), digits=3,caption = 'Coeficiente de autocorrelación modelo SD índice de relación área distancia de EV', booktabs = TRUE)
```





```{r diag-model-areasdist-espaciales, fig.asp=0.6, fig.cap="Diagnóstico comparativo entre modelos"}
diagPltsSAR<-diagPlotlaglm(sar.areas.dist)
# diagPltsSEM<-diagPlotlaglm(sem.areas.dist)
# diagPltsSD<-diagPlotlaglm(sd.areas.dist)
# diagPltsSLX<-diagPlotlaglm(slx.areas.dist)
diagPltsOLS<-diagPlotlaglm(lm.ia.areas.dist.sel)

#diagPlotsAll<-arrangeGrob(grobs = c(diagPltsOLS,diagPltsSLX,diagPltsSD,diagPltsSEM,diagPltsSAR),ncol = 3, nrow = 5)
grid.arrange (arrangeGrob(grobs = diagPltsOLS, ncol = 3,left ="OLS"),
              # arrangeGrob(grobs = diagPltsSEM, ncol = 3,left ="SEM"),
              arrangeGrob(grobs = diagPltsSD,ncol = 3, left = "SD"),nrow =2)
```




